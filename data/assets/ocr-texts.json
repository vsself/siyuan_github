{
  "assets/image-20230321105834-jb5wxx9.png": "5 操作系统的运行机制是怎样的OIE操作系统的运行机制。 re人申断处理过程nmD--国人-6 一@关中断@引出中断产生一个故障中断FESTt 指令2 a wanes一一指令3指令4 IPS",
  "assets/image-20230321110707-o83d4go.png": "第一章bean的元数据一、回顾bean的注入方式1、xmlI1 \u003cbean id=\"user\" class=\"com.ydlclass.User\" scope=\"prototype\" autowire=\"byType\" init-method=\"init™depends-on=\"a,b\" \u003e\u003cproperty name=\"name\" value:\u003cproperty name=\"age\" value=\"4 \u003c/bean\u003e\"jerry\"/\u003e8\"/\u003exm2. TERR1 @Controller2 public class UserService {}1 @Service2 @Dependson(value = {\"xxx\", \"yyyy\"})3 public class UserService {}1 @Repository2 public class UserDao {}@Compoment@Dependson(value = {\"xxx\", \"yyyy\"})public class RedisTemplate {}wm",
  "assets/image-20230321140007-dmssm6m.png": "(@Uverride ipublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactc// Don't override the class with CGLIB if no overrides.if (!bd.hasMethodOverrides()) {Constructor\u003c?\u003e constructorToUse;synchronized (bd.constructorArgumentLock) {",
  "assets/image-20230321140039-s6d1609.png": "Jelse {// Must generate CGLIB subclass.return instantiateWithMethodInjection(bd, beanName, owner);",
  "assets/image-20230321144830-eriw3ec.png": "no usages@Testpublic void test(){Object user = beanFactory.getBean( name: \"user\");Object userFactory = beanFactory.getBean( name: \"\u0026user\");logger.info(\"user --\u003e{} \",user);° logger.info(\" --\u003e{} \",userFactory) ;©: ww Tests passed: 1 of 1 test - 275 mstoryTest (com.ydiclass.spr 275 ms275 msBeanFactoryTest : Starting BeanFactoryTest using Java 17.0.5 with PID 11576 (started byBeanFactoryTest : No active profile set, falling back to 1 default profile: \"default\"BeanFactoryTest : Started BeanFactoryTest in 0.923 seconds (process running for 1.554)BeanFactoryTest : user --\u003eUser{username='###)i', age=30}BeanFactoryTest : userFactory --\u003ecom.ydlcLlass .UserFactoryBean@5ae15",
  "assets/image-20230321145448-0tdre2t.png": "public class UserFactoryBean implements FactoryBean\u003cUser\u003e {@Overridepublic User getObject() throws Exception {return new User( username: \"楠老师\"，age: 30);@Overridepublic Class\u003c?\u003e getObjectType() {return User.class|;",
  "assets/image-20230321151448-sxtm87h.png": "@Component(\"user|\")public class UserFactoryBean implements FactoryBean\u003cUser\u003e {@Overridepublic User getObject() throws Exception {// 可能很复杂，帮助我们完成复杂对象的创建return new User( username: \"楠老师\"，age: 30);@Overridepublic Class\u003c?\u003e getObjectType() {return User.class;",
  "assets/image-20230321151805-cey2u26.png": "二、bean工厂的创建一个典型的功能强大的bean工厂实现，就是DefaultListableBeanFactory，事实上我们的容器中维护的beanFactory都是这个类的实例;我们看一下该类的类图:这里简单的总结一下，一个完整的bean工厂应该具备哪些能力?1、bean工厂的芭础能力，枚举bean，分层，自动装配、独立配置等。2、注册单例bean (包括Factorybean) 的能力。3、注册别名的能力。",
  "assets/image-20230321151947-pqwody2.png": "地YY| 上下文创建后，我们该做人什么。 。 |。 bean工厂创建后，我们该做什么|| 所有的beanDefinition注册后，我们二点什么，比如再注册一些bean实例化前，我们干点什么bean实例化后，我们干点什么bean的属性填充前，我们干点什么bean MERI, RFRAhbean调用初始化方法前，我们干点什么bean调用初始化方法后，我们干点什么所有的bean都实例化完成了，我们干点祭4 - - ---- -一-\u003espringSSSeTHRRRIS BA SPRAPOSTProcessor, tH0/EHSs. Mee EBANBeanFactoryPostProcessor#f]BeanPostProcessor，我们可以写如下的用例做测试:",
  "assets/image-20230321152144-6wh3s3t.png": "四、了解扩展点spring给我们提供了很多的扩展点，这些扩展点可以多许我们在spnng上下文启动的任意环节进行干预，实现自己的膛辑。我们大致将spring的启动环节回一个图，当然他可能不准确，我们只是想将大致的环节勾勒出来，然后看看其中的可以扩展的地方。后午处理器的核心作用就是当容器的一项工作做完了，我们可以做点什么补充扩展atopen \u003e ,Y v上下文创建后，我们该做什么bean工厂创建后，我们该做什么所有的beanDefinition注册后，我们干点人— - - - _ - \u003e么，比如再注册一些bean实例化前， 了们二点什么—_\u003e \u003c\u003ebean实例化后，我们干点什么+-- : ea eet 1bean的属性填充前，我们干点什么w--F \u003e \u003ebean的属性填充后，我们干点什么人\\----\u003c@ \u003e\u003e :bean调用初始化方法前，我们干点什么4 i ibeaniMMMKARE, RFRA 4- - - ~~~ -\u003c \u003e \u003c\u003e-一一一一所有的bean都实例化完成了，我们干点祭4 - -----------\u003e",
  "assets/image-20230321152210-tt32bxy.png": "当然实现类内容和过程基本一致，如下:1 public AnnotationConfigApplicationContext(String... basePackages) {2 thisQ:3 scan(basePackages) ;4 refreshQ);5 }refresh()方法被定义在AbstractApplicationContextd个大章节进行讲解。和，该方法会引导spring8上下文的启动，所以十分重要，下边我们会和独出一",
  "assets/image-20230321152308-c9hafch.png": "我们观豪一下这个实现类的构造器如下，整个构造的过程如下，在之前的课程中，我们已经学习了加载beanDefintion的过程，下个章节我们就进入【刷新容器的部分】:1 public GenericXm1App1icatipnContext(Resource... resources) {2 J/ 1、加载资源3 load(resources);4 // 2、刷新容器5 refreshgO ;5 }",
  "assets/image-20230321152743-ntmgpcr.png": "我们在之前的学习中常常下的ApplicationContext实现: FileSystemXmlApplicationContext,ClassPathXmlApplicationContext这里就不演示了。spring3.0之后我们更推荐如下的实现类，GenericApplicationContext作为一个通用的上下文类，给我们提供了丰富的实现, 如下:wu NYous1112@Testpublic void testxmlConfigQO{GenericxmlApplicationContext xmlApplicationContext = newGenericxmlApplicationContext(\"classpath:spring.xm1\");User user = xmlApplicationContext.getBean(User.class);System. out.printIn(user);]] -一xmlApplicationContext = new GenericxmlApplicationContext(\"file:D://spring. xml\");user = xmlApplicationContext.getBean(User.class);System. out.printIn(user);",
  "assets/image-20230321152811-0akpd56.png": "我们编写如下测试类，然3析一下，我们注册的线程会在何时调用1 public class TestBeanFactory {23 @Testzl public void testxmlConfig() throws InterruptedException {5 MyGenericApplicationContext myGenericApplicationContext = newMyGenericApplicationContext() ;6 myGenericApplicationContext. registerShutdownHook() ;7 System.out.printin(\"before\");8 Thread.sleep(2000) ;9 System.out.printIn(\"after\");10 }11 }1213 GR:14 before I15 after16 BSA, wre Tew!",
  "assets/image-20230321152832-ofx5cwe.png": "我们可体会一下registerShutdownHook的用法，我们自己写一个容器类继承GenericApplicationContext:1 public class MyGenericApplicationContext extends GenericApplicationContext {23 private Thread shutdownHook = null;45 @Override6 public void registerShutdownHook() {7 if (this.shutdownHook == null) {// No shutdown hook registered yet.3 this.shutdownHook = new Thread(SHUTDOWN_HOOK_THREAD_NAME) {10 @Ooverrideuu public void runQ {12 System.out.println(\"容器关闭了，该干啥干啥吧! \");13 }14 515 Runtime. getRuntime() . addShutdownHook (this . shutdownHook) ;16 } I17 +",
  "assets/image-20230321152849-cmytgdh.png": "// 配置和获取环境对象void setEnvironment(ConfigurableEnvironment environment) ;ConfigurableEnvironment getEnvironmentQ);// 设置一个启动器void setApplicationStartup(ApplicationStartup applicationStartup) ;ApplicationStartup getApplicationStartup();// 增加BeanFactoryPostProcessorvoid addBeanFactoryPostProcessor(BeanFactoryPostProcessor postProcessor) ;// 增加/删除Listenervoid addApplicationListener (ApplicationListener\u003c?\u003e listener);void removeApplicationListener(ApplicationListener\u003c?\u003e listener);// 设置类加载器void setClassLoader(ClassLoader classLoader);// 增加协议解析策略， 我们可以定义对应解析器解析自定义协议void addProtocolResolver(ProtocolResolver resolver);// PRBS, BPHvoid refreshQ) throws BeansException, IllegalStateException;// PIWMETNAM-TARABT, EIWAAMKAMETR, RECS RARA, TMADMT-void registerShutdownHook() ;// 关闭这个容器释放她锁定的所有的资源Goverridevoid close();// 确定一个上下文是否是活跃的，已经被刷新，没有关闭boolean isActiveQ);// 获得上下文中持有的bean工厂ConfigurableListableBeanFactory getBeanFactory() throws I11egalStateException;",
  "assets/image-20230321152906-17cbz7m.png": "其子接口ConfigurableApplicationContextz寺ApplicationContext进行了扩展:1 public interface ConfigurableApplicationContext extends ApplicationContext, Lifecycle, Closeable {23 // 定义配置路径的分隔符4 String CONFIG_LOCATION_DELIMITERS = \",; \\t\\n\";56 // ConversionServicefJ BF7 String CONVERSION_SERVICE_BEAN_NAME = \"“conversionService\";8 String LOAD_TIME_WEAVER_BEAN_NAME = “loadTimeWeaver\"™;9 String ENVIRONMENT_BEAN_NAME = “environment”;10 String SYSTEM_PROPERTIES_BEAN_NAME = “systemProperties\";11 String SYSTEM_ENVIRONMENT_BEAN_NAME = “systemEnvironment\";12 String APPLICATION_STARTUP_BEAN_NAME = \"“applicationStartup\";13 String SHUTDOWN_HOOK_THREAD_NAME = “SpringContextShutdownHook\" ;1415 // 给上下文设置一个唯一的id16 void setId(String idys1718 // 设置一个父上下文19 void setParent(@Nullable ApplicationContext parent);",
  "assets/image-20230321152958-yj2ev54.png": "一个ApplicationContext继承了五个接口，共同为一个上下文赋能，这些接口我们都已经接触过了:1. EnvironmentCapable: 提供一个上下文环境的能力2. ListableBeanFactory: 枚举bean工厂的bean的能力3. HierarchicalBeanFactory: 分层的能力4. MessageSource: 国际化的能力5. ApplicationEventPublisher: 发布事件的能力1 public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory,HierarchicalBeanFactory,MessageSource, ApplicationEventPublisher, ResourcePatternResolver {23 // 返回一个4 @Nullable5 String getId(Q); I67 // 返回此上下文所属的已部署应用程序的名称。8 String getApplicationName();910 // 返回此上下文的显示名称11 String getDisplayName(Q);1213 // 返回第一次加载此上下文时的时间戳。14 long getStartupDate();1516 // BORER17 @Nul lable18 ApplicationContext getParent();1920 // 为此上下文公开AutowireCcapab1eBeanFactory功能。21 AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;2223}",
  "assets/image-20230321153027-ajfhfn9.png": "三、认识SpringApplicationSpringApplication是应用程序的中央接口，提供一些便利的功能，引导Spring的程序进行启动，他是我们学习spring中的重中之重, 理解了SpringApplication我们就学会了spring。spring8上下文提供了丰富的功能，拥有强大的能力，一切的spring的知识内其实都是为了服务个SpringApplication，下图展示了SpringApplication中的一些核心接口和类:usaiessenectarne) ——7 Messagetourcetto本和a se i seabgatasyanenanooscationC anteRS REEN cs Ca3 ‘Feleccenaowesaa cereicapolcaontoet ‘cenercwebaccicanenCorersAAPWERADplicaboaComeah®, preg3. ERE \"i ARCANE TRAsa‘Aeerectheremnaniecontgtosieatarc ntact 8 8 eenereninciseatanonent nesRANA aiE ROR Arnatatontaniighpohaionreent \u003e zar 本至全下上下= \" . Ganramamingpicaton omen ath \u0026 er",
  "assets/image-20230321153143-5rmgec3.png": "三、了解扩展点3pring给我们提供了很多的扩展点，这些扩展点可以多许我们在spring上下文启动的任意环节进行十蔬，实现自己的逻辑。我们大致将spring的启动环节画一个图，当然他可能疏售确，我们只是想将大致的环节勾勒出来，然后看看其中的可以扩展的地方。后置处理器的核心作用就是当容器的一项工作做完了，我们可以做点什么补充扩展5 amen“tmsetain 5 \u003e¥ Y上下文创建后，我们该做什么bean工厂创建后，我们该做什么所有的beanDefinition注册后，我们干点什么，比如再注册一些bean实例化前，我们干点什么bean实例化后，我们干点什么bean的属性填充前，我们干点什么bean的属性填充后，我们干点什么bean调用初始化方法前，我们干点什么bean调用初始化方法后，我们干点什么所有的bean都实例化完成了，我们干点人4 - -----------\u003c\u003c",
  "assets/image-20230321153524-7ewagu3.png": "spring给我们提供的常用的扩展点称为POSTProcessor，也叫后填器。而我们最常使用的BeanFactoryPostProcessor和BeanPostProcessor，我们可以写如下的用例做测试:",
  "assets/image-20230321153702-agmifdh.png": "@Componentpublic class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {@Override :@ public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {// 核心目的是对bean工三做额外的于预System.out.printLn(\"beanFactory-----------------\u003epostProcessBeanFactory\");",
  "assets/net-img-1679220173791-d23b4e93-e0dd-451c-b835-cf3d75f3c819-20230321111820-lvk5c4d.png": "第一章bean的元数据一、回顾bean的注入方式1, xml1 \u003cbean id=\"user\" class=\"com.ydlclass.User\" scope=\"prototype” autowire=\"byType\" init-method=\"init\"depends-on=\"a,b\" \u003e2 \u003cproperty name=\"name\" value=\"jerry\"/\u003e\u003cproperty name=\"age\" value=\"18\"/\u003e4 \u003c/bean\u003exm2、注解1 @Controller2 public class UserService {}1 @Service2 @DependsOn(value = {\"xxx\", \"yyyy\"})public class UserService {}@Repositorypublic class UserDao {}N@Compoment@DependsOn(value = {\"xxx\", \"yyyy\"})public class RedisTemplate {}w_ N",
  "assets/net-img-1679220204295-999f5b86-982f-4c75-ac95-aaa5f1f1f9a9-20230321111820-v94mc0g.png": "3、配置类1 |pconFiguration!2 public class Userconfiguration {3 egeanCuser{public User userOt5 User user =6 user. setnaneC7 user. setage(20);8 return user;310}4、import注解1 public class wyselector inplements Iaportselector {2) @override2, public string() selectrmports (amotationetadata importingclassNetadata) {4 return new String[]{\"con. ydlclass.Userservice\", \"com.ydlcTass.UserDa0\"}:5 了18 @ConFigurationrmport(yselector.class)10 public class Userconfiguration ()",
  "assets/net-img-1679223702869-36c67154-04b8-4566-9dc3-d4eb1cc66ffe-20230321111820-q8c5gxy.png": "spring在构造bean时，不可能像我们主动构造那样，随心所欲的new，赋值、已经完成方法调用。他需要将千差万别的class概括成为一种【统一的措述性】语言，spring提供了一个接口BeanDefintion为我们统一了这种描述bean的元数据。bean的元数据通常是我们使用xml或者注解进行配置的数据，我们的spring容器启动之间第一步就是加载配置数据，这些元数据会被加载到内存以一个个beanDefinition的形式保存在一个map中。一个BeanDefiniiton大概保存了以下信息:1. 定义了id、别名与Bean的对应关系(BeanDefinitionHolder)2. 具体的工厂方法(Class类型) ，包括工厂方法的返回类型，工厂方法的Method对象3. 构造函数、构造函数形参类型4, Bean的class对象5. 作用范围、是否懒加载等等以下是BeanDefiniiton的类的结构图，这里没有用类图，我觉得这里用这样的图好看一些:",
  "assets/net-img-1679223821449-8dc7fdbc-c29f-4957-b438-e445991b1d46-20230321111820-cdfk43a.png": "BeanDefinition接口该接口提供了检索、修改Bean的元数据的能力，并定义了一些基础数据VvAnnotatedBeanDefinition##0该接口拥有访问特定注解元数据的能力，不需要加载类就能访问，直接解析类文件(ASM)抽象类|GenericBeanDefinition类Spring2.5以后提供的通用BeanDefinition实现，该类通过parenetName属性来灵活(动态) 设置parent bean definition可AbsractBeanDefinition抽象类提供了基本的方法实现，定义了一系列属性vps charg#8BeanDefinition,ChildBeanDefinition配合构建父子关系的bean可ConfigurationClassBeanDefinition类负责将@Bean注解的方法转换为对应的ConfigurationClassBeanDefinition类vvScannedGenericBeanDefinition#基于ASM扫描宝的类文件加载Bean的定义存储@Cconpoment、@sSservice、@Controller等注解注释的类| |AnnotatedGenericBeanDefinition在基于注解驱动的Spring应用着，它使用的非常多|ChildBeanDefinitionChildBeanDefinition@—#bean definition，它可以继承它父类的设置，对RootBeanDwtfinition有一定的依赖关系Mt: 自Spring2.5以来，以编程方式注册bean定义的首选方法是GenericBeanDefinition类，它允许通过GenericBeanDefinition动态定义依赖项。setparentName方法。对于大多数用例，这有效的取代了childBeanDefinition类。",
  "assets/net-img-1679236554503-b8c0494c-6eea-4b47-9e8b-35ed317ef69d-20230321111820-2nkz8sl.png": "GenericBeanDefinition在很多场景可以车换以上的内容，但是由于历史等原因，RootBeanDefinition依旧存在而且很重要，后期T的归一处理还是要糙不同的BeanDefinition转换或合并至一个RootBeanDefinition :RootBeanDefinition与AbstractBeanDefinition是互补关系，RootBeanDefinition在AbstractBeanDefinition的基础上定义了更多属性。RootBeanDefinition不能有父BeanDefinition，可以和ChildBeanDefinition配合使用构建父子关系(bean是可以继承的) 。目前最常用的BeanDefinition是GenericBeanDefinition及其子类的实现，GenericBeanDefinition很强大，也可以很轻松的独立的构建父子关系。有时为了统一调用，不同的BeanDefinition可以合并、拷贝等。1 // 转换的2 GenericBeanDefinition definition = new GenericBeanDefinition(teddy) ;3 // 合并的4 definition. overrideFrom(dog) ;",
  "assets/net-img-1679236644604-b2904706-3d41-428e-87b0-f863169e76ee-20230321111820-8sfwnja.png": "1 @Test2 public void testRootBeanDefinition() throws ClassNotFoundException, NoSuchMethodException,InvocationTargetException, InstantiationException, I]llegalAccessException {3 RootBeanDefinition dog = new RootBeanDefinition();4 dog.setBeanClassName(\"com.yd1class.Dog\");5 BeanMetadataAttribute color = new BeanMetadataAttribute(\"color\", “white\");6 BeanMetadataAttribute age = new BeanMetadataAttribute(\"age\",\"3\");7 dog. addMetadataAttribute(color);8 dog. addMetadataAttribute(age) ;10 // 子Definition的创建需要依赖父Definition11 ChildBeanDefinition teddy = new ChildBeanDefinition(\"dog\");12 teddy. setBeanC lassName(\"com. ydIclass.TeddyDog\") ;13 BeanMetadataAttribute name = new BeanMetadataAttribute(\"name\", “doudou\");14 teddy. addMetadataAttribute(name) ;15 了",
  "assets/net-img-1679236680842-5fa68152-2acf-47db-be63-dcbe0836be73-20230321111821-mqfkw10.png": "有了统一标准的元数据之后，我们就可以统一管个容器去存储，当然我们可以使用map这样的集合类，当然spring差不多也是这样做的，他为我们提供了一个接口BeanDefinitignRegistry。只要实现了这个接口，就会盾有注册beanDefinition的能力。",
  "assets/net-img-1679236740877-01562681-23d5-40e0-ba7c-45d7ad3e7b7b-20230321111821-7vi09f3.png": "BeanDefinitionRegistry接口如下:1 public interface BeanDefinitionRegistry extends AliasRegistry {23 // 注册一个BeanDefinition4 void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)56throws BeanDefinitionStoreException;void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;9 BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;1011 boolean containsBeanDefinition(String beanName) ;1213 String[] getBeanDefinitionNames();14 IL15 int getBeanDefinitionCount();1617 boolean isBeanNameInUse(String beanName) ;1819|}一个bean可以有一个d，和多个名字或别名，AliasRegistry为我们提供了注册别名的能力: 一1 public interface AliasRegistry {2 void registerAlias(String name, String alias);3 void removeAlias(String alias);4 boolean isAlias(String name);5 String[] getAliases (String name);6 }",
  "assets/net-img-1679238637663-5dbd8fa3-33e4-4894-bdeb-8aae984594d7-20230321111821-r62jqgp.png": "四、加载BeanDefinition当然我们不可能为每一个类手动编写与之对应的BeanDefinition，元数据还是要从xml或注解或配置类中获取，spring也为我们提供了对应的工具。1、读取xml配置文件该类通过解析xml完成BeanDefinition的读取，并且将它解析的BeanDefinition注册到一个注册器中:1 @Test2 public void téstRegistryByxm]O{34 // 定义一个注册器，用来注册和管理BeanDefinition5 BeanDefinitionRegistry registry = new SimpleBeanDefinitionRegistryQ;67 // 通过xm]文件加载8 Xm1BeanDefinitionReader xmlReader = new Xm1BeanDefinitionReader(Cregistry);9 xmlReader. loadBeanDefinitions(\"classpath: spring. xml\");1011 logger. info(Arrays. toString(registry. getBeanDefinitionNames()));12 }java",
  "assets/net-img-1679238699003-cd8ecc96-f282-406c-833f-07646dcc032c-20230321111820-5py8p0p.png": "xml可b必0下定义:1 \u003cbean id=\"dog”class=\"com.ydlclass.Dog\"\u003e2 \u003cproperty name=\"color\" value=\"white\"/\u003e3 \u003cproperty name=\"age\" value=\"3\"/\u003e4 \u003c/bean\u003e56 \u003cbean id=\"teddyDog\" class=\"com.ydlclass.TeddyDog\" parent=\"dog\"\u003e7 \u003cproperty name=\"name\" value=\"“)2L\"/\u003e8 \u003c/bean\u003e如果是手动定义如下:",
  "assets/net-img-1679238719964-9973bce2-4985-4baa-b6bb-23e00534994b-20230321111820-umso8u8.png": "我们再测试一种具有继承关系的bean:public class Dog {private String color;12zl private Integer age;41056public class TeddyDog extends Dog{private String name;©ww",
  "assets/net-img-1679238818018-db52233f-aa16-45bd-9964-8ddc6dba12d1-20230321111821-cw0xke5.png": "spring给我们提供了一个超级简单的实现SimpleBeanDefinitionRegistry，如下:1 public class SimpleBeanDefinitionRegistry extends SimpleAliasRegistry implementsBeanDefinitionRegistry {23 // 维持一个map用来保存beanDefinition ，就这么简单4 private final Map\u003cString, BeanDefinition\u003e beanDefinitionMap = new ConcurrentHashMap\u003c\u003e(64);56 // 对beanDefinition的增删查改7 @Override Ipublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)9 throws BeanDefinitionStoreException {10 Assert. hasText(beanName, \"'beanName' must not be empty\");11 Assert.notNull(beanDefinition, “BeanDefinition must not be null\");12 this. beanDefinitionMap. put(beanName, beanDefinition) ;",
  "assets/net-img-1679238872932-ee38eae7-8254-4f61-beff-31682ce08725-20230321111821-aq5smsa.png": "上// 定义一个注册器，用来注册和管理BeanDefinitionBeanDefinitionRegistry registry = new SimpleBeanDefinitionRegistry(Q);// 代码方式创建GenericBeanDefinition beanDefinition = new GenericBeanDefinition();beanDefinition.setBeanClassName(\"com.ydlclass.User\");MutablePropertyValues propertyValues = new MutablePropertyValues();propertyValues.addPropertyValue(\"name\",\"lily\");propertyValues.addPropertyValue(\"age\",12);beanDefinition.setPropertyValues (propertyValues) ;// 进行注册registry.registerBeanDefinition(\"user\" ,beanDefinition);1ogger.info(C\"The beanClassName is {}.\",beanDefinition. getBeanClassName());",
  "assets/net-img-1679238917924-9e693269-5388-4438-8680-d99da3013f39-20230321111821-4v8cnu7.png": "2、加载带注解的bean1 @Test2 public void testRegistryByAnnotation(){24 // 定义一个注册器, 用来注册和管理BeanDefinition5 BeanDefinitionReyistry registry = new SimpleBeanDefinitionRegistryQ;67 // 通过配置文件加载8 AnnotatedBeanDefinitionReader annoReader = new AnnotatedBeanDefinitionReader (registry);9 annoReader. register(User.class);10 logger. info(Arrays. toString(registry. getBeanDefinitionNames()));ih |p3、读取配置类ConfigurationClassBeanDefinitionReader可以读取配置类，只是这个类不让我们使用，该类审供了如下方法:1 private void loadBeanDefinitionsForConfigurationClass2 private void registerBeanDefinitionForImportedconfigurationClass3 private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod)他会将读取的元数据封装成为: ConfigurationClassBeanDefinition。",
  "assets/net-img-1679239470463-98ce2a69-4253-44c4-a20f-0720c952ab24-20230321111821-tbwu5zu.png": "4、类路径扫描1 @Test2 public void testRegistryByScanner(){34 // 定义一个注册器，用来注册和管理BeanDefinition5 BeanDefinitionRegistry registry = new SimpleBeanDefinitionRegistry();67 // 通过扫描包的方式8 ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner (registry);9 scanner.scan(\"com.ydiclass\");10 logger. info(Arrays.toString(registry. getBeanDefinitionNames()));11 了java",
  "assets/net-img-1679239688573-c0acc7cb-94d8-45c1-88ec-2f3bea86ea52-20230321111821-85ehyf7.png": "5、包扫描的过程无台是扫包还是其他方式，我们我们解析一个类无非有几种方式:。 加载一个类到内存，获取Class对象，通过反射获取元数据。 再而证(class) ，读取字节码内的元数据毫无疑问sprin8选择了第二种，。 首先: 第二种性能要优于第一种其次: 第一种会将扫描的类全部加载到堆内存，无疑会浪费空间，增加gc次数，第二种可以根据元数据按需加载我们以包扫描的doScan方法为例(ClassPathBeanDefinitionScanner类) :",
  "assets/net-img-1679239712766-3287c891-785f-4cee-bb98-dd8cef4c0474-20230321111822-cw87lor.png": "// 首先从注解中获取bean的名字，如果没有// 使用beanName生成器beanNameGenerator来生成beanName// 在注解中的bean的默认名称和xm]1中是不一致的// 注解中如果没有指定名字本质是通过ClassuUti1 的getshortName 方法获取的String beanName = this.beanNameGenerator .generateBeanName(candidate，this.registry);// 将进一步设置应用于给定的BeanDefinition ，使用AbstractBeanDefinition的一些默认属性值//设置autowireCandidate属性，即XML的autowire-candidate属性，IoC学习的时候就见过该属性，默认为true，表示该bean支持成为自动注入候选beanif (candidate instanceof AbstractBeanDefinition) {postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);}// 如果bean定义是AnnotatedBeanDefinition类型，ScannedGenericBeanDefinition同样属于AnnotatedBeanDefinition类型if (candidate instanceof AnnotatedBeanDefinition) {// 4 处理类上的其他通用注解: GLazy, @Primary, @DependsOn, GRole, @DescriptionAnnotationConfigUti 1s. processCommonDefinitionAnnotations ((AnnotatedBeanDefinition)candidate);}// 检查给定的beanName ，确定相应的bean 定义是否需要注册或与现有bean定义兼容if (checkCandidate(beanName, candidate)) {BearpefinitionHolder definitionHolder = new BeanDefinitionHolder (candidate,beanName) ;// 根据proxyMode属性的值，判断是否需要创建scope代理，一般都是不需要的definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata,definitionHolder, this.registry);beanDefinitions.add(definitionHolder);registerBeanDefinition(definitionHolder, this.registry);return beanDefinitions;",
  "assets/net-img-1679239734021-714a9006-a539-4f79-a718-ca70e8d126f1-20230321111821-cclalzq.png": "1人34567加oo1011i1314protected Set\u003cBeanDefinitionHolder\u003e doScan(String... basePackages) {// BeanDefinitionHolder### BeanDefinition实例和名字以及别名Set\u003cBeanDefinitionHolder\u003e beanDefinitions = new LinkedHashSet\u003c\u003e();for (String basePackage : basePackages) {// 这里是具体的扫描过程，找出全部符合过滤器要求的BeanDefinition// 返回的BeanDefinition的实际类型为ScannedGenericBeanDefinitionSet\u003cBeanDefinition\u003e candidates = findCandidateComponents (basePackage) ;// 根据不同的bean类型做统一处理，如附默认值等// 因为有些数据我们并没有配置，需要这里做默认处理for (BeanDefinition candidate : candidates) {// 如果存在，则解析@scope注解，为候选bean设置代理的方式ScopedProxyMode，XML属性也能配置:scope-resolver、scoped-proxy，可以指定代理方式jdk或者cg1ibScopeMetadata scopeMetadata =this.scopeMetadataResolver. resol veScopeMetadata(candidate) ;candidate. setScope(scopeMetadata. getScopeName());",
  "assets/net-img-1679241255629-20403828-735b-42be-8913-2deb63482ef4-20230321111822-tmlswjs.png": "我们可以紧接着看看其中很重要的一个方法:1java1 public Set\u003cBeanDefinition\u003e findCcandidateComponents (String basePackage) {2 if (this.componentsIndex != null \u0026\u0026JindexSupportsIncludeFiltersQ) {3 // SpringS#4ett, HM \"META-INF/spring. components \"Aft RSl tH MeAaREH Mbean, Bl aw描，用于提升启动速度4 // Spring5升级的其中一个重点就提升了注解驱动的启动性能，\"META-INF/spring.components\"这个文件类似于一个\"组件素引\"文件，我们将需要加载的组件《beean定义) 预先的以键值对的样式配置到该文件中，当项目中存在\"META-INFVspring.components \"文件并且文件中配置了属性时，spring不会进行包扫描，而是直接读取\"META-INF/spring.components\"中组件的定义并直接加载，从而达到提升性能的目的。5 return addCandidateComponentsFromIndex(this.componentsIndex, basePackage) ;6 37 else {return scanCandidateComponents (basePackage) ;30 |}我们可以添加如下的依赖，自动生成部分索引:工2345\u003cdependency\u003e\u003cgroupId\u003eorg.springframework\u003c/groupId\u003e\u003cartifactId\u003espring-context-indexer\u003c/artifactId\u003e\u003cversion\u003e6.0.3\u003c/version\u003e\u003c/dependency\u003e",
  "assets/net-img-1679274597419-1f4cf6ed-a666-44c0-976f-7578fce50eed-20230321111822-5kodwxp.png": "上边的源码中我们看到读取类文件的真实的实例是simpleMetadataReader，spring选用了【read+visitor】的方式来读取字节码，read负责景露接口，visitor负责真正的读取工作:1 final class SimpleMetadataRedder implements MetadataReader 工23 SimpleMetadataReader (Resource resource, GNullable ClassLoader classLoader) throws IOException {4 SimpleAnnotationMetadataReadingVisitor visitor = newSimp] eAnnotationMetadataReadingVisitor(classLoader) ;// 这里是核心，一个reader需要结合一个vjsitorgetClassReader(resource) .accept(visitor，PARSING_O0PTIONS) ;this.resource = resource;8 // 元数据都是visitor的能力，典型的访问者设计模式9 this.annotationMetadata = visitor.getMetadata();10 }1112 // 通过资源获取一个ClassReader13 private static ClassReader getClassReader(Resource resource) throws IOException {14 try (InputStream is = resource.getInputStream()) {15 try {16 return new ClassReader (is);17 }18 }19 }",
  "assets/net-img-1679274657083-9cf14b40-ce68-46f2-aeab-27cac3af3ba5-20230321111822-wq98zac.png": "当然我们更加关注的是scanCandidateComponents方法:12)3456private Set\u003cBeanDefinition\u003e scanCandidateComponents (String basePackage) {进来Set\u003cBeanDefinition\u003e candidates = new LinkedHashSet\u003c\u003e();try {// 生成完整的资源解析路径// com.ydiclass -\u003e classpath*:com/yd1class/**/*.class// 关于资源解析的内容会在后边的课程单独讲String packageSearchPath = ResourcePatternReso1ver.CLASSPATH_ALL_URL_PREFIX +resolveBasePackage(basePackage) + '/' + this.resourcePattern;// MEARABET HAR, HISRAAE\"classpath*\", AMMA RMA jar AP ABST ARS RO// Spring会将每一个定义的字节码文件加载成为一个Resource资源〈包括内部类都是一个Resource资源)// 此处是以资源) 的方式加载〈普通文件》 ，而不是将一个类使用类加载器加载到jvm中。Resource[] resources = getResourcePatternResolver() .getResources (packageSearchPath) ;boolean traceEnabled = logger. isTraceEnabled();boolean debugEnabled = logger. isDebugEnabled();// 遍历所有的资源文件for (Resource resource : resources) {String filename = resource. getFilename();// 此处忽略CGLIB生成的代理类文件，这个应该不陌生if (filename != null \u0026\u0026 filename.contains(C1assUti1s.CGLIB_CLASS_SEPARATOR)) {continue;}if (traceEnabled) {logger. trace(\"Scanning \"+ resource);}try {// getMetadataReader方法会生成一个元数据读取器// 我们的例子中是Simp1eMetadataReaderMetadataReader metadataReader =getMetadataReaderFactory() . getMetadataReader (resource) ;",
  "assets/net-img-1679274818118-d3014a27-8e4f-409a-bbfa-a1c4bccefc16-20230321111822-da7at62.png": "// 检查读取到的类是否可以作为候选组件，即是否符合TypeFi1ter类型过滤器的要求// 使用IncludeFi1ter。就算目标类上没有GComponent注解，它也会被扫描成为一个Bean// 使用ExcludeFi1ter，就算目标类上面有GCComponent注解也不会成为Beanif CisCandidateComponent(metadataReader)) {// 构建一个ScannedGenericBeanDefinitionScannedGenericBeangefinition sbd = newScannedGenericBeanDefinition(metadataReader) ;sbd.setSource(resource) ;if CisCandidateComponent(sbd)) {if (debugEnabled) {logger .debug(\"Identified candidate component class: ”3candidates .add(sbd) ;+ resource);java",
  "assets/net-img-1679279718744-9c5628d3-0a78-4f8c-95b5-1c0c456dd96b-20230321111822-u20ioeb.png": "// 提供了通用能力Goverridepublic ClassMetadata getClassMetadata() {return this.annotationMetadata;3@overridepublic AnnotationMetadata getAnnotationMetadata() {return this. annotationMetadata;",
  "assets/net-img-1679279747577-8c2aeeee-a107-4a5f-9bd1-5dd229c58a07-20230321111822-iewoae0.png": "SimpleAnnotationMetadataReadingVisitor类使用了大量asm的内容，class文件的内容，而非加载后通过反射获取，我们列举其中的个别属性和方法，大致能宽探一二:25import org.import org.import org.import org.import org.springframework. asmspringframework. asmspringfrajework. asmspringframework. asmspringframework. asm.AnnotationVisitor;.ClassVisitor;.MethodVisitor;.Opcodes;.SpringAsmInfo;此可见spring在读取元数据的时候，是直接读取final class SimpleAnnotationMetadataReadingVisitor extends ClassVisitor {//.-//.-// 访问一个内部类的方法Goverridepublic void visitInnerClass(String name, @Nullable String outerName, String innerName, intaccess) {//..-省略// 访问注解的方法Goverride@Nullablepublic AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {-省略// 访问方法的方法Goverride@Nullablepublic MethodVisitor visitMethod(.省略",
  "assets/net-img-1679279842069-4447ef81-3b65-43cf-b8c0-5007dc717ebf-20230321111822-m0o4x1j.png": "java",
  "assets/net-img-1679279861265-1e82e9ef-fa02-471b-90ee-5b7be20f7225-20230321111823-q6a9tj2.png": "这其中还是用了一些类如下: Ea这些类都是对注解和类的元数据进行了封装，提供更简单的访问方式，很简单。我们写一个简单的小例子，来看看:1 @Test2 public void testAsm() throws IOException {3 Resource resource = new ClassPathResource(\"com/ydlclass/User.class\");4 ClassReader classReader = new ClassReader (resource. getInputStream());5 logger. info(classReader. getClassName());6 // 缺少visitor的reader能力优先，我们只做几个简单的实现7 // visitor实现相对复杂，我们没有必要去学习8 // classReader .acCept(xxxVijsitor) ;910 // 返回的对应的常量池的偏移量+111 // 0-3 cafebaba 4-7 主次版本号8-9 第一个是10+1",
  "assets/net-img-1679279876053-0decff12-4cd8-4a4d-b767-1666df23e7c7-20230321111823-a8xtgkz.png": "12 // 二进制可以使用bined插件查看13 logger.info(\"The first item is {}.\",classReader.getItem(1));14 logger.info(\"The first item is {}.\",classReader.getItem(2));15 // 00 3A 这是字节码文件看到的，16 // 常量池的计数是1-57 0表示不引用任何一个常量池项目17 logger.info(\"The first item is {}.\",classReader.getItemCount());1819 // 通过javap -v .NUser.class class文件访问标志20 // flags: (0x0021) ACC_PUBLIC，ACC_SUPER 十进制就是3321 // ACC_SUPER 0x00 20 是否允许使用invokespecial字节码指令的新语义.22 // ACC_PUBLIC 0x00 01 是否为Pub1ic类型23 1ogger.info(\"classReaderJgetAccess() is {}\",classReader.getAccess());2425 | }",
  "assets/net-img-1679279893172-349b8bc1-a1a5-428b-91f0-82d941ad1994-20230321111823-9oxltwa.png": "下同的扫描方式形成了不同的Definition子类如下:XmlBeanDefinitionReader读取BeanDefinitionRegistryxml中定义的bean \u003e GenericBeanDefinitionClassPathBeanDefinitionScanner\u003e ScannedGenericBeanDefinition@Compoment, @Service,@Respository等注解注释的类AnnotatedBeanDefinitionReader\u003e AnnotatedGenericBeanDefinitionConfigurationClassBeanSito =@Configuration相关的配置类ConfigurationClassBeanDefinitionReader",
  "assets/net-img-1679280152500-ce90e8ea-eeec-4c38-8df4-9deba26d8c96-20230321112825-v6szmjb.png": "第二章基础工具一、内省api1、什么是内省内省(IntroSpector)是java 语言针对Bean类属性、事件的一种缺省处理方法，spring的源码中也会经常出现相关的api，所以我们有必要了解一下。JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。事实上，内省机制也是通过反射来实现的。相对于内省，反射则更加强大，他能在运行状态把java类中的各种成分映射成相应的java类，可以动态的获取所有的属性以及动态调用任意一个方法，强调的是运行状态。内省和反射的常用api如下:内省使用, 反射(Beaninfo) (Class)| |t i 1 j i \"EEE ES Eee ES Ee ES@lavaNat, BANSAbHEHALNE",
  "assets/net-img-1679280352960-9c350d0f-a2fd-406b-a9b5-3198244acc69-20230321112826-in8o3ca.png": "和ava内省中，用到的基本上就是上述几个类。内省api的一般的做法是通过类Introspector 的getBeanlnfo方法来获取某个对象的Beanlnfo 信息，然后通过Beanlnfo 来获取属性的描述器(PropertyDescriptor)，通过这个属性描述器就可以获取某个属性对应的取信/赋值方法，然后我们就可[通过反射机制来调用这些方法，这就是内省机制。ii12 import java.beans.Beaninfo;3 import java.beans.Introspector;4 import java.beans.PropertyDescriptor;5 import java. lang.reflect.Method;67 @Test8 public void testIntrospect1() throws Exception {9 BeanInfo info = Introspector.getBeanInfo(User.class, Object.class);// 不自省从父类继承的属性10 PropertyDescriptor[] pds = info.getPropertyDescriptors();// 取得属性描述器11 for (PropertyDescriptor pd : pds) {12 logger. info(\"pd. getName()--\u003e{}\", pd. getName()) ;13 logger. info(\"pd. getReadMethod() --\u003e{}\" ,pd. getReadMethod());14 logger. info(\"pd. getwriteMethod()--\u003e{}\", pd. getWriteMethod());15 logger. info(\"pd. getPropertyType()--\u003e{}\" ,pd. getPropertyType());16 logger. info(\"pd. getShortDescription() --\u003e{}\",pd.getShortDescription());17 318 }",
  "assets/net-img-1679280370660-fef875e7-1db9-4699-ad7c-077c2e155551-20230321112826-2tsosoo.png": "23 User user = new User();24 PropertyDescriptor pd = new PropertyDescriptor(\"age\", User.class);25 // 得到属性的写方法，为属性赋值26 Method method = pd.getWriteMethod();27 method. invoke(user, 24);28 // 获取属性的值29 method = pd.getReadMethod() ;30 System. out.printIn(method. invoke(user, nul1));31] }AZ SN BeanUtils 5]. NSS HEA Fbean :1 @Test2 public void testBeanUtil() throws Exception {3 User user = new User();4 // 赋值5 BeanUtils.setProperty(user, name\" ，tom'\") ;6 BeanUti1ls.setProperty(Cuser，\"age\" ,10);a logger. info(\"user-\u003e{}\",user);8 // BRE9 logger. info(\"the user's name is -\u003e{}.\",BeanUtils.getProperty(user, \"name\"));",
  "assets/net-img-1679281537599-bdb2b66a-4754-4ab4-9fb8-fae76d8ffb70-20230321112826-a8d56xw.png": "二、更强的反射工具在spring中，我们除了能看到内省相关的api，看到的更多的可能是反射pi了，当然针对原生api的复杂性，spring同样进行了封装，让其使用起来更简单。spri ngieSO ERT SBARISCRY TR BeanW ea pper，下边的例子展示了该类如何配合BeanDefinition对其进行了实例化:1、bean的创建1 @Test2 public void testCreate() throws ClassNotFoundException, NoSuchMethodException,InvocationTargetException, InstantiationException, IllegalAccessException {3 // 1、通过任意形式捕获beanDefinition4 GenericBeanDefinition beanDefinition = new GenericBeanDefinition();5 beanDefinition.setBeanClassName(\"com.ydiclass.User\");6 MutablePropertyValues propertyValues = new MutablePropertyValues();7 propertyValues.addPropertyValue(\"name\",\"lily\");8 propertyValues .addPropertyValue(\"age\",12);9 beanDefinition.setPropertyValues (propertyValues) ;1011 // 2、通过权限定名称获得Class12 Class\u003c?\u003e aClass = Class. forName(beanDefinition. getBeanC lassName());1314 // 3、使用Beanwrapper包于实例，使其更方便使用反射方法15 BeanWrapper beanwrapper = new BeanWrapperImp](aClass);16 beanwWrapper.setPropertyValues (beanDefinition. getPropertyValues());17 Object bean = beanwrapper.getwrappediInstance();18 logger.info(\"The bean is [{}]\",bean);19 }我们可以看到BeanWrapperlmpl仅仅需要一个Class就能十分友好的结合beanDefinition进行构建和赋值，而不需要通过复杂的反射获取构造器进行实例化，获取字段对象进行赋值，当然这仅仅是api寺装的功劳，原理还是那些东西。",
  "assets/net-img-1679282342230-4b8a5441-3bd2-4d5c-9b0e-9070dfda9ea9-20230321112826-ak57nsk.png": "2. ihetais我们可以使用如下的方法进行批量构造1 @Test2 pliblic void testBatchCreate() throws ClassNotFoundException, NoSuchMethodexception,InvocationTargetException, InstantiationException, I]llegalAccessException {3 // 1、通过任意形式捕获beanDefinition4 BeanDefinitionRegistry registry = new SimpleBeanDefinitionRegistryQ;5 Xm1BeanDefinitionReader xmlReader = new XmlBeanDefinitionReader(registry) ;6 xmlReader. loadBeanDefinitions(\"classpath: spring. xml\");89 // 2、通过反射实例化10 String[] definitionNames = registry.getBeanDefinitionNames();11 for (String definitionName : definitionNames) {12 BeanDefinition beanDefinition = registry. getBeanDefinition(definitionName) ;3 String beanClassName = beanDefinition.getBeanClassName() ;14 Class\u003c?\u003e aClass = Class. forName(beanClassName) ;15 Constructor\u003c?\u003e constructor = aClass.getConstructor();16 Object bean = constructor.newInstance();1718 // 3、使用BeanwWrapper包裹实例，使其更方便使用反射方法19 Beanwrapper beanWrapper = new BeanWrapperImp] (bean);20 beanwrapper .setPropertyValues (beanDefinition.getPropertyValues());21 bean = beanwrapper.getWrappediInstance();22 System. out.printIn(bean) ;23 }",
  "assets/net-img-1679282504446-c0eef76f-4917-42c5-ad2a-314e5e42ae8f-20230321112826-161zl1p.png": "貌似事与愿违，此时抛出一个异常，是说无法将一个TypedStringValue类型的数据转化为一个Integer，没有合适的转化器:1 org.springframework.beans.TypeMismatchException: Failed to convert property value of type‘org.springframework. beans. factory. config. TypedStringValue’ to required type ‘java.lang.Integer' forproperty ‘age’;这个问题，我们先按下不表，后边再解释，接着我们看几个常用的类:3, ResolvableType !该类可以封狗ava类型，提供对超类类型、接口和泛型参数的访问，以及最终解析为类的能力，这是非常常见的一个类，他能及其方便的简化对反射api的调用，该类在spring中的使用率非常高。ResolvableType可以从字段、方法参数、方法返回类型或类中获得。这个类上的大多数方法本身都会返|以便于链式调用。官方的案例如下:回一个ResolvableType，1 private HashMap\u003cInteger, List\u003cString\u003e\u003e myMap;2 public void exampleQ {3 ResolvableType t = ResolvableType. forField(getClass().getDeclaredField(\"myMap\"));4 t.getSuperType(); // AbstractMap\u003cInteger, List\u003cString\u003e\u003e5 t.asMap(); // Map\u003cInteger, List\u003cString\u003e\u003e6 t.getGeneric(0).resolveQ); // Integer // 获取泛型7 t.getGeneric(1).resolveQ); // List8 t.getGeneric(1); // List\u003cString\u003e9 //第二个泛型,里面的泛型,即List\u003cSstring\u003e里面的String10 t.resolveGeneric(1, 0); // String11|}我们也可以写测试用例测试一下，光看不练是记不牢的:1 @Test2 public void testTypeResolvableType() throws NoSuchFieldException {3 ResolvableType type =ResolvableType. forField(DefaultSingletonBeanRegistry.class.getDeclaredField(\"singletonObjects\"));4 // 获取类型5 logger. info(type. getTypeQ . getTypeName());6 // BRAD",
  "assets/net-img-1679282530679-c21ef624-2495-4c42-9aa6-637a7166b645-20230321112826-xn47jez.png": "logger. info(Arrays.toString(type. getGenerics()));8 logger. info(Arrays . toString(type. getInterfaces()));9 logger. info(Arrays. toString(type. resolveGenerics()));10 // 获取来源11 Class\u003c?\u003e resolve = type.resolve();12 logger. info(type. getRawClass().getName());13/}Resolvable: 可解析的，可分解的。spring中经常出现这个单词。如ResolvableAttribute，ResolvableType，registerResolvableDependency，后期遇到戌们再学习。",
  "assets/net-img-1679282911645-fd68e2db-14b8-4d95-aa7e-e328c6ff7a67-20230321112826-a6fobqa.png": "二、类型转化我们从xml里搜集到的所有数据者是【字符串】，但是实际的类中的成员变量可能是数字，数组，集合，或者是复杂的引用郑型，所以spring给我们提供了强大的转换服务(conversionService接口) 。1、转换服务ConversionService接口很简单，可以根据源类型和目标类型进行判断是否可以转换，并执行转换:1 public interface ConversionService {23 boolean canConvert(@Nullable Class\u003c?\u003e sourceType, Class\u003c?\u003e targetType);45 boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType);67 @Nul lable8 \u003cT\u003e T convert(@Nullable Object source, Class\u003cT\u003e targetType);910 // 将给定的{ecode source} MABE MH {@code targetType}-11 Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptortargetType);1213 }我们不妨看看DefaultConversionService的源码，更多核心的功能是在器父类中实现的，在构造实例时，他会默认传入大量可化器:public class DefaultConversionService extends GenericConversionService {123 @Nullable4 private static volatile DefaultConversionService sharedInstance;56",
  "assets/net-img-1679283265594-ad22223f-3705-441c-a9fb-6d5c6f3bdd80-20230321112827-7ozxn19.png": "public DefaultConversionService() {// 添加大量的默认的转换器addDefau1tConverters (this);了// 类似单例的获取方式public static ConversionService getSharedInstance() {DefaultConversionService cs = sharedInstance;if (cs == null) {synchronized (DefaultConversionService.class) {cs = sharedInstance;if (cs == null) {cs = new DefaultConversionService();sharedInstance = cs;}return cs;",
  "assets/net-img-1679283451195-6de4d509-6bcd-499f-a325-e7d53214fb94-20230321112827-2yyv46r.png": "// 添加适合大多数环境的转换器public static void addDefau1tConverters (ConverterRegistry converterRegistry) {addscalarConverters (converterRegistry) ;addCollectionConverters (converterRegistry) ;converterRegistry.addCconverter(new ByteBufferConverter ((ConversionService)converterRegistry));converterRegistry.addConverter(new StringToTimeZoneConverter ());converterRegistry.addConverter (new ZoneIdToTimeZoneConverter ());converterRegistry.addConverter(new ZonedDateTimeToCalendarConverter ());//.. BAYS",
  "assets/net-img-1679284447748-8b792843-7880-418e-bc73-ac3dea3059c0-20230321112827-p956m88.png": "// 增加通用的转换器，例如集合、数组TRSpublic static void addCollectionConverters(ConverterRegistry converterRegistry) {ConversionService conversionService = (ConversionService) converterRegistry;converterRegistry.converterRegistry.converterRegistry.converterRegistry.converterRegistry.//.. BARSaddConverter (newaddConverter (newaddConverter (newaddConverter (newaddConverter (newArrayToCol lectionConverter (conversionService));CollectionToArrayConverter(conversionService));StringToCol lectionConverter (conversionService));CollectionToObjectConverter (conversionService));ObjectToCol lectionConverter (conversionService));",
  "assets/net-img-1679284457392-d6afcd22-07c5-4aab-8c9f-29b8fd1990f4-20230321112827-gozgk71.png": "5455// 新增标量的转化器，主要是字符串数字类型private static void addScalarConverters(ConverterRegistry converterRegistry) {converterRegistry.converterRegistry.converterRegistry.converterRegistry.converterRegistry.converterRegistry.//.. BAYSaddConverterFactory(new NumberToNumberConverterFactory());addConverterFactory(new StringToNumberConverterFactory());addConverter(Number.class, String.class, new ObjectToStringConverter());addConverter(new StringToPropertiesConverter());addConverter (new PropertiesToStringConverter());addConverter (new StringToUUIDConverter());",
  "assets/net-img-1679284469498-c48cc52e-a928-4767-95d3-b796b48947d9-20230321112827-d1v4bqn.png": "我们可以编写如下的测试用例，可以将字符吕转换为数字和列表:1 @Test2 public void testConvertinteger(){3 String source = \"100\";4 ConversionService conversionService = new DefaultConversionService();5 if (conversionService. canConvert (String. class ,Integer.class)){6 Integer target. = conversionService.convert(source, Integer.class);7 logger. info(\"The number is {}.\", target);8 }9|}1011 @Test12 public void testConvertListQ){13 String source = \"100,12,23,54,56\";14 ConversionService conversionService = new DefaultConversionService();15 if (conversionService.canConvert(String.class, List.class)){16 List target = conversionService.convert(source, List.class);17 logger. info(\"The number is {}.\", target);18 }19 | }这种类型转换的能力非常有用，我们从【xml到java对象】，从【前端参数到java对象】，都需要这样的强大能力。",
  "assets/net-img-1679284556197-6aae48a5-5ca8-44cc-af2b-c5e7db53f465-20230321112827-ekqvl2n.png": "2、独立编写转化器我们也可以实现自己的转化器，我们不妨写一个【从字符串到User类】的转化器，我们的转换器需要实现GenericConverter接，这个可以仿照其他的转换器写:我们可以先看看GenericConverter接|public interface GenericConverter {123 // 返回目标类型和源类型的一个set4 Set\u003cConvertib1 epPaiT\u003e getConvertibleTypes ();5 // 新的方法6 Object convert(G@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType);89 // 定义了一个source-to-target class pair.10 final class ConvertiblePair {il12 private final Class\u003c?\u003e sourceType;13 private final Class\u003c?\u003e targetType;1415 ... 其他内容省略16 }718 |}我们需要实现GenericConverter的两个方法:",
  "assets/net-img-1679284568418-de4ae212-f47d-4bc3-8ec7-e7e961ccef3c-20230321112827-nuwkgx0.png": "1 public class UserConvert implements GenericConverter {23 Q@override4 public Set\u003cConvertiblePair\u003e getConvertibleTypes() {5 // 返回一个Set集合，其中的元素为一个只包含object(obj) 的不可变集合6 return Collections.singleton(new GenericConverter.ConvertiblePair(String.class,User.class));7 了89 Q@override10 public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {11 // 我们假设字符串的类型如下: nme | age12 assert source != null;13 String[] nameAndAge = source.toString().split(\"\\\\|\");14 if (nameAnddge. length == 2){15 return new User(nameAndAge[0].trimQ , Integer. valueOf (nameAndAge[1].trim()));16 } else {17 throw new RuntimeException(\"转化出现异常.\");18 }19 }20 }java在当前的测试用例中，我们将我们的convert添加到conversionService中:",
  "assets/net-img-1679284631675-5408eb94-cdcc-45b5-ba44-82aa308493c1-20230321112827-5ai5lac.png": "1 @Test2 public void testConvertuUser(){3 String source = \"Tom | 23\";4 // 这里必须使用子类的类型，接口并不提供addConverter方法5 DefaultConversionService conversionService = new DefaultConversionService();6 conversionService.addConverter (new UserConvert());7 if (conversionService. canConvert(String.class, User.class)){User target = conversionService.convert(source, User.class);9 logger. info(\"The user is {}.\", target);10 3111/}12 // 结果13 19:51:03.210 [main] INFO com.ydlclass.ToolsTest - The user is User{name='Tom', age=23}.事实上这个转化器确实生效了。",
  "assets/net-img-1679284676231-384f2e0e-9956-41ff-8e58-a867a6141c44-20230321112827-cazaky3.png": "3、更简单的实现我们发现DefaultConversionService有很多重载的addConverter方法，我们甚至可以传入一个实现了Converter\u003c?, ?\u003e接口的实fil, MF:1 @Override2 public void addConverter(Converter\u003c?, ?\u003e converter) {3 // 这个方法可以获得实现类的泛型4 ResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter.class);5 if (typeInfo == null \u0026\u0026 converter instanceof DecoratingProxy decoratingProxy) {6 typeInfo = getRequiredTypeInfo(decoratingProxy.getDecoratedClass(), Converter.class);7 }8 if (typeInfo == null) {9 throw new I1legalArgumentException(\"Unable to determine source type \u003cS\u003e and target type \u003cT\u003efor your \"+10 \"Converter [\" + converter.getClass().getName() + \"];does the class parameterize those types?\");11 }12 // Converter\u003c?, ，?\u003e和GenericConkerter做了适配13 addCconverter (new ConverterAdapter(converter, typeInfo[0], typeInfo[1]));14|}按照这个方法的定义，我们重新编写我们的UserConverter2，他需要实现Converter接口, 如下:1 public class UserConverter2 implements Converter\u003cString,User\u003e {23} @override4 public User convert(String source) {5 String[] nameAndAge = source.split(\"\\\\|\");6 if(nameAnddge. length == 2){7 return new User(nameAndAge[0].trimQ , Integer. valueOf (nameAndAge[1].trim(Q)));8 } else {9 throw new RuntimeException(\"转化出现异常.\");这个结和更加的简单优雅，他是一个函数式接口，所以可以用lamdba去达式编写:",
  "assets/net-img-1679284686448-c630588f-97b9-4dbf-94ad-4791eccac7d4-20230321112828-ccln0pn.png": "@FunctionalInterface Ipublic interface Converter\u003cS, T\u003e {@NullableT convert(S source);//构造一个复合转换器，首先将该转换器应用于其输入，然后将后一个转换器应用于结果。default \u003cU\u003e Converter\u003cS, U\u003e andThen(Converter\u003c? super T，? extends U\u003e after) {Assert.notNull(after, “'after' Converter must not be null\");return (Ss) -\u003e {T initialResult = convert(s);return (initialResult != null ? after.convert(initialResult) : null);a",
  "assets/net-img-1679284704728-8eff530e-2905-414a-b634-bd50de206998-20230321112828-tcyfctc.png": "他的实现逻辑是，运行时获取泛型的类型，并且与GenericConverter做适配。我们可以使用以下的测试用例获得泛型的类型:1 public void testGenericQ{2 ParameterizedType genericInterfaces = (ParameterizedType)(UserConverter2.class.getGenericInterfaces () [0]);34\\}5| 结果:6[class java.lang.String, class com.yd]class.User]如果我们还记得之前学习的工具类更简单了:@Testpublic void testGenericQ{logger. info(Arrays. toString(genericinterfaces. getActualTypeArguments()));ResolvableType[] generics = c.getInterfaces()[0].getGenerics();logger. info(Arrays. toString(generics));6\\}123 ResolvableType c = ResolvableType. forClass (UserConverter2.class);45有细心的朋友可能会发现，java中不是有泛型掠除的机制吗》为什么这里还可以获取呢?回其实泛型的擦除指的是编译后方法体和类结构还是可以获取的。不在使用泛型，退至原始类型，但是在字节码中还是会有记录，强大的反射机制",
  "assets/net-img-1679284720010-039f3f2e-5ec8-47dc-a306-e9e5318299b1-20230321112828-rixvhqw.png": "遗留问题:在上一个例子中，我们的异常说是TypedStringValue到integer无法转化，TypedStringValue是spring对String的一个包装，具体的值是存在TypedStringValue中的，我们的DefaultConversionService没有默认的转换器，当然实际spring在转换的时候会做出处理，我们目前先不考虑，我们倒是可以写一个简单的转换器如下;1 @Test2 public void testBatchCreate() throws ClassNotFoundException, NoSuchMethodException,InvocationTargetException, InstantiationException, I]llegalAccessException {3 // 1、通过任意形式捕获beanDefinition4 SimpleBeanDefinitionRegistry registry = new SimpleBeanDefinitionRegistry();5 Xm1BeanDefinitionReader xmlReader = new Xml1BeanDefinitionReader(Cregistry);6 xm]Reader. loadBeanDefinitions(\"classpath: spring. xml\");8 // 2、通过反射实例化I9 String[] definitionNames = registry. getBeanDefinitionNames();10 for (String definitionName : definitionNames) {11 BeanDefinition beanDefinition = registry. getBeanDefinition(definitionName) ;12 String beanClassName = beanDefinition. getBeanClassName() ;13 Class\u003c?\u003e aClass = Class. forName(beanClassName) ;1415 // 3、使用geanwrapper包砷实例，使其更方便使用反射方法16 BeanWrapperImp] beanWrapper = new BeanWrapperiImp](aClass);1718 DefaultConversionService conversionService = new DefaultConversionService();19 // BRBEKREW: 使用lamdba表达式写一个转换器20 conversionService. addConverter ((Converter\u003cTypedStringValue, Integer\u003e) source -\u003eInteger. valueOf (Objects. requireNonNull (source. getValue())));21 beanWrapper.setConversionService(conversionService) ;2223 beanWrapper.setPropertyValues (beanDef inition. getPropertyValues());24 Object bean = beanWrapper.getwrappediInstance();25 System. out.printIn(bean) ;26 }27) }",
  "assets/net-img-1679284738904-bb4c183e-9cf4-4056-964d-d3b175c27938-20230321112828-46c9nry.png": "注意啦!最后有心的朋友会发现中还有如下的接口，留给我们自己探索，非常简单;1 void addconverterFactory(ConverterFactory\u003c?, ?\u003e factory);我们发现能过启动装换的转化器有三种，分别是Converter、ConverterFactory、GenericConverter，为了方便统一管理，他们在添加到Converters之前都统一被适配为了GenericConverter。",
  "assets/net-img-1679284767150-6b807757-df15-4e45-8e9f-0febf85c9da2-20230321112828-8khx76e.png": "3、转化器源码所有注册的convertor都会存储在Converters中，该类结构相对比较复杂:private static class Converters {123 // 存取通用的转换器，并不限定转换类型，一般用于和哲底4 private final Set\u003cGenericConverter\u003e globalConverters = new CopyOnwriteArraySet\u003c\u003e();5 // 指定了类型对，对应的转换器们的映射关系。6 // ConvertiblePair: 表示一对，包含sourceType和targetType7 // ConvertersForPair: 这一对对应的转换器们《〈 因为能处理一对类型转换可能存在多个转换器) ，内部使用一个双端队列peque来存储，保证顺序8 private final Map\u003cConvertiblePair, ConvertersForPair\u003e converters = new ConcurrentHashMap\u003c\u003e(256); I910 public void add(GenericConverter converter) {11 // 获得他的类型对儿12 Set\u003cConvertiblePair\u003e convertibleTypes = converter.getConvertibleTypesO;13 if (convertibleTypes == null) {14 // 如果没有限定转换类型，添加到gl1oba1Converters15 this.globalConverters.add(converter) ;16 }17 else {18 // 如果已经存在转换类型，我们写的都在这里19 for (ConvertiblePair convertiblePair : convertibleTypes) {20 // 找到与之匹配的加进去，这里是个链表21 getMatchableConverters (convertiblePair) .add(converter) ;22 }23 }24 }",
  "assets/net-img-1679284782651-340104a9-9cc2-416d-9e64-fd45bf59d3a9-20230321112828-qkuuq8c.png": "27@Nullablepublic GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType) {// 搜索完整的类型层次结构，父类---\u003e// 比如想要搜索【虎猜-\u003e 老虎】，但如过虎猫有父类《〈猫)// 我们还需检索【猫-\u003e 老虎了List\u003cClass\u003c?\u003e\u003e sourceCandidates = getClassHierarchy(sourceType. getType());List\u003cClass\u003c?\u003e\u003e targetCandidates = getClassHierarchy(targetType. getType());for (Class\u003c?\u003e sourceCandidate : sourceCandidates) {for (Class\u003c?\u003e targetCandidate : targetCandidates) {// 所有的类型都要匹配ConvertiblePair convertiblePair = new ConvertiblePair(sourceCandidate,targetCandidate);// 找到一个就返回GenericConverter converter = getRegisteredConverter(sourceType，targetType，convertiblePair);if (converter != null) {return converter;}}了return null;3@Nullableprivate GenericConverter getRegisteredConverter(TypeDescriptor sourceType,TypeDescriptor targetType, ConvertiblePair convertiblePair) {// 根据convertib1ePair获取ConvertersForPairConvertersForPair convertersForPair = this.converters.get(convertiblePair);if (convertersForPair != null) {GenericConverter converter = convertersForPair.getConverter(sourceType, targetType);if (converter != null) {return converter;",
  "assets/net-img-1679284800562-2e935104-55c6-407d-b939-faaeb666f24d-20230321112828-us29bzu.png": "59 // 检查是否能匹配哲底的全局转换器60 for (GenericConverter globalConverter : this.globalConverters) {61 if (((Conditionalconverter) globalConverter).matches(sourceType, targetType)) {62 return globalConverter;64 }65 return null;68 了ConvertiblePair: #7a—%J, M@SsourceType*targetType",
  "assets/net-img-1679285523000-920cc1b9-4a02-4c0e-9f1b-ffaf2f425556-20230321112828-7fj0919.png": "1 final class ConvertiblePair {2 private final Class\u003c?\u003e sourceType;3} private final Class\u003c?\u003e targetType;4\\}ConvertersForPair: 这一对对应的转换器们(因为能处理一对类型转换可能存在多个转换器) ，内部使用一个双端队列Deque来存储，保证顺序。他的结构如下:1 Map\u003cCconvertiblePairConvertersForPair\u003econverters的结构1L 1ConvertiblePair存储了源类型和目标类型ConvertersForPair内部维护了一个双向队列Ar。sig encom 3",
  "assets/net-img-1679285821393-8968847e-90da-4775-a3d7-d5530404c95e-20230321112829-t3m6e33.png": "LAuUPRWN HEooprivate static class ConvertersForPair {// 内部维护的队列Iprivate final Deque\u003cGenericConverter\u003e converters = new ConcurrentLinkedDeque\u003c\u003e();public void add(GenericConverter converter) {this.converters.addFirst (converter);@Nullablepublic GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {for (GenericConverter converter : this.converters) {// 此处表明，如果我们有特殊的需求，还可以实现ConditionalGenericConverter，实现特殊的匹配规则，连边中的converter可以有不同的匹配规则，// 当然通常情况下会返回第一个if (!(converter instanceof ConditionalGenericConverter genericConverter) ||genericConverter.matches(sourceType, targetType)) {return converter;}return null;",
  "assets/net-img-1679286183647-2102d1fe-4d52-42bf-91e5-a5f502b22f16-20230321112829-2g891km.png": "三、资源获取Spring的【Resource]】接|位于【org.springframework.core.io】包，他抽象了对资源的访问的能力。 下面提供了[Resource] 接口的概述， Spring本身广泛地使用了Resource接口，这个我们之前就接触过了。public interface Resource extends InputStreamSource {boolean exists();boolean isReadable();boolean isFileQ;URL getURL() throws IOException;1234 boolean isOpen();56URI getURI() throws IOException;8 File getFileQ throws IOException;9 ReadableByteChannel readableChannel() throws IOException;10 long contentLength() throws IOException;11 long lastModified() throws IOException;12 Resource createRelative(String relativePath) throws IOException;13 String getFilename();14 String getDescription();54H1、内置的Resource的实现Spring包含了几个内置的Resource 实现，如下所示:UrlResource: UrlResource包装了java.net.URL，可以用来访问任何需要通过URL访问的对象，例如文件、HTTPS目标、FTP目标等。 所有URL都用一个标半化的字符昌表示，这样就可以使用适当的标侍化前组来表示不同类型的URL。 这包括文件系统路径的' file: ',ClassPathResource: 该类表示应该从【类路径】中获取的资源。入资源。通过https协议访问资源的' https: ', 通过ftp访问资源的' fp: 等。FileSystemResource: 这是面向java.io的Resource实现，可以简单的实现对系统文件的操作。InputStreamResource: 给定的InputStream的Resource实现。 只有当没有特定的资源实现适用时，才应该使用它。ByteArrayResource: 这是一个给定字节数组的资源实现。于访问它使用线程上下文类装入器、给定的类装入器或给定的类装",
  "assets/net-img-1679286245452-d78bb9e2-2ce4-4141-ba50-708b738d4fa3-20230321112829-p0crqeq.png": "我们编写以下三个测试有用例来简单学习感知一下:1 @Test2 public void testUr1() throws IOException {3 Resource resource = newUrlResource(“https://d1dir1. qq. com/qqfile/qq/PCQQ9.7.0/QQ9.7.0.28921. exe\");FileOutputStream fos = new FileOutputStream(\"D://\"+resource.getFilename());// 该工具包需要引入commons-ioIoutils.copy(resource.getInputStream() , fos);NOW",
  "assets/net-img-1679286262121-39c02152-dac9-4f15-a9fc-1f9e11aa141a-20230321112829-bt282by.png": "@Testpublic void testFileSystem() throws IOException {Resource resource = new FileSystemResource(\"D:/spring/spring.xm1\");byte[] buffer = new byte[1024*100];int offset = I0Utils.read(resource.getInputStream(), buffer);logger. info(new String(buffer ,0,offset));@Testpublic void testClassPath() throws IOException {Resource resource = new ClassPathResource(\"spring. xml\");byte[] buffer = new byte[1024*100];int offset = I0Utils.read(resource.getInputStream(), buffer);logger. info(new String(buffer ,0,offset));",
  "assets/net-img-1679286275965-406070ad-e51b-4e9d-99c7-79ee5b3a7c2b-20230321112829-xculo5y.png": "2、xml解析这里我们接着之前的源码继续深入，回顾我们之前的加载beanDefinition的过程:1、加载.class文件资源，这里和类加载不是一个概念。2、加载xm文件首先我们看一个小知识点:。 Big8[classpath:*] : 只会到你的target下面的class路径中查找找文件，通常匹配一个资源。前经|。 Bi4%[classpath*:] : 不仅包含target下面的class路径，还包括jar文件中(target下面的class路径)进行查找，可以匹配多个资源，这种场景非常多，比如在实现了springboot自动装配相关的jar包中绝大多数都会有spring.factories文件。Maven: org.springframework.b« ring-boot-\u003cspring-boot-autoconfigur 1 jarMETA-INFspringorg.springframework.context.Appspring给我们提供了springPathMatchingResourcePatternResolver类，该工具可以很灵活的帮助我们获取对应的Resource实例，他提供了getResource和getResources方法为我们使用:",
  "assets/net-img-1679286393116-32d93cb7-be25-438b-8cee-6cd6991ed88a-20230321112829-3xlog4g.png": "public Resource getResource(String location) {Assert.notNul]l(location, “Location must not be null\");// 留给我们的扩展的协议解析器，如自定义for (ProtocolResolver protocolResolver : getProtocolResolvers()) {Resource resource = protocolResolver.resolve(location, this);if (resource != null) {return resource;if Clocation.startswith(\"/\")) {return getResourceByPath(location);3// Classpath:else if Clocation.startswith(CLASSPATH_URL_PREFIX)) {return new ClassPathResource(location. substring (CLASSPATH_URL_PREFIX. length()),getClassLoader());} else {try {// 尝试将位置解析为URL-URL url = ResourceUtils.toURL(Ipcation) ;// ®MBAEFile: vfsfile:iTAHreturn (ResourceUtils.isFileURL(url) ? new FileUriResource(url) : newUr1Resource(url));}",
  "assets/net-img-1679286418673-0c6b32db-6fb6-4c49-be7c-d14349e527f9-20230321112829-hnvrb4g.png": "我们写一个测试用例如下:1 @Test I2 public void testPathMatch() throws IOException {3 PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();4 logger. info(\"Then resource is {}.\", resolver.getResource(\"classpath:yd1.xm1\").getClass());5 logger. info(\"Then resource is {}.\", resolver.getResource(\"https://yd1.xm1\").getClass());6 logger.info(\"Then resource is {}.\", resolver.getResource(\"ftp: //ydl.xm1\").getClass());7 logger.info(\"Then resource is {}.\", resolver.getResource(\"file://yd1.xm1\").getClassQ);8 }当然我们也可以调用getResources方法获取类路径下的所有的同名文件:我们可以写如下的测试用例:1 public void testMoreFile() throws IOException {2 PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();3 Resource[] resources = resolver.getResources(\"“classpath*: /META-INF/spring. factories\");4 for (Resource resource : resources) {5 System. out.printIn(resource. getURI());6 }}结果如下:java",
  "assets/net-img-1679286442063-0a92fa01-bfda-4a59-a727-b20d1631fb34-20230321112829-hksbbx8.png": "pring-boot/3.0.1/spring-boot-3.0.1.jar! /META-INF/spring. factoriespring-boot-autoconfigure/3.0.1/spring-boot-autoconfigure-3.0.1.jar! /META-INF/spring.factor-aop/6.0.3/spring-aop-6.0.3. jar! /META-INF/spring.factoriespring-boot-test/3.0.1/spring-boot-test-3.0.1.jar!/META-INF/spring. factoriespring-boot-test-autoconfigure/3.0.1/spring-boot-test-autoconfigure-3.0.1.jar!/META-INF/spr-test/6.0.3/spring-test-6.0.3.jar! /META-INF/spring. factories",
  "assets/net-img-1679287736882-08072c4e-bb76-43e0-99c2-5d6933f5c307-20230321112829-ncwlqe4.png": "四、环境抽象Ispring提供了Environment接口，是一个对环境的抽象，集成在容器中，它模拟了应用程序环境的两个关键方面，分别是profiles和properties。。 一个profile是一个给定名字的，在【逻辑上分了组】的beanDifination配置，只有在给定的profile是激活的情况下才向容器注册。。 properties 在几乎所有的应Se Pa REESE. 他就是一大堆的key-value的集合， 和— 属性件、JVM系统属性、系统环境变量、JNDI、servlet上下文参数、特定的【Properties】对象、“Map\"对象等等。 与属性相关的Environment对象的作用是为提供一个方便的服务接口，用于配置属性源并从那里解析属性。1、porpertiesSpring中的环境对象提供了对【属性】的搜索操作，我们看下下边的例了1 @Testpublic void testMoreEnvProperties() throws IOException {ApplicationContext ctx = new GenericApplicationContext();4 Environment env = ctx.getEnvironment();boolean containsMyProperty = env.containsProperty(” 了;1ogger.info(\"Does my environment contain the ‘JAVA property? {}\", containsMyProperty) ;Fae了当然我们也可以debug，观察其中的env变量:Environment() ;iables ConsoleRUNNINGStandardE e epro 0 defaultProfiles=[dToolsTest (comyalclass)emProperties|",
  "assets/net-img-1679288240785-2b721031-f1cf-40d8-9ed7-d3ca1bad7b3d-20230321112830-7uhljlt.png": "在前面的代码片段中，我们看到了查询在spring的env中是否存在【JAVA_HOME】属性。 为了回答这个问题，Environment对象对propertySources中的【PropertySource】执行搜索。这里边又出现了PropertySource的概念，他是对任何【键值对源】的一个简单抽象， spring的StandardEnvironment配置了两个基础PropertySource对象:(1) 一个代表|VM系统属性的集合“System.getProperties()1 @Test2 public void testSystemProperties() {3 Properties properties = System.getProperties();4 Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entries = properties.entrySet();5 for (Map.Entry\u003cObject,Object\u003e entry:entries){6 System. out.printIn(entry);7 3oocm",
  "assets/net-img-1679288307046-47a0a863-256f-4dea-bc7e-7c6c848ba078-20230321112830-cpbdb7p.png": "java.file.java.-vendor.url.bug=https://bugreport. java.com/bugreport/javajava.java.user.puntime.name=Java(TM) SE Runtime Environmentencoding=UTF-8vm.name=Java HotSpot(TM) 64-Bit Server VMio.tmpdir=C:\\Users\\itnanls\\AppData\\Local\\Temp\\version=17.0.5|dir=E:\\project\\spring-source-studyos.arch=amd64java.vm.specification.name=Java Virtual Machine Specification",
  "assets/net-img-1679288336956-757bd098-628f-4d16-8b29-2d087178061b-20230321112830-204ondk.png": "(2) 一个代表系统环境变量的设置(System.getenv()”)GTest2 public voidMap\u003cString, String\u003e env = System.getenvQ);4 Set\u003cMap.Entry\u003cString, String\u003e\u003e entries = env.entrySet();for (Map.Entry\u003cString,String\u003e entry:entries){System. out.printIn(entry);weweHHRR, Sem:0S=Windows_NTOneDriveConsumer=C: \\Users\\itnanls\\OneDriveCOMPUTERNAME=DESKTOP-D3LI9B9PROCESSOR_REVISION=a701CommonProgramW643 \\Program Files\\Common FilesComSpec=C: \\WINDOWS\\system32\\cmd.exeProgramData=C: \\ProgramDataProgramW6432=C:\\Program FilesHOMEPATH=\\Users\\itnanlsSystemRoot=C: \\WINDOWSStandardEnvironment的源码如下，默认情况便确实会将这两个propertySource加入env:",
  "assets/net-img-1679288348929-108ab177-ebee-49ec-9384-0b84f868b21e-20230321112830-3znvu1g.png": "1 public class StandardEnvironment extends AbstractEnvironment {23 /** System environment property source name: {@value}. */4 public static final String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = “systemEnvironment\";56 /** JVM system properties property source name: {@value}. */A public static final String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = “systemProperties\";89 @Override10 protected void customizePropertySources (MutablePropertySources propertySources) {11 propertySources.addLast(12 new PropertiesPropertySource (SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME ,getSystemProperties()));13 propertySources.addLast(14 new SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME ,getSystemEnvironment()));15 }",
  "assets/net-img-1679288368991-44c1307a-7a7e-4fb1-9ab8-6e9dd0d9dbd2-20230321112830-qmu2brm.png": "当然，人整个机制都是可配置的。 我们可以将自定义的属性源集成到此搜索中。 为此，我们可以实例化【PropertySource】，并将它添加到当前' Environment 的' propertyssources '集合中，如下:1 public class MyPropertySource extends PropertySource\u003cString\u003e {2 public MyPropertySourcelString name) {3 super (name);4 }56 @Override7 public String getProperty(String name) {8 // 这里可以是源自任何罗辑的键值对来源，9 // 可以从properties文件中检索，也可以是数据库检索，等等10 return “hello\";abl }12 11测试用例如下:1 @Test2 public void testStandardEnvironment() {3 StandardEnvironment env = new StandardEnvironment();4 MutablePropertySources sources = env.getPropertySources();5 sources.addFirst(new MyPropertySource(\"my-source\"));6 }己的",
  "assets/net-img-1679288433254-60adcd8d-60c2-4483-b74a-8851646086f1-20230321112830-9fx8qpx.png": "【@propertySource 】注解提供了一种方便的声明性机制，用于向Spring的【Environment】中添加【 PropertySource] 。给定一个名为app的propertis文件，输入内容, 如【teacherName=itnanls】，编写如下配置类:1 @Configuration2 @PropertySource(\"classpath: app. properties\")3 public class AppConfiguration {4\\}测试用例如下:",
  "assets/net-img-1679288455665-cd692ecd-bdd1-4b86-9df3-d78d03cfeb58-20230321112830-i0uyo2l.png": "1 @SpringBootTest(classes = AppConfiguration.class)2 public class PropertySourceTest {3} @autowired4 Environment environment;5 @Test6 public void testEnv(){if System. out.printIn(environment. getProperty(\"teacherName\")) ;8 }9|}10ll 输出内容:12 itnan1s",
  "assets/net-img-1679293243316-756d84f4-e84a-46a0-93b1-31f8635fd5af-20230321112830-ri26p3u.png": "2、ProfilesProfiles在核心容器中提供了一种机制，人允许在不同环境中注册不同的Bean。 “环境\"这个词对不同的用户有不同的含义，。 在开发中使用内存中|。 为客户A和客户B部署注册定制的bean实现。的数据源，还是在生产中从INDI中查找的数据源。考虑一个实际应中的第一个用例，它需要一个数据源'。 在测试环境中，配置可能类化各下:1 @Bean2 public DataSource dataSource() {3 return new EmbeddedDatabaseBui Ider()4 . setType (EmbeddedDatabaseType. HSQL)5 .addScript (\"my-schema.sq]\")6 [ -addscript(\"my-test-data.sql\")7 -buildQ;8 }TES RUA RSIE SRD, iQ SAE RC LSS SRS Se NDIB SRdataSource ' bean现在看起来如下所示:1 @Bean2 public DataSource dataSource() throws Exception {3 Context ctx = new InitialContext();4 return (DataSource) ctx. lookup(\"java: comp/env/jdbc/datasource\") ;5|}重点: 问题是如何根据当前环境在使用这两种数当然，我们可以使月GProfile,导源之间进行切换?P。 我们的'【@Profile】注解允许您指出，当一个或多个bean在哪一种Profile被激活时被注入。 使用前画的例子，我们可以将dataSource配置重写如下:",
  "assets/net-img-1679293332405-cb091bba-0b08-4494-aa94-1843742dc4cc-20230321112830-uszvkkf.png": "1 @Configuration2 @Profile(\"development\")3 public class StandaloneDataConfig {45 @Bean6 public DataSource dataSource() {7, return new EmbeddedDatabaseBui Ider ()8 . setType (EmbeddedDatabaseType. HSQL)9 .addScript(\"classpath: com/bank/config/sq1/schema.sq1\")10 .addScript(\"classpath: com/bank/config/sq1/test-data.sql\")11 -buildQ;12 }13/}java1 @Configuration 工2 @Profile(\"production\")3 public class IJndiDataConfig {45 @Bean(destroyMethod=\"\")6 public DataSource dataSource() throws Exception {7 Context ctx = new InitialContext();8 return (DataSource) ctx. lookup(\"java: comp/env/jdbc/datasource\");9 }10 }eProfiletBal ETERS, ROS—MBA—Membean (fia, st+—MeebeaniiS teh), 2 NERAAra",
  "assets/net-img-1679293347637-a7839185-d586-487e-9aa5-2b6503c4385f-20230321112831-c7t4gej.png": "1 @Configuration2 public class AppConfig {@Bean(\"dataSource\")@Profile(\"“development\")public DataSource standaloneDataSource() {return new EmbeddedDatabaseBui Ider (). set Type (EmbeddedDatabaseType. HSQL).addScript(\"classpath: com/bank/config/sql/schema.sql\").addScript(\"classpath: com/bank/config/sql/test-data.sql\")-buildQ;@Bean(\"dataSource\")@Profile(\"production\")public DataSource jndiDataSource() throws Exception {Context ctx = new InitialContext();return (DataSource) ctx. lookup(\"java: comp/env/jdbc/datasource\");",
  "assets/net-img-1679293376038-d71e6bca-93a8-4987-a4a4-73023e0c1260-20230321112831-3n72v7f.png": "编程的方式1 ctx. getEnvironment().setActiveProfiles(\"profilei\", “profile2\");spring-boot PSSmBs, PTS RAT:1 kspri ng.profiles.active=devproperties",
  "assets/net-img-1679293608981-d7d4a4cf-1032-4673-a52e-207167e0b48c-20230321112831-mlgi2x7.png": "3、激活一个配置现在我们已经更新了配置，我们仍然需要指示Spring哪个配填文件是活动的。 如果我们现在启动我们的样例应用程序，我们会看到抛出一个NosuchBgeanDefinitionException ，因为容器无法找到名为datasource的Spring bean,激活配置文件有几种方式，但最直接的方式是通过【ApplicationContext】可用的【Environment】API以编程方式执行。 下面的例子展示了如何做到这一点:1 @Test2 public void testProfile(){3 // 创建容器4 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();5 // 省活环境6context.getEnvironment() .setActiveProfiles (\"development\") ;// Fecontext.scan(\"com.yd1class.datasource\");9 // 刷新10 context. refreshQ);al // 使用12 DataSource bean = context.getBean(DataSsource.class);13 logger. info(\"{}\", bean);此外，你还可以通过spring.profiles来声明性地激活环境【active】属性，它可[以通过系统环境变量、JVM系统属性、servlet上下MBSE web.xml '中指定。请注意，配置文件不是一个'非此即彼\"的命题。 您可以一次激活多个配置文件。 通过编程方式，您可以向' setActiveProfiles() 方法提供多个配置文件名，该方法接受' String…可变参数。 下面的示例激活多个配置文件加入启动参数:1 -Dspring.profiles.active=\"profilel, profile2\"",
  "assets/net-img-1679293650386-5c04dedf-b681-4cad-acbd-67f2c5a03cc5-20230321112831-ujht4mg.png": "五、发布订阅一、简介spring汶我们提供了event multicaster，可以十分简单的实现发布订阅模式:multicast (组播) : 也叫多播，多点广播或群播。 指把信息同时传递给一组目的地址。它使用策略是最高效的，因为消息在每条网络链路上只需传递一次，而且只有在链路分又的时候，消息才会被复制。事件消息(A事件) 1listener I(ABH) ;ws 3(ABH) : 1Mutticaster 发布事件”事件消息| listener listener(多播器) (ABH) (A事件) (BE) :事件消息(A事件)listener(A事件)spring启动时也会默认注入一个如下的bean: simpleApplicationEventMuiticaster，我们可以使用这个类轻松实现事件机制，这是典型的观察这设计模式:",
  "assets/net-img-1679293701941-dc63e587-56cd-44d6-92eb-565571712200-20230321112831-t86z1v8.png": "1@Testpublic void t caster(){SimpleApplicationEventMulticaster caster =new SimpleApplicationEventMulticaster();caster.addApplicationListener (new EmailListener());caster.addApplicationListener(new EmailListener());caster.addApplicationListener (new MessageListener());caster.multicastEvent(new OrderEvent(this));",
  "assets/net-img-1679300441058-abbbcae9-7b82-47bd-9765-a31e5d4c1a41-20230321112831-lz5sewv.png": "public class 0rderEvent extends ApplicationEvent {no usages Ipublic OrderEvent(Object source) {e super (source) ;",
  "assets/net-img-1679300540877-c212050d-8b74-4e50-a278-83507440ede6-20230321112831-vutuioo.png": "DCpublic class MessageListener implements ApplicationListener\u003cOrderEvent\u003e {4 usages@Overridepublic void onApplicationEvent(OrderEvent event) {System. out.println(event.getSource()+\"--\u003eii{a Rik f! \");Ip",
  "assets/net-img-1679300592927-a4cfe20a-eb08-4ab4-99bf-297008cb8f1e-20230321112831-k4iyhwl.png": "二、源码阅读中有很多复杂的情况，比如listener是我们直接手动注册的实例呢，还是spring工厂中的bean呢，如果是bean是singleton还是prototype呢?RABEL, RSS Tee:图一:addApplticationListener的过程DefauttListenerRetriever ，编程式的添加listener | 肤认的存储listeners的检索工具|编程式的直接注册1 applicationListeners，他是set集合'ABAGH sm listenertROHY aLE 从闪避中获取单例，实现了listener接口的bean 的besn让接注册| applicationtistenerBeans 'listeners! _ | |i Etisal \u003e ffiibean 。 非单例bean1 。 单例bean2 '判断为非单例容器不会保存单例bean， | ，我们需要保存bean的名字, 2 | 1机会实例化图二显示了当listener被调用执行后，如何进行了缓存:",
  "assets/net-img-1679300692269-13d1ae12-de2e-4749-b541-dfc762e1df47-20230321112831-ydet3v6.png": "SimpleApplicationEventMulticaster篇程式的添加Ustener 默认的存储Usteners的检索工具defaultRetrieverneSEAT listeneri#O的bean将名字注入实现了listener接口的bean|listener1 listener2单例bean1 。” 非单例bean1 = 单例bean2retrieverCache是map结构可以作为一级缓存，先从这个缓存中找ListenerCacheKey 一Cached ListenerRetrieverListenerCacheKey 一Cached ListenerRetriever| |非单例bean1 。 非单例bean1 。 非单例bean1listener1编程式。 listener2单例bean 。 listener2单例bean",
  "assets/net-img-1679303462823-4a94a830-3ba0-4947-bf97-17e11148849e-20230321112831-9di3w2j.png": "SimpleApplicationEventMulticaster源码如下:1 public class SimpleApp]icatzonEventMulticaster extends AbstractApplicationEventMulticaster {23 // 定义一个线程池，事件被触发时可由他来实现事件，黑认为nu114 private Executor taskExecutor;5)6 // 这个用来捕获1istener执行过程中产生的异常7 // 需要这用赋值caster.setErrorHandler(Cnew XxxErrorHandlerO )8 private ErrorHandler errorHandler;9 private volatile Log lazyLogger;10II12 public SimpleApplicationEventMulticaster() {}13 public SimpleApplicationEventMulticaster(BeanFactory beanFactory) {14 setBeanFactory(beanFactory);15 }1617 public void setErrorHandler(@Nullable ErrorHandler errorHandler) {18 this.errorHandler = errorHandler;19 }20",
  "assets/net-img-1679304417727-6cbaf316-0400-4d69-8d94-32d427070759-20230321112832-ywvcgtx.png": "@Nullableprotected ErrorHandler g\u0026étErrorHandler() {return this.errorHandler//设置一个自定义执行器《线程池) 来调用每个侦听器。public void setTaskExecutor(@Nullable Executor taskExecutor) {this.taskExecutor = taskExecutor;3@Nullableprotected Executor getTaskExecutor() {return this. taskExecutor// 广播一个事件Goverridepublic void multicastEvent(ApplicationEvent event) {multicastEvent(event, resolveDefaultEventType(event));",
  "assets/net-img-1679304576914-41efc5bc-a120-48c9-ae3a-fbad7c5dcf92-20230321112832-jm9v3aa.png": "// 广播一个事件的具体实现Goverridepublic void multicastEvent(final ApplicationEvent event, G@Nullable ResolvableType eventType) {ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));Executor executor = getTaskExecutor();// 核心一: getApp1icationListeners(event，type)稍后看// 他的重点是如何设计的缓存// 获取所有与event事件匹配的1istener并调用核心方法onApp1icationEventfor (ApplicationListener\u003c?\u003e listener : getApplicationListeners(event, type)) {// 如果你设置了线程池他会将任务丢给线程池if (executor != null) !{/kf 核心二: 调用Listener的方法invokeListenerexecutor.execute(() -\u003e invokeListener(listener, event));}// 否则就以单线程的方式运行else {invokeListener(listener, event);// 调用1istener的方法protected void invokeListener(ApplicationListener\u003c?\u003e listener, ApplicationEvent event) {// ErrorHandler可以保存Listener在执行过程中产生的异常// 其默认为nu11，我们可以独立设置ErrorHandler errorHandler = getErrorHandler();if (errorHandler != null) {try {doInvokeListener(listener, event);}catch (Throwable err) {// 将执行1istener时产生放入errorHandlererrorHandler.handleError(err);",
  "assets/net-img-1679304608043-b5adf6cf-21ef-45a0-92a9-0ca85439cd6a-20230321112832-nwgk91g.png": "100101102103104105106107}else {// 负责直接调用doInvokeListener(listener, event);@SuppressWarnings({\"rawtypes\", \"unchecked\"})private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {try {// 调用方法Tistendr. onApplicationEvent(event);}// 捕获类型转化异常catch (ClassCastException ex) {String msg = ex.getMessage();if (msgnull || matchesClassCastMessage(msg, event.getClass()) |(event instanceof PayloadApplicationEvent \u0026\u0026 matchesClassCastMessage(msg,((PayloadApplicationEvent) event) .getPayload().getClass()))df// 可能是1ambda定义的侦听器，我们无法为其解析泛型事件类型// 让我们抑制异常。Log loggerToUse = this.1azyLoggerif CloggerToUse == null) {loggerToUse = LogFactory.getLog(getClass());this. lazyLogger = loggerToUse;}if CloggerToUse.isTraceEnabled()) {loggerToUse.trace(\"Non-matching event type for listener}} else {throw ex;+ listener, ex);Error in boxClipToRectangle: box outside rectangleError in pixScanForForeground: invalid box",
  "assets/net-img-1679316696404-bf04d17a-69fa-449a-a67f-4d5f4592e224-20230321112832-vvg3biy.png": "六、国际化spring引入了MessageSource机制，可以帮有我们简单的实现[fl4 (internationplization) ，简称i18n。ResourceBundleMessageSource是一个简单的实现，我们可以建立如下的文件用以测试:文件内容超级简单，分别是:© zh_CN的文件内容: hello=你好{0}© en_us的文件内容: hello=hello {0}使用以下的测试用例就可以简单的获取对应Locale的内容:1 @Test2 public void testMessageSource(){3 ResourceBundleMessageSource rbs = new ResourceBund]eMessageSource();4 rbs .setBasename(\"i18n/message\");5 rbs.setDefaultEncoding(\"UTF-8\");6 rbs.setDefaultLocale(Locale.CHINA) ;7 String hello = rbs.getMessage(\"hello\", new Object[]{\"tom\"}, Locale.US);8 System. out.printIn(hello);9/3关于方法中的几个参数的描述:。 string code: 文件中的key。 Object[ args: 待解析字符串的参数，value中可以存在带{}占位符的变量。 String defaultMessage: 读取不到国际化信息时依据此默认值进行处理。 Locale locale: 国际化定位，如Locale.CHINA te FE图",
  "assets/net-img-1679325628988-2ebe6252-6564-46bb-9df4-917bf43b2293-20230321112832-0ptsh3c.png": "七、表达式1、简介本节介绍【SpEL接口及其去达式语言】的简单使用。 下面的代码引入了SpEL APl来计算字符捉字面表达式' Hello World '。1 ExpressionParser parser = new SpelExpressionParser();2 Expression exp = parsen panseexpics sion Gglclto World'\");3 String message = (String) exp.getValue();消息变量的值是\"Hello World\",【ExpressionParser]】 接口【负责解析去达式字符捉】。[Expression] 接口负责计算前面定义的表达式字符串。EvaluationException 两个异常。【Expression】接口负责【计算前面定义的表达式字符中java在前面的示例中，表达式字符站是|引号表志当调用parser时，可以抛出ParseException和2]. SPpEL支持广泛的特性，例如调| 在下面的方法调用示例中，我们甚至可以在字符中字面量上调用【concat】方法:1 ExpressionParser parser = new SpelExpressionParser();2 Expression exp = parser.parseExpression(\"'Hello World’.concat('!')\");3 String message = (String) exp.getValue();\" message 的值现在是'Hello World!',| 下面的例子调用了' String Bt [bytes] :ExpressionParser parser = new SpelExpressionParser();Expression exp = parser.parseExpression(\"'123 // invokes 'getBytes()'45 byte[] bytes = (byte[]) exp.getvalue();RATES HERAT TRA.Hello World’ .bytes\");JFoa\u003ens,方法、访问属性和调用构造函数。",
  "assets/net-img-1679325690309-f9bb5be8-2300-4939-9309-c9f9a22c8b99-20230321112832-3m12aw8.png": "SpEL还通过| 祭准点表示法(如' prop1.prop2.prop3 ') 和相应的属性值设置来支持嵌套属性。 也可以访问公共字段。下面的例子展示了如何使用点表示法来获取文字的长度:ExpressionParser parser = nev] SpelExpressionParser(O);Expression exp = parser.parseExpression(\"'Hello World’. bytes. length\");123 // invokes ‘getBytes(). length’45 int length = (Integer) exp.getValueQ);还可以调用String的构造函数而不是使用字符四字面值，如下例所示:1 ExpressionParser parser = new SpelExpressionParser();2 Expression exp = parser.parseExpression(\"new String(‘hello world').toUppercase()\");3 String message = exp.getValue(String.class);从字面量构造一个新的' String '，并使其为大写。",
  "assets/net-img-1679325721732-27e6ed60-b75f-4791-a2f6-6dd6b09250c3-20230321112832-kygy9rr.png": "SpEL更常见的用法是提供一个针对特定对象实例(称为根对象) 求值的表达式字符串。 下面的例子展示了如何从Inventor类的实例中检索' name '属性:// Create and set a calendarGregorianCalendar c = new GregorianCalendar();c.set(1856, 7, 9);// The constructor arguments are name, birthday, and nationality.Inventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"“Serbian\");ExpressionParser parser = new SpelExpressionParser();I10 Expression exp = parser.parseExpression(\"name\"); // Parse name as an expression11 String name = (String) exp.getValue(tesla);CANAURWNH12 // name == \"Nikola Tesla”3 // 这个表达式在比较连个名字是不是\"Nikola Tesla‘14 exp = parser.parseExpression(\"name == \"Nikola Tesla'\");15 boolean result = exp.getValue(tesla, Boolean.class);16 // result == truePa TATASRRS pELRAS AE Tm RET ECE [BeanDefinition] Shi, 在这两种情况下，定义玫达式的语法形式都是#{\u003cexpression string\u003e},",
  "assets/net-img-1679325754097-23a67262-7d99-4da8-b2d6-da5bc980e428-20230321112833-ahlw44f.png": "2、XML配置属性或构造函数参数值可水通过使用表达式设置，如下例所示:1 \u003cbean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\"\u003e2 \u003cproperty name=\"randomNumber\" value=\"#4{ T(java.lang.Math).random() * 100.0 }\"/\u003e34 \u003c!-- other properties --\u003e5 \u003c/bean\u003e应用程序上下文中的所有bean都可以作为【具有公共bean名称】的预定义【变量】使用(意识就是可以将bean的名称作为表达式的变量) 。这包括于访问运行时环境的标准上下文bean，如【environment】，以及【systemProperties】和【systemEnvironment 】等bean实例。下面的示例显示了对【systempProperties】 bean的SpEL变量访问:1 \u003cbean id=\"taxCalculator\" class=\"org.spring.samples.TaxCalculator\"\u003e2 \u003cproperty name=\"defaultLocale\" value=\"#{systemProperties[*user.region'] }\"/\u003e3 \u003c!-- other properties --\u003e4 \u003c/bean\u003e注意，这里不需要在预定义变量前加上' # '符号。我们还可水通过名称引用其他bean属性，如下例所示:",
  "assets/net-img-1679325782240-9202fc9d-5e2a-4638-bfd8-e47d11139aba-20230321112833-d1ct2ft.png": "CONAUARWNHE1011\u003cbean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\"\u003e\u003cproperty name=\"randomNiimber\" value=\"#{ T(java.]ang.Math).random() * 100.0 }\"/\u003e\u003c!-- other properties --\u003e\u003c/bean\u003e\u003cbean id=\"shapeGuess\" class=\"org.spring.samples.ShapeGuess\"\u003e\u003cproperty name=\"initialShapeSeed\" value=\"#{ numberGuess.randomNumber }\"/\u003e\u003c!-- other properties --\u003e\u003c/bean\u003e",
  "assets/net-img-1679325795784-b32a4f90-563f-4c4e-bffa-12998b189bef-20230321112833-v69gyat.png": "3、注解配置要指定默认值，可以在字段、方法和方法或构造函数参数上放置(@Value'》设置字段的默认人的示例如下:1 public class FieldValueTestBean {23 @value(\"#{ systemProperties['user.region'] }\")4 private String defaultLocale;56 public void setDefaultLocale(String defaultLocale) {he this.defaultLocale = defaultLocale;8 }910 public String getDefaultLocale() {11 return this.defaultLocale;12 }",
  "assets/net-img-1679325811844-29bfb5c8-d228-4538-8bad-35f161737eab-20230321112833-ww48d6h.png": "下面的例子展示了一个等价的属性setter方法:1 public class PropertyValueTestBean {23 private String defaultLocale;45 @Value(\"#{ systemProperties['user.region'] }\")6 public void setDefaultLocale(String defaultLocale) {7 this.defaultLocale = defaultLocale;8 }910 public String getDefaultLocale() {11 return this.defaultLocale;12 }",
  "assets/net-img-1679325822896-07c16b0c-af93-428d-b5f6-7485080e3ea7-20230321112833-ilcc45s.png": "动连接的方法和构造函数也可以使用@Value 注解，如下面的例子所示:public class SimpleMovieLister {, oo callprivate MovieFinder movieFinder;private String defaultLocale;@Autowiredpublic void configure(MovieFinder movieFinder,@value(\"#{ systemProperties['user.region'] }\") String defaultLocale) {this.movieFinder = movieFinder;this.defaultLocale = defaultLocale;Up ae",
  "assets/net-img-1679325830941-35345870-bdd0-41b6-9ac1-33e99509051d-20230321112833-3eigz0i.png": "123456public class MovieRecommender {private String defaultLocale;private CustomerPreferenceDao customerPreferenceDao;public MovieRecommender (CustomerPreferenceDao customerPreferenceDao,@value(\"#{systemProperties['user.country']}\") String defaultLocale) {this.customerPreferenceDao = customerPreferenceDao;this.defaultLocale = defaultLocale;IUf a3",
  "assets/net-img-1679325843052-767f5e6c-c11c-42f0-8317-5a929ab713cd-20230321112833-9pdrsad.png": "4、语法参考(不需要记忆啊)1, 文字表达方式支持的文字表达式类型有字符串、数字值、布尔信和空信。 字符串由单引号分隔。 若要将单引号本身放入字符串中，请使用单引号字符。下面的例子晶示了文字的简单用法。 通常，它们不会像这样单独使用，而是作为更复杂表达式的一部分使用。例如，在远辑|运算符的一侧使用文字。1 ExpressionParser parsek = new SpelexpressionParser();// evals to “Hello world\"String helloworld = (String) parser.parseExpression(\"'Hello World'\").getvalue();double avogadrosNumber = (Double) parser.parseExpression(\"6.0221415E+23\").getvalueQ);Jo wm 上wwN8 // evals to 21474836479 int maxValue = (Integer) parser.parseExpression(\"Ox7FFFFFFF\").getValue();11 boolean trueValue = (Boolean) parser.parseExpression(\"true\").getValue();13 Object nullValue = parser.parseExpression(\"nul1\").getVvalue();数字支持使用负号、指数符号和小数点。 EXER, GEADouble.parseDouble() 解析实数。比较",
  "assets/net-img-1679326286375-127cf240-c327-4ec0-b217-91e8ee931421-20230321112833-8ou3j2v.png": "2、Arrays，Lists， Maps| 便用[点】开指示绒训的属性值。1 // evals to 18562 int year = (Integer) parser.parseExpression(\"birthdate.year + 1900\").getValue(context) ;4 String city = (String) parser.parseExpression(\"placeOfBirth. city\") .getValue(context) ;More Actions人允许属性名称的首字母1900\"和“placeOfBirth.city'。 此外，可以通过方法调placeOfBirth.city 。RI分大小写。此，上面例子中的表达式可以写成\"birthdate.year +访问属性Fig, ' getPlaceOfBirth(). getcity() 而不是'",
  "assets/net-img-1679326295282-48dfd13e-2899-49c7-90e9-15998db02178-20230321112833-snmwycg.png": "| 便用方括号表示法获取数组和列表的内容，示例如下:1 ExpressionParser parser = new SpelExpressionParser();2 EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding() .build();3// Inventions Array456 // evaluates to “Induction motor\"7 String invention = parser.parseExpression(\"inventions[3]\").getValue(8 context, tesla,String.class);9 I10 // Members List1112 // evaluates to \"Nikola Tesla\"13 String name = parser.parseExpression(\"members[0].name\").getValue(14 context, ieee, String.class);16 // List and Array navigation17 // evaluates to “Wireless communication\"18 String invention = parser.parseExpression(\"members [0]. inventions[6]\").getValue(19 context, ieee, String.class);",
  "assets/net-img-1679326308572-795a7aca-0efb-473b-9b8b-6fe4837ba803-20230321112833-3igb6p4.png": "3、 内联列表可以使用匡符号在表达式中直接雪示列表。1 // evaluates to a Java list containing the four numbers2 List numbers = (List) parser.parseExpression(\"{1, 2, 3, 4}\").getValue(context);34 List listOfLists = aby parser.parseExpression(\"{{'a', 'b'}, {'x', 'y'}}\").getvalue(context) ;{} 它本身就是一个空列表(list). WHESRA, URIS TSHRENS EAN, Ste MITA式(而不是在每次求值时构建一个新列表) 。4、 内联映射我们还可以使用fkey: value} 表示法在表达式中直接表示映射关系。 下面的例子展示了如何做到这一点:1 // evaluates to a Java map containing the two entries2 Map inventorInfo = (Map) parser.parseExpression(\"{name: ‘Nikola’, dob: '10-July-1856'}\").getValue(context);4 Map mapOfMaps = (Map) parser.parseExpression(\"{name:{first: ‘Nikola’, last:'Tesla‘}, dob: {day:10,month: ‘July’, year:1856}}\").getValue(context) ;CIECASME TSR (map). 出于性能原因，如果映射本身由固定的文字或其他嵌套的常量结构组成，则创建一个常量映射来表示表达式(而不是在每次求人时构建一个新映射) 。",
  "assets/net-img-1679326317277-529d8be1-043f-414f-bf86-bcd6d0f53143-20230321112834-0h4su1n.png": "5、 数组结构可以使用熟悉的java语法构建数组，也可以提供一个初始化式，以便在构造时填充数组。 下面的例子展示了如何做到这一点:int[] numbersl = (int[]) parser.parseExpression(\"new int[4]\").getvalue(Ccontext) ;// Array with initializer// Multi dimensional array1234 int[] numbers2 = (int[]) parser.parseExpression(\"new int[]{1,2,3}\").getValue(context) ;56int(][] numbers3 = (int[][]) parser.parseExpression(\"new int[4][5]\").getValue(context) ;You cannot currently supply an initializer when you construct a multi-dimensional array.6, 方法调用我们可以使用典型的ava编程语法来调用方法。 我们还可以在文字上调用方法。 也支持变量参数。 下面的例子|法: I// string literal, evaluates to “bc”String bc = parser.parseExpression(\"'abc'.substring(1,3)\").getValue(String.class);boolean isMember = parser.parseExpression(\"isMember('Mihajlo Pupin')\").getValue(工234 // evaluates to true56societyContext, Boolean.class);展示了如何调用方",
  "assets/net-img-1679326336638-f21f1f88-e27d-4796-9451-cdccd0ea7e0f-20230321112834-c6w7y5z.png": "7、 运算符Spring志达式语言支持以下类型的操作符:。 逻辑运算符。 数学运算符。 RIES| 关系二算符使用标准操作符雪示法支持关系操作符(等于、不等于、小于、小于或等于、大于和大于或等于)。 下面的例子展示了一些操作符示Bil:// evaluates to trueboolean trueValue = parser.parseExpression(\"2 == 2\").getValue(Boolean.class);// evaluates to falseboolean falseValue = parser.parseExpression(\"2 \u003c -5.0\").getValue(Boolean.class);// evaluates to trueboolean trueValue = parser.parseExpression(\"'black’ \u003c ‘block'\").getValue(Boolean.class);ONAURWNE",
  "assets/net-img-1679326357403-b1f04d8d-699a-4f41-9adf-0880f359312d-20230321112834-k6ad5ey.png": "除了标准的关系操作符外，SpEL还支持instanceof和基于正则表达式的matches 操作符。 下面的例子展示了两者的例子:NowmhwmNH891011// evaluates to falseboolean falseValue = parser.parseExpression(\"'xyz' instanceof T(Integer)\").getValue(Boolean.class);// evaluates to trueboolean trueValue = parser.parseExpression(\"'S.00' matches ‘A-?\\\\d+(\\\\.\\\\d{2})?S'\").getvalue(Boolean.class);// evaluates to falseboolean falseValue = parser.parseExpression(”5.0067” matches 'A-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);个符号运算符也可以指定为纯字母等效符。 这避免了所使用的符号对嵌入表达式的文档类型(例如XML文档)贞有特殊意义的问题。 对应文本为:",
  "assets/net-img-1679326385891-247c5593-9d5e-4476-bef4-4b3ab5b0e041-20230321112834-wytdo8j.png": "It (\u003c)。 gt (\u003e)e。 le (\u003c=)ge (\u003e=)。 eq (==ne (!=)¢ div(/)© mod (%)e not (!).所有的文本操作符都是不区分大小写的。",
  "assets/net-img-1679326415013-a543e744-e161-41fe-a2b6-4b8aa42098bb-20230321112834-k0v0c7m.png": "| setSpEL支持以下逻辑操作符;© and (\u0026\u0026)¢ or(}1)se not (!)",
  "assets/net-img-1679326428476-5fb8029f-36be-4ed3-b997-67130b6c6029-20230321112834-e1c0h34.png": "下面的示例演示如何使用逻辑运算符;// -- AND --aft23 // evaluates to false4 boolean falseValue = parser.parseExpression(\"true and false\"). getValue(Boolean.class);567// evaluates to trueString expression = \"isMember('Nikola Tesla’) and isMember('Mihajlo Pupin')\";8 boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);10) // -- OR --12 // evaluates to true13 boolean trueValue = parser.parseExpression(\"true or false\").getValue(Boolean.class);15 // evaluates to true16 String expression = “isMember('Nikola Tesla’) or isMember('Albert Einstein')\";17 boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);18 ik19| // -- NOT --2021 // evaluates to false22 boolean falseValue = parser.parseExpression(\"! true\") .getValue(Boolean.class);24 // -- AND and NOT --25 String expression = “isMember('Nikola Tesla’) and !isMember('Mihajlo Pupin')\";26 boolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);",
  "assets/net-img-1679326440170-879a21ba-7120-40dd-8d99-d34be63e14aa-20230321112834-jtmz9cl.png": "| BasesPRET ESL加法运算符(+ )。 BATTS EACH -), FOA(* AOE / RE. BATALISHES HERS ESS. 执行标准操作符优先级。 下面的例子展示了使用中的数学运算符:// Additionint two = parser.paString testString =rseExpression(\"1 + 1\").getValue(Integer.class); // 2parser.parseExpression(test’ + + ‘string'\").getValue(String.class); // ‘test string’I// Subtractionint four = parser.parseExpression(\"1 - -3\").getValue(Integer.class); // 4double d = parser.parseExpression(\"1000.00 - 1e4\").getValue(Double.class); // -9000// Multiplicationint six = parser.padouble twentyFour =// DivisionrseExpression(\"-2 * -3\").getValue(Integer.class); // 6parser.parseExpression(\"2.0 * 3e0 * 4\").getValue(Double.class); // 24.0int minusTwo = parser.parseExpression(\"6 / -3\").getValue(Integer.class); // -2double one = parser// Modulus.parseExpression(\"8.0 / 4e0 / 2\").getValue(Double.class); // 1.0int three = parser.parseExpression(\"7 % 4\").getValue(Integer.class); // 3int one = parser.parseExpression(\"8 / 5 % 2\").getValue(Integer.class); // 1",
  "assets/net-img-1679326452027-c61c204b-aedd-4867-aacf-914ae365dfd8-20230321112834-1o1yars.png": "2627 // Operator precedence28 int minusTwentyOne = parser.parseExpression(\"1+2-3*8\").getValue(Integer.class); // -21",
  "assets/net-img-1679326461388-6f38b75c-fb6f-4531-8eaa-03f27a0dcf80-20230321112834-sh6t3ve.png": "| meena要设置属性，请使用赋值操作符(=)。 这通常是在调用setvalue 中完成的，但也可以在调用getvalue 中完成。 下面的例子展示了便用赋值操作符的两种方法:Inventor inventor = new Inventor();EvaluationContext context = SimpleEvaluationContext. forReadwriteDataBinding() .buildQ;parser.parseExpression(\"name\").setValue(context, inventor, “Aleksandar Seovic\");// alternativelyString aleks = parser.parseExpression('\").getValue(context, inventor, String.class);ONAUAWNEH“name = ‘Aleksandar Seovic",
  "assets/net-img-1679326473664-5eb7789c-4b17-44ec-b1c4-b16a4e274ab5-20230321112835-3ne62m1.png": "8、类型你可以使用特殊的' T 操作符来指定一个'java.lang.Class '(类型) 的实例。 静态方法也可以通过使用此操作符来调用。StandardTypeLocator类会黑认注册【java.lang】包下的类。 这意味着' T0 '引用java.lang包不需要完全限定，但所有其他类型引用必须是完全限定的, 下面的示例演示如何使用'T\"操作符:1 Class dateClass = parser.parseExpression(\"T(java.util.Date)\").getValue(Class.class);23 Class stringClass = parser.parseExpression(\"T(String)\").getValue(Class.class);boolean trueValue = parser.parseExpression(\"T(java.math.RoundingMode).CEILING \u003c T(java.math.RoundingMode) .FLOOR\")- getValue(Boolean.class);NOURStandardTypeLocator类的构造器如下:",
  "assets/net-img-1679326502697-f4c8fc21-f5e0-4fc6-9dbf-25df3c30bbd8-20230321112835-k16vvaj.png": "public class StandardTypeLocator implements TypeLocator {public StandardTypeLocator (@Nullable ClassLoader classLoader) {this. knownPackagePrefixes = new ArrayList(1);this.classLoader = classLoaderthis.registerImport(\"“java. lang\");",
  "assets/net-img-1679326509541-5069cadc-2cce-4828-bd30-07168d3e544a-20230321112835-inlo8kf.png": "9、构造函数你可以使用new操作符来调用构造函数。 你应该对所有类型使用完全限定类名，除了那些位于java.lang package (Integer ,Float, string ，等等)。 下面的例子展示了如何使用new操作符来调用构造函数:Inventor einstein = p.parseExpression(“new org.spring.samples.spel.inventor.Inventor('Albert Einstein’, 'German')\").getValue(Inventor.class);// create new Inventor instance within the addQ) method of Listp.parseExpression(“Members.add(new org.spring.samples.spel. inventor. Inventor(\"Albert Einstein’, '‘German'))\").getValue(societyContext) ;NOURWNEHoo",
  "assets/net-img-1679326521803-d557d4c4-d1cf-41e5-852d-7c30023996cf-20230321112835-39q9but.png": "10、变量可以使用#variableName 语法引用表达式中的变量。 变量是通过在EvaluationContext实现上使用setVariab1e方法设置的。下面的例子展示了如何使用变量。Inventor tesla = new Inventor(\"Nikola Tesla\",\"Serbian\");123 // 我们必须创建一个上下文，在上下文中定义变量4 EvaluationContext Context = Siip1leEvaluationContext.forReadwriteDataBinding(G .buildQ);56Context.setVvariable(C\"newName\"，Mike Tesla\");parser.parseExpression(\"name = #newName\").getValue(context, tesla);System.out.printIn(tesla.getName()) // \"Mike Tesla\"oo",
  "assets/net-img-1679326535090-4e0cea79-2afe-4605-82e5-e3dad1cee0e0-20230321112835-19o479d.png": "11、Bean 的引用如果计算上下文已经配置了bean解析器，那么我们可以使用\u0026符号从表达式中查找bean。下面的例子展示了如何做到这一点:NOUPRWNR要访问FactoryBean本身，应该在bean名称前加上' \u0026 FS. 下面的例子展示了如何做到这一点:omwnN// 定义一个容器ApplicationContext ctx = new AnnotationConfigApplicationContext(A.class);// 创建一个解析器ExpressionParser parser = new SpelExpressionParser();// 定义一个表达式上下文StandardEvaluationContext context = new StandardEvaluationContextQ);// 这个地方规定了我要从哪里查找bean ，我们的具体实现是BeanFactoryResol1ver，代表了从容器中获取context.setBeanResolver(new BeanFactoryResolver(ctx));Object bean = parser.parseExpression(\"GmessageListener\").getValue(context);javaExpressionParser parser = new SpelExpressionParser();StandardEvaluationContext context = new StandardEvaluationContext(Q);context.setBeanResolver (new MyBeanResolver());// This will end up calling resolve(context, \"\u0026foo\") on MyBeanResolver during evaluationObject bean = parser.parseExpression(\"\u0026foo\") .getValue (context) ;",
  "assets/net-img-1679326612554-852633bd-e2fb-4bcf-aeee-4519a86b87ef-20230321113609-bvb7gtu.png": "第三章容器和上下文!本章节，我们会深入了解【容器和上下文】，并从源码的角度做出深度的解析。目前，我们所接触的容器主要有servlet容器和springhlass, Ase]用中十分重要，大致有以下好处:1、统一管理，使用容器通常需要按照统一的规范，比如我们的jakarta Serviet™ 6.0规范，spring6.0规范等等。按照特定规范，编写规范的容器内容(servlet，bean) ,可以更好的管理容器内容的生命周期。2、隔高应用，屏蔽外界|将更多的精力放在业务上。3、分层管理，每个|一、认识bean工厂bean工厂是我们spni中我们需要注意几点:ng容器的载体，是spring8上下文的主要内容。下图展示了我们整个bean工厂的常见的接口和类以及功能,其的复杂性，更专注于业务开发。理论上，我们可以不明白容器是如何启动的，如何建立了连接等等，可以呈边界清晰，名司其职，如mvc的容器就和spring的容器不一样，又互相关联。1. 不同的接口展现了不同的能力，是对子类能力的抽象2. 抽象类构建通|方法的实现，是通上核心方法的具体实现3. 具体类完成特定功能的实现，是特定功能的具体实现有了这样的思想, 3我们才能更好的区阅读源码:",
  "assets/net-img-1679326933462-7a68f831-4756-4ccf-b880-4a5795c79fd4-20230321113609-d6b3wqf.png": "beanFactory接口这个接口表明实现类是一个bean工厂ListablebeanFactory接口枚举其容器内所有bean的能力抽象类AutowireCapabteBeanFactory接口实现了该接口的工厂拥有自动装配能力解决依赖注入的问题ConfigurableListableBeanFactory接口复合接口拥有以上所有能力HierachicalBeanFactory接口SingletonBeanRegistry接口该接口为我们的bean工厂提供了分层的能力该接口有注册单例bean的能力不同的工厂可以通过父子关系关联| |trConfigurableBeanFactory##0提供对bean工厂的一些额外配置的能力比如: 忽略一些类型的自动装配等|AbstractBeanFactory抽象类|AbstractAutowireCapableBeanFactory抽象类提供了一些公用方法4DefaultsingletonBeanRegistry类默认的单例bean注册器所有的bean都放在这里(三级缓存)4FactoryBeanRegistrySupport抽象类提供对FactoryBean的注册支持这里保存了所有的FactoryBeanBeanDefinitionRegistry接口实现该接口会拥有BeanDefinition的注册能力DefaultListableBeanFactory类|\u003e 这是我们最核心的一个bean工厂实现类|XmlBeanFactory接口这个接口表明其实现类是一个bean工厂",
  "assets/net-img-1679327309270-0a0b1173-b632-471d-a57a-ac2e93251435-20230321113609-v9c9rq5.png": "1、基础能力从接口的定义中，我们可以完全了解bean的基础功能，主要是获取bean以及获取bean的一些基本特征:ib245619public interface BeanFactory {// 这个变量在获取一个FactoryBean时使用，后边详细介绍String FACTORW_BEAN_PREFIX fps// 工厂的核心方法，提供了多种获取单个实例bean的能力Object getBean(String name) throws BeansException;\u003cT\u003e T getBean(String name, Class\u003cT\u003e requiredType) throws BeansException;Object getBean(String name, Object... args) throws BeansException;\u003cT\u003e T getBean(Class\u003cT\u003e requiredType) throws BeansException;\u003cT\u003e T getBean(Class\u003cT\u003e requiredType, Object... args) throws BeansException;\u003cT\u003e ObjectProvider\u003cT\u003e getBeanProvider(Class\u003cT\u003e requiredType) ;\u003cT\u003e ObjectProvider\u003cT\u003e getBeanProvider(ResolvableType requiredType) ;boolean containsBean(String name);boolean isSingleton(String name) throws NoSuchBeanDefinitionException;boolean isPrototype(String name) throws NoSuchBeanDefinitionException;@NullableClass\u003c?\u003e getType(String name) throws NoSuchBeanDefinitionException;Class\u003c?\u003e getType(String name, boolean allowFactoryBeanInit) throwsNoSuchBeanDefinitionException;ii29|}String[] getAliases(String name);",
  "assets/net-img-1679327621442-d038fdca-15f6-4e73-b6c4-34f23df11835-20230321113609-xxkydu5.png": "小插曲:ObjectProvider是为了解决隐式注和站时产生的问题spring4.3之前，我们的bean如果需要使用特定构造器进行构造时必须使用@Autowired尘1 @Service2 public class UserService {34 private UserDao userDao;5 @aAutowired6 public UserService(UserDao userDao) {7 this.userDao = userDao;8 }91}spring4.3之后，就可以不写，容器会降式为你注入:",
  "assets/net-img-1679327633142-a1c99cba-90a6-4ac7-9d77-4205347347d7-20230321113609-rz06jvs.png": "@Servicepublic class UserService {public UserService(UserDao userDao) {1234 private UserDao userDao;56 this.userDao = userDao;在当容器的bean可用且唯一时当然没有问题，但是容器如果没有这个bean就会出问题:1 Parameter 0 of constructor in com.ydlclass.UserService required a bean of type*com.ydlclass.UserDao' that could not be found.此时ObjectProvider就发挥作用了:",
  "assets/net-img-1679327656826-7c2ce79f-5c3d-4462-aa84-91bf2ccd0675-20230321113609-1yrxsd7.png": "@Servicepublic class UserService {public UserService(UserDao userDao) {1234 private UserDao userDao;56 this.userDao = userDao;8 }在当容器的hean可用目唯一时当然没有问题，但是容串如果没有这个bean就会出问题:1 Parameter 0 of constructor in com.ydiclass.UserService required a bean of type\"com.yd1iclass.UserDao’ that could not be found.此时ObjectProvider就发挥作用了:@servicepublic class UserService {public UserService(ObjectProvider\u003cUserDao\u003e userDao) {1234 private UserDao userDao:567 this.userDao = userDao.getIfUnique();这样注入的好处很明显，如果容器中不存在UserDao或者存在多个UserDao时，可以从容处再ObjectProvider接口如下，他继承自ObjectFactory，这个接口后边也会常用:站",
  "assets/net-img-1679327670995-860d75ce-acc9-4482-9b3b-c1cea1c8e41d-20230321113609-wkqv4rf.png": "工2.3451apublic interface \u003cT\u003e extends ObjectFactory\u003cT\u003e, Iterable\u003cT\u003e {T getObject(Object... args) throws BeansException;// 处理判断有可用的bean的时候我们怎么依，可以重写T getIfAvailable() throws BeansException;default T getIfAvailable(Supplier\u003cT\u003e defaultSupplier) throws BeansException {T dependency = getIfAvailable();return (dependency != null ? dependency : defaultSupplier.get());3default void ifAvailable(Consumer\u003cT\u003e dependencyConsumer) throws BeansException {T dependency = getIfAvailable();if (dependency != null) {dependencyConsumer . accept (dependency) ;// 处理判断只有唯一的bean的时候我们怎么做， 可以重写T getIfUnique() throws BeansException;default T getIfUnique(Supplier\u003cT\u003e defaultSupplier) throws BeansException {T dependency = getIfUnique();return (dependency != null ? dependency : defaultSupplier.get());了default void ifUnique(Consumer\u003cT\u003e dependencyConsumer) throws BeansException {T dependency = getIfUnique();if (dependency != null) {dependencyConsumer . accept (dependency) ;// 当匹配多个时，可以迁代处理Goverridedefault Iterator\u003cT\u003e iterator() {return streamQ.iterator();",
  "assets/net-img-1679327683188-cb5eb64d-123a-42be-a99c-12946df8ee3d-20230321113609-5da3672.png": "ObjectFactory作为一个对象工厂函数式接口更是简单:1 @FunctionalInterface2 public interface ObjectFactory\u003cT\u003e {34 [**5 * Return an instance (possibly shared or independent)6 * of the object managed by this factory.7 * @return the resulting instance8 * @throws BeansException in case of creation errors9 SA/10 T getObject() throws BeansException;1112 }修改UserService，新增login方;1 public class UserService {23 public void login(ObjectFactory\u003cUser\u003e userFactory) {4 User user = userFactory.getObject(Q);567System.out.println(\"使用[”+ user + \"]#H(THR\");}",
  "assets/net-img-1679327691440-f0bc44a7-db04-4013-bf9a-29ceeb16225c-20230321113609-lmz774x.png": "编写测试用例:1 @Test2 public void testObjectFactoryO{3 UserService service = new UserService();4 service. login(() -\u003e new User(\"tom\", 23));5 // 更复杂的实现，甚至可能是代理，如符合某种条件就生成代理6 service.1ogin(O -\u003e {7 int random = new Random() .nextInt(100) ;8 System.out.printIn(random) ;9 return random \u003e 50 ? new User(\"tom\", 24) : new User(\"jerry\", 33);10 vn:",
  "assets/net-img-1679327699321-ab9fd071-f087-4ad1-bc66-a8a4aea19070-20230321113610-omn7nvr.png": "2、更强的枚举能力LstableBeanFactory为后续的实现类提供了全强的枚学能力， 这些能力可能不对外公开，但是对于子类操作容器的操作bean十分重要，我们不妨看看他提供的接|1 public interface ListableBeanFactory extends BeanFactory {23 // 对BeanDefinition的细节操作4 boolean containsBeanDefinition(String beanName) ;5 int getBeanDefinitionCount();6 String[] getBeanDefinitionNames();8 // 根据类型检举出所有的Bean的名字9 String[] getBeanNamesForType(ResolvableType type);10 String[] getBeanNamesForType(G@Nullable Class\u003c?\u003e type);11 String[] getBeanNamesForType(G@Nullable Class\u003c?\u003e type, boolean includeNonSingletons, booleanallowEagerInit);1213 // 根据类型获取bean的一个map14 \u003cT\u003e Map\u003cString, T\u003e getBeansOfType(CNu]1able Class\u003cT\u003e type, boolean includeNonSingletons,boolean allowEagerInit)15 throws BeansException;1617 // 根据注解获得bean的名称18 String[] getBeanNamesForAnnotation(Class\u003c? extends Annotation\u003e annotationType);1920 // 根据注解获得bean21 Map\u003cString, Object\u003e getBeansWithAnnotation(Class\u003c? extends Annotation\u003e annotationType) throwsBeansException;2223 // 获取一个bean的注解24 \u003cA extends Annotation\u003e A findAnnotationOnBean(String beanName, Class\u003cA\u003e annotationType)25 throws NoSuchBeanDefinitionException;26",
  "assets/net-img-1679327961627-a3e82e4e-f33c-4221-aac4-b8ccebc6d9bc-20230321113610-naj3drf.png": "3、灵活的分层能力分层的能力十分重要，这在web工程至有典型应用，spring和springmvc会建立两个独立的上下文，后续涉及web工程时我们再深入讲解，分层之后各司其职，更易管理:public interface HierarchicalBeanFactory extends BeanFactory {123 // 返回bean工厂的父工厂4 @Nullable5 BeanFactory getParentBeanFactory();6// 此方法忽略祖先上下文定义的bean ，只会查询本地工厂boolean containsLocalBean(String name);oo910 }java可以写如下测试用例测试:1 public void testHierarchicalBeanFactory(){2 // 创建一个核心的工厂3 DefaultListableBeanFactory springFactory = new DefaultListableBeanFactory();4 springFactory. registerSingleton(\"user\",new User (\"#8 ii\", 31));5 // 创建一个web工厂，独自管理各个层级的内容6 DefaultListableBeanFactory webFactory = new DefaultListableBeanFactory();7 // 设置父子关联关系8 webFactory.setParentBeanFactory(springFactory);9 // 子工厂可以访问父工厂的bean10 System. out.printIn(webFactory. getBean(\"user\"));11)}",
  "assets/net-img-1679328045613-dd762572-c1ad-4fb8-8129-a181859a1b43-20230321113610-c6vl5ea.png": "4、构建和自动装配的能力T这个接口的实现及其复杂，主要是赋予子类自动装配的能力，是容器最核心的接口，这个接口定义了bean的创建以及装配能力，同时细粒度的控制了bean的生命周期:public interface AutowireCapableBeanFactory extends BeanFactory {123 // 不进行外部bean的自动装配的常量，BeanFactoryAware等和注释驱动的注入仍将被应用int AUTOWIRE_NO = 0;5 // 注入方式的常量，按类型或名称6 int AUTOWIRE_BY_NAME = 1;7 int AUTOWIRE_BY_TYPE = 2;8 int AUTOWIRE_CONSTRUCTOR = 3;910 hm11 // 用于创建实例的典型方法，12 ]/-------------------------------------------------------------------------13 \u003cT\u003e T createBean(Class\u003cT\u003e beanClass) throws BeansException;1415 // 自动装配的能力16 void autowireBean(Object existingBean) throws BeansException;718 // 对bean进行一些配置，如调用aware接口19 Object configureBean(Object existingBean, String beanName) throws BeansException;207a22 [faa a a a a23 // 用于对bean生命周期进行细粒度控制的专门方法24 // 主要是三块内容: 创建《实例化) ”属性填充《装配》 ”初始化25 12627 sa28 * 生命周期第一步《创建29 * 按照指定的装配策略根据c1ass生成一个完整的bean的实例30 * 执行bean的完全初始化，包括所有适用的BeanPostProcessors31 * @param dependencyCheck 是否对对象执行依赖项检查(不适用于自动装配构造函数，因此忽略)32 * @return 新的bean的实例33 bfError in boxClipToRectangle: box outside rectangleError in pixScanForForeground: invalid boxError in boxClipToRectangle: box outside rectangleError in pixScanForForeground: invalid box",
  "assets/net-img-1679328170233-4627a758-917a-4e27-a51b-0009926fe494-20230321113610-u9lft1u.png": "34353637383404142Object createBean(Class\u003c?\u003e beanClass, int autowireMode, boolean dependencyCheck) throwsBeansException;/*** 生命周期第二步〈装配)* 通过应用after-instantiation 和property post-processing (例如注释驱动的注入)* 来填充给定的bean详例。idObject autowire(Class\u003c?\u003e beanClass, int autowireMode, boolean dependencyCheck) throwsBeansException;",
  "assets/net-img-1679328203343-54bcc5a4-89ee-441e-bcad-25f2dccbcb56-20230321113610-138677m.png": "65/*** 通过指定的自动装配方式来对给定的Bean进行自动装配。void autowireBeanProperties (Object existingBean, int autowireMode, boolean dependencyCheck)throws BeansException;[ee* 将具体值的bean定义的属性值应用到给定的bean实例。* 是属性填充的重要步邓afvoid applyBeanPropertyValues (Object existingBean, String beanName) throws BeansException;* 初始化前的回调* 将BeanPostProcessors应用到给定的现有bean实例* 调用它们的postProcessBeforeInitialization方法ahObject applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)throws BeansException;pee* 初始化给定的原始bean ，应用工厂回调，如setBeanName和setBeanFactory，* 当然也包括应用所有的bean post processors",
  "assets/net-img-1679328223089-a3bf0e02-4324-4985-8b17-cab566580a39-20230321113610-8roq5mj.png": "Object initializeBlean(Object existingBean, String beanName) throws BeansException;/*** 初始化后的回调* 将BeanPostpProcessors应用到给定的现有bean实例* 调用它们的postProcessAfterInitialization方法es;Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throwsBeansException;/*** $5928 E Mbeanst tii* 使用Disposab1leBean接口定义的销毁方法afvoid destroyBean(Object existingBean) ;// 解决匹配注入点的方法// 在注入的时候通过以下的方法匹配属性与之对应的bean* 解析唯一匹配给定对象类型(如果有的话)的bean实例，包括它的bean名称。* 比如我们调用getBean(User.class) 会匹配一个或多个bean ，需要该方法进行选择* 这实际上是getBean(C1ass)的一个变体。\u003c\u003cT\u003e NamedBeanHolder\u003cT\u003e resolveNamedBean(Class\u003cT\u003e requiredType) throws BeansException;",
  "assets/net-img-1679328231757-6458ec6a-6676-4755-8257-f849cdfa0619-20230321113610-tw7blvg.png": "[ee* 解析给定bean名称的bean实例， 向目标工厂方法公开提供依赖描述符。* 这实际上是getBean(String，C1ass)的一个变体，sf)Object resolveBeanByName(String name, DependencyDescriptor descriptor) throws BeansException;/*** 针对此工厂中定义的bean解析指定的依赖项，注入的时候很有用。* 通过一个依赖的描述《对方法，字段，构造器的抽象) ，获得一个beanai@NullableObject resolveDependency(DependencyDescriptor descriptor, G@Nullable String requestingBeanName)throws BeansException;",
  "assets/net-img-1679328499262-a353f7ef-8aa8-4f98-9907-ed7f5670096c-20230321113610-xnsrjmu.png": "java接口中我们遇到如下的类，这里简单看看:NamedBeanHolder简单的包装了beanName和beanlnstance，我们通过【别名或者类型】查找bean时可以Ni反|BeifFi)1 public class NamedBeanHolder\u003cT\u003e implements NamedBean {23 private final String beanName;45 private final T beanInstance;6}",
  "assets/net-img-1679328512077-339dc971-4070-4524-9e3a-dbce38573cda-20230321113610-y272baz.png": "DependencyDescriptor是一个依赖措述符，这个类可以包装构造函数参数、方法参数或字段，人允许统一访问它们的元数据，这在入的时候很有用，比如给定一个【构造参数的描述】或【字段的描述】或【setter方法】，找到与之匹配的bean。1 public class DependencyDescriptor extends InjectionPoint implements Serializable {72 private final Class\u003c?\u003e declaringClass;3 @Nullableprivate String methodName;@Nul lableprivate Class\u003c?\u003e[] parameterTypes;private int parameterIndex;Lau 上上@Nullable9 private String fieldName;10 private final boolean required;11 private final boolean eager;12 private int nestingLevel = 1;13 @Nullable14 private Class\u003c?\u003e containingClass;15 G@Nul11able16 private transient volatile ResolvableType resolvableType;17 @Nullable18 private transient volatile TypeDescriptor typeDescriptor;",
  "assets/net-img-1679328551345-22b703eb-1bdc-459d-849a-0a0b56950b4b-20230321113611-ksb6jnt.png": "5、更强的配置能力这个bean工厂接口并不用于正常的应用程序代码中。这个扩展接口只是为了允许框架内部的即插即用和对bean工厂配置方法的特殊访问，具体如下:public interface ConfigurableBeanFactory extends HierarchicalBeanFactory, SingletonBeanRegistry {123 // 标准单例作用域的范围标识符:\"singleton\"。自定义作用域可以通过registerScope添加。4 String SCOPE_SINGLETON = “singleton”;5 String SCOPE_PROTOTYPE = “prototype”;6[**8 * 设置此bean工厂的父级。9 \u003c/10 void setParentBeanFactory(BeanFactory parentBeanFactory) throws I11egalStateException;1112 713 * 将class 1oader设置为加载中的bean类，默认是线程上下文类装入器。14 Lf15 void setBeanClassLoader(@Nullable ClassLoader beanClassLoader) ;1617 [fs18 * 返回这个工厂的的class 1oader，用于加载bean类19 */20 @Nullable21 ClassLoader getBeanClassLoader();2223 /**24 * 指定一个临时ClassLoader用于类型匹配，默认为none。25 * 如果涉及到加载时织入，则通常只指定临时ClassLoader ，以确保实际的bean类尽可能延迟地加载。26 * 一旦BeanFactory完成引导阶段，临时加载器就会被移除。27 2人28 void setTempClassLoader(G@Nu11ab1le ClassLoader tempClassLoader) ;2930 // 返回用于类型匹配的临时ClassLoader，31 ClassLoader getTempClassLoader();323334 (pes35 * 设置是天缓存bean元数据，例如给定的bean定义(以合并的方式)和resolved bean classese36 * 关闭此标志可启用bean Definition和特定bean类的热刷新。如果该标志关闭，则任何bean详例的创建都将重新查询bean class 1oader以获得新解析的类。w局四",
  "assets/net-img-1679328643343-fb2c7927-7d93-4506-b31e-d8a24a6fd9ef-20230321113611-fomgdvd.png": "53+Yhvoid setCacheBeanMetadata(boolean cacheBeanMetadata) ;boolean isCacheBeanMetadata() ;// 指定bean的表达式分析器void setBeanExpressionResolver(@Nullable BeanExpressionResolver resolver);BeanExpressionResolver getBeanExpressionResolver();// 设置和获取转化服务void setConversionService(@Nullable ConversionService conversionService);ConversionService getConversionService();// 添加属性编辑器void addPropertyEditorRegistrar(PropertyEditorRegistrar registrar);void registerCustomEditor(Class\u003c?\u003e requiredType, Class\u003c? extends PropertyEditor\u003epropertyEditorClass);void copyRegisteredEditorsTo(PropertyEditorRegistry registry);* 设置一个自定义类型转换器，这个BeanFactory应该使用它来转换bean属性值、构造函数参数值等。* 这将材盖默认的PropertyEditor机制，从而使任何自定义编辑器或自定义编辑器注册器变得无关紧要。TypeConverter getTypeConverter();/*** 为注入的值添加一个String解析器，如“aa${fbbjcc”。7,",
  "assets/net-img-1679328674692-d1fa56ab-9c6c-48c1-aaa8-0b3b08a9f852-20230321113611-ndberxv.png": "void addEmbeddedvalueResolver(SstringvalueResolver valueResolver);boolean hasEmbeddedValueResolver();String resolveEmbeddedvalue(String value);// 添加和获取bean的后置处理器void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) ;int getBeanPostProcessorCount();// 注册自定义的作用范围void registerScope(String scopeName, Scope scope);String[] getRegisteredScopeNames () ;Scope getRegisteredScope(String scopeName);//为这个bean工厂设置{ecode App1icationstartup},用来记录启动步骤void setApplicationStartup(ApplicationStartup applicationStartup) ;ApplicationStartup getApplicationStartup();// 从一个bean工厂拷贝配置void copyConfigurationFrom(ConfigurableBeanFactory otherFactory);",
  "assets/net-img-1679328727359-31a25960-9055-4a4f-8996-d4b833d03eb1-20230321113611-n4tc6kp.png": "// 注册别名void registerAlias(String beanName, String alias) throws BeanDefinitionStoreException;// 获得合并的bean的定义，后边细讲BeanDefinition getMergedBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;// @BELS beanboolean isFactoryBean(String name) throws NoSuchBeanDefinitionException;// 控制指定bean当前的创建状态。仅供容器内部使用。void setCurrentlyInCreation(String beanName, boolean inCreation);boolean isCurrentlyInCreation(String beanName) ;",
  "assets/net-img-1679328766699-5dd418d5-07a0-4ed7-93a6-4e45df9c2da7-20230321113611-fxqbzj1.png": "97 // 为给定的bean注册一个依赖bean，在给定的bean被销毁之前销毁它。98 void registerDependentBean(String beanName, String dependentBeanName) ;99100 // 如果有的话，返回依赖于指定bean的所有bean的名称。101 String[] getDependentBeans(String beanName) ;102103 // MORAN» iB GHEE bean fh tk HPT A beanfl 3 fr -104 String[] getDependenciesForBean(String beanName) ;105106 // 根据bean名称销毁给定的bean详例(通常是从该工厂获得的原型实例) 。107 void destroyBean(String beanName, Object beanInstance);108109 // 销毁指定的【作用域bean]110 void destroyScopedBean(String beanName) ;111112 // 销毁此工厂中的所有单例bean，包括已注册为一次性的内部bean 。在工厂关闭时被召回。113 void destroySingletons();114 3}",
  "assets/net-img-1679328958262-231bb1aa-98f8-4a29-975d-551382a1df4b-20230321113611-bw12t3c.png": "6、更多配置项AbstractAutowi reCapableBeanFactory 为子类提供了更多的配秆项如下;12ms456public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactoryimplements AutowireCapableBeanFactory {// 详例化策略，默认使用Cg1ibsubclassingInstantiationstrategyprivate InstantiationStrategy instantiationStrategy;// 方法参数名解析策略@Nullableprivate ParameterNameDiscoverer parameterNameDiscoverer = newDefaultParameterNameDiscoverer();// 是理允许循环引用《会详细介绍)private boolean allowCircularReferences = true;// 是理在循环引用的情况下注入一个原始bean实例，即使注入的bean最终被包装类。private boolean allowRawInjectionDespiteWrapping = false;// 要在依赖项检查和自动装配时忽略的依赖项类型，如类对象的集合: 例如，字符串。默认值为none。private final Set\u003cClass\u003c?\u003e\u003e ignoredDependencyTypes = new HashSet\u003c\u003e();// 在依赖项检查和自动装配时忽略的依赖项接口，如类对象集。缺省情况下，只有BeanFactory接口被忽略。private final Set\u003cClass\u003c?\u003e\u003e ignoredDependencyInterfaces = new HashSet\u003c\u003e();// 当前创建的bean的名称，保存在ThreadLocal中。private final NamedThreadLocal\u003cString\u003e currentlyCreatedBean = new NamedThreadLocal\u003c\u003eC\"Currently created bean\");",
  "assets/net-img-1679328973012-18509de0-68c2-40da-bb37-93ed27e8f9f4-20230321113611-24b7sp9.png": "// 未完成的FactoryBean实例的缓存private final ConcurrentMap\u003cString, BeanWrapper\u003e factoryBeanInstanceCache = newConcurrentHashMap\u003c\u003e();// 每个工厂类的候选工厂方法缓存private final ConcurrentMap\u003cClass\u003c?\u003e, Method[]\u003e factoryMethodCandidateCache = newConcurrentHashMap\u003c\u003e();// 过滤后的PropertyDescriptors缓存:bean类到PropertyDescriptor数组。private final ConcurrentMap\u003cClass\u003c?\u003e, PropertyDescriptor[]\u003e filteredPropertyDescriptorsCachenew ConcurrentHashMap\u003c\u003e();",
  "assets/net-img-1679329156187-03d00e07-f3ed-4c15-8451-3e2b08f66cb9-20230321113611-zqd3qhd.png": "wipublic AbstractautowireCdpableBeanFactory() {superQ;ignoreDependencyInterface(BeanNameAware. class);ignoreDependencyInterface(BeanFactoryAware. class);ignoreDependencyInterface(BeanClassLoaderAware. class);this.instantiationStrategy = new CglibSubclassingInstantiationStrategy();public AbstractAutowireCapableBeanFactory(@Nullable BeanFactory parentBeanFactory)thisO;setParentBeanFactory(parentBeanFactory) ;// 设置初始化策略，这里用到了策略设计模式public void setInstantiationStrategy(InstantiationStrategy instantiationStrategy) {this.instantiationStrategy = instantiationStrategy;}public InstantiationStrategy getInstantiationStrategy() {return this. instantiationStrategy;",
  "assets/net-img-1679329182311-14de9e9b-a0f9-4e5e-9d93-9564cab2d519-20230321113612-rbkv8ax.png": "60616263// 设置参数名称解析器public void setParameterNameDiscoverer(@Nullable ParameterNameDiscovererparameterNameDiscoverer) {this.parameterNameDiscoverer = parameterNameDiscoverer;}public ParameterNameDiscoverer getParameterNameDiscoverer() {return this.parameterNameDiscoverer;}// 后边会详细讲解// 设置是否允许bean之间的循环引用-并自动尝试解析它们。// 默认为\"true”。springboot中默认是false。// 注意:通常建议不要依赖bean之间的循环引用。// 重构您的应用程序逻辑，使涉及的两个bean委托给封装它们的公共逻辑的第三个bean 。",
  "assets/net-img-1679329189732-54e623a7-6209-445a-a764-84aada9c1453-20230321113612-suq0501.png": "理) 。public void setA11owCircularReferences (boolean allowCircularReferences) {this.allowCircularReferences = allowCircularReferences;public boolean isAllowCircularReferences() {return this.allowCircularReferences;[*** 设置是否允许将一个bean的原始实例注入到其他bean的属性中尽管注入的bean最终会被包装(例如，通过AOP自动代*这只会在循环引用无法通过其他方式解决的情况下作为最后的手段使用:从本质上讲，宁愿注入一个原始实例，也不愿整个bean装配过程失败。* 从Spring 2.0开始，默认为“false\"”。*/public void setAllowRawInjectionDespiteWrapping(boolean allowRawInjectionDespiteWrapping) {this.allowRawInjectionDespitewrapping = allowRawInjectionDespiteWrapping;办}public boolean isAllowRawInjectionDespitewrapping() {return this.allowRawInjectionDespitewrapping;[*** 忽略自动装配的给定依赖类型:* 例如，string。默认值为none。public void ignoreDependencyType(Class\u003c?\u003e type) {this. ignoredDependencyTypes . add(type) ;} I// 忽略自动装配的给定依赖接口。public void ignoreDependencyInterface(Class\u003c?\u003e ifc) {this. ignoredDependencyInterfaces.add(ifc);",
  "assets/net-img-1679329251067-3ac227e6-4649-4d19-ac0c-7de41f87110d-20230321113612-t1gykwu.png": "如下的测试用例中我们使用spring的简单实例化策略和BeanWrapper工具，实现了bean的实例化和属性填充:- -123456@Testpublic void testInstantiation() throws ClassNotFoundException {}// 编写bean的定义RootBeanDefinition beanDefinition = new RootBeanDefinition();beanDefinition.setBeanClassName(\"com.ydiclass.User\");MutablePropertyValues propertyValues = new MutablePropertyValues();propertyValues.addPropertyValue(\"name\",\"itta# ii\") ;propertyValues.addPropertyValue(\"age\", 32);beanDefinition. setPropertyValues (propertyValues) ;beanDefinition. resolveBeanC lass (Thread. currentThread() . getContextClassLoader());// 我们模仿一个beanDefinition如何变成一个beanDefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();beanFactory. registerBeanDefinition(\"user\" ,beanDefinition) ;// 实例化SimpleInstantiationStrategy instantiationStrategy = new SimpleInstantiationStrategy();Object user = instantiationStrategy. instanti 全nition, “user\", beanFactory);// 属性填充BeanWrapper wrapper = new BeanWrapperimp] (user);wrapper. setPropertyValues (beanDefinition. getPropertyValues());logger. info(\"The user is [{}]\",user);这个小例子“定要好好看-看，对后续的内容很有帮助。我们可以阅读一下简单的实例化策略:wnionan@Overridepublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {//在将XML 配置解析成BeanDefinition 的时候，bean标签的1ookup-method和rep1aced-method会被分别解析成LookupOverride 和ReplaceOverride 对象，添加到BeanDefinition 的methodoverrides成员变量中。它们的作用是通过配置来材盖Bean 原有的方法实现。这个我们一会看。计〈!bd.hasMethodoverrides(O) {Constructor\u003c?\u003e constructorTouse;synchronized (bd.constructorArgumentLock) {constructorToUse = (Constructor\u003c?\u003e) bd.resolvedConstructorOrFactoryMethod;if (constructorToUse == null) {final Class\u003c?\u003e clazz = bd.getBeanClass();if (clazz.isInterfaceQ)) {",
  "assets/net-img-1679329288336-e808908d-fb81-4d0b-9b3e-16d2ba69e0a8-20230321113612-4zqrcb7.png": "16 了17 catch (Throwable ex) {18 throw new BeanInstantiationException(clazz, \"No default constructor found\",ex);19 320 了eat 322 // 直接使用原生的反射生成实例23 return BeanUtils. instantiateClass (constructorTouse) ;24 }25 else {26 // 有需要重写的方法，我们则生成一个cg91ib的子类27 return instantiatewithMethodInjection(bd, beanName, owner);28 3",
  "assets/net-img-1679329330548-41c65493-3279-49da-b996-afc2c4ac305e-20230321113612-rp8iknv.png": "1、lookup-method注入lookup-method注入是spring动态改变bean下面的例子，告诉我们这个方法怎么使用:回法的实现。指定方法的返回人为某个已经存在的bean。1 public abstract class CommandManager {23 public Object process(Object commandstate) {4 // grab a new instance of the appropriate Command interface5 Command command = createCommand();6 // set the state on the (hopefully brand new) Command instance7 command. setState(commandstate) ;8 return command. execute() ;S }1011 // okay... but where is the implementation of this method?12 protected abstract Command createCommand();13/} if配置如下:1 \u003cbean id=\"manager\"class=\"com.Xxxx.1ookupmethod.CommandManager \"\u003e2 // createCommand方法将返回commad这个bean3 \u003clookup-method bean=\"command\" name=\"createCommand\"/\u003e4 \u003c/bean\u003e5 \u003cbean id=\"command\" class=\"com. xxx. lookupmethod.MyCommand\"\u003e6 \u003c/bean\u003e",
  "assets/net-img-1679329349817-db5d1bb5-a0cc-4756-8492-9b1b8248020d-20230321113612-baea9vf.png": "2、replaced-method注入replaced-method注入是spring动态改变bean方法的一种实现。他可以改变的方法执行丈辑，将方法进行车换，定义蔡换方法的类(需要继承接口org.springframework.beans.factory.support.MethodReplacer) 接口。1 public class MyValueCalculator {2 public String computeValue(String input) {3 // some real code...4 +5; // some other methods...6 389 * meant to be used to override the existing computeValue(String)10 * implementation in MyvqlueCalculator11| #/12 public class ReplacementComputeValue implements MethodReplacer {1314 public Object reimplement(Object o. Method m, Object[] args) throws Throwable {15 // get the input value. work with it. and return a computed result16 String input = (String) args[0]:17 sae18 return ...;rk) }",
  "assets/net-img-1679329358838-1a0a8fbf-220c-4304-a481-3113bb34f275-20230321113612-rro44w5.png": "配置:1 \u003cbean id=\"myValueCalculator\" class=\"x.y.z.MyValueCalculator\"\u003e2 \u003c!-- arbitrary method replacement --\u003e3} \u003creplaced-method name=\"computeValue\" replacer=\"replacementComputeValue\"\u003e4 \u003carg-type\u003eString\u003c/arg-type\u003e5 \u003c/replaced-method\u003e6 \u003c/bean\u003e8 \u003cbean id=\"replacementComputeValue\" class=\"a.b.c.ReplacementComputeValue\"/\u003e: 从源码中得知，基于以上两种方式注入后，bean需要使用cglib生成子类完成目标，由于采icglib4成之类的方式，所以需要用来动态注入的类，不能是final修饰的，需要动态注入的方法，也不能是final修饰的。",
  "assets/net-img-1679329371744-78e87e42-a60b-45c5-a7bf-35f2fcb66226-20230321113612-tc974ij.png": "7、工厂的生命周期bean工厂的生命周划比较简单: start-\u003eonRefresh-\u003eRunning-\u003eonClose-\u003estop每一个生命周期节点都会完成大量的工作，我们后边的内容会详细介绍:public interface nage123 void startQ;45 void stop();67 boolean isRunning();8 }91011 public interface LifecycleProcessor extends Lifecycle {13 /**14 * 上下文刷新通知，例如自动启动组件。1516 void onRefresh();7",
  "assets/net-img-1679329387840-7662a31f-7f82-4ef6-b099-5d44bf0d034b-20230321113612-4fts8yh.png": "上下文关闭阶段的通知，例如自动停止组件。/void onClose();"
}