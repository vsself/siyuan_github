{
	"ID": "20230402222917-ec82plo",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230402222917-ec82plo",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20230402222917-rhu809s\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230402222917-qzo78cw\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230402222917-rhu809s\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0}",
		"title": "spring源码系列（七）——beanDefinition（3）_shadow?s的博客-CSDN博客",
		"updated": "20230402222917"
	},
	"Children": [
		{
			"ID": "20230402222917-rhu809s",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230402222917-rhu809s",
				"updated": "20230402222917"
			}
		},
		{
			"ID": "20230402222917-i9mt1um",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230402222917-i9mt1um",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"ID": "20230402222917-nbyuptz",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230402222917-nbyuptz",
						"updated": "20230402222917"
					},
					"Children": [
						{
							"ID": "20230402222917-kixn7pd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230402222917-kixn7pd",
								"updated": "20230402222917"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://blog.csdn.net/java_lyvee/article/details/115185345?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168044143016800211538380%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D\u0026request_id=168044143016800211538380\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-7-115185345-null-null.blog_rank_default\u0026utm_term=spring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97\u0026spm=1018.2226.3001.4450",
									"TextMarkTextContent": "https://blog.csdn.net/java_lyvee/article/details/115185345?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168044143016800211538380%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D\u0026amp;request_id=168044143016800211538380\u0026amp;biz_id=0\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a sub",
									"TextMarkAHref": "https://blog.csdn.net/java_lyvee/article/details/115185345?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168044143016800211538380%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D\u0026request_id=168044143016800211538380\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-7-115185345-null-null.blog_rank_default\u0026utm_term=spring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97\u0026spm=1018.2226.3001.4450",
									"TextMarkTextContent": "blog"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://blog.csdn.net/java_lyvee/article/details/115185345?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168044143016800211538380%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D\u0026request_id=168044143016800211538380\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-7-115185345-null-null.blog_rank_default\u0026utm_term=spring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97\u0026spm=1018.2226.3001.4450",
									"TextMarkTextContent": "first_rank_ecpm_v1~rank_v31_ecpm-7-115185345-null-null.blog_rank_default\u0026amp;utm_term=spring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97\u0026amp;spm=1018.2226.3001.4450"
								}
							]
						}
					]
				},
				{
					"ID": "20230402222917-2vjl7jd",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230402222917-2vjl7jd",
						"updated": "20230402222917"
					},
					"Children": [
						{
							"ID": "20230402222917-l4gvnzj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230402222917-l4gvnzj",
								"updated": "20230402222917"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "首先声明文章末尾有恰饭的内容——哈哈这篇文章的视频讲解又B站链接，点击即可https://www.bilibili.com/video/BV1rA411N7NL?from=search\u0026seid=6089645575499504886继续讨论BeanFactoryPostProcessorbeanFactoryPostProcessor有什么作用顾名思义beanFactoryPostProcessor=bean工厂的后置处理器，主要是提供给程序员扩展的（当然了spring内部也对这个接口进"
								}
							]
						}
					]
				},
				{
					"ID": "20230402222917-aeykk6d",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230402222917-aeykk6d",
						"updated": "20230402222917"
					},
					"Children": [
						{
							"ID": "20230402222917-osifnbu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230402222917-osifnbu",
								"updated": "20230402222917"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2023-04-02 22:29:17"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230402222917-1uea223",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230402222917-1uea223",
				"updated": "20230402222917"
			}
		},
		{
			"ID": "20230402222917-a19w2oe",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230402222917-a19w2oe",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "继续讨论BeanFactoryPostProcesso"
				}
			]
		},
		{
			"ID": "20230402222917-ux8aw64",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230402222917-ux8aw64",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "beanFactoryPostProcessor有什么作用"
				}
			]
		},
		{
			"ID": "20230402222917-9herxo2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-9herxo2",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "顾名思义beanFactoryPostProcessor=bean工厂的后置处理器，主要是提供给程序员扩展的（当然了spring内部也对这个接口进行了各种实现，本文只讨论程序员如何扩展它）；在spring容器运行期间可以让程序员对BeanFactory组件进行各种全局的设置，这便是这个处理器的作用；关于什么是beanFactory——中文翻译过来叫做bean工厂，其实也就是我们常常说的spring容器；这个处理器主要就是针对spring容器做一些配置；那么他能进行哪些配置呢？先看一下这个接口的定义和他的主要方法"
				}
			]
		},
		{
			"ID": "20230402222917-7onsmv6",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230402222917-7onsmv6",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public interface BeanFactoryPostProcessor {\n\n\tvoid postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;\n\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230402222917-bvdmxcj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-bvdmxcj",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其实这个接口（不考虑子类）他只有一个方法；也就是当程序员实现这个接口后，重写这个方法后，spring容器会在启动的时候调用你重写的这个方法，并且把"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ConfigurableListableBeanFactory"
				},
				{
					"Type": "NodeText",
					"Data": "​类的对象传给你；实际运行过程中传入的是个子类——"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "DefaultListableBeanFactory"
				},
				{
					"Type": "NodeText",
					"Data": "​，当我们得到这beanFactory之后就能对这对象进行设置了，那么回到刚刚的问题，主要能进行哪些设置呢？这就要看"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "DefaultListableBeanFactory"
				},
				{
					"Type": "NodeText",
					"Data": "​当中主要提供哪些API供我们调用了；他的api比较多，笔者并没有打算在一篇文章当中写完；会逐个分析他的一些重要的api"
				}
			]
		},
		{
			"ID": "20230402222917-0dus77n",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230402222917-0dus77n",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "ignoreDependencyType"
				}
			]
		},
		{
			"ID": "20230402222917-1y50lam",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-1y50lam",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ignoreDependencyType"
				},
				{
					"Type": "NodeText",
					"Data": "​——忽略依赖注入的某个类型，存在父类当中"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ConfigurableListableBeanFactory"
				},
				{
					"Type": "NodeText",
					"Data": "​\n先看一下这方法发的定义和javadoc"
				}
			]
		},
		{
			"ID": "20230402222917-x8axj3q",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230402222917-x8axj3q",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "   /**\n\t * Ignore the given dependency type for autowiring:\n\t * for example, String. Default is none.\n\t * @param type the dependency type to ignore\n\t */\n\tvoid ignoreDependencyType(Class\u003c?\u003e type);\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230402222917-1ywmeey",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-1ywmeey",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个方法只有参数class类型的，比如你调用这个方法传入了一个"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "B.class"
				},
				{
					"Type": "NodeText",
					"Data": "​则表示整个spring容器当中当遇到需要"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "自动注入"
				},
				{
					"Type": "NodeText",
					"Data": "B的时候会被忽略,你注意看他的javadoc的说明，特别强调是自动注入的时候；接下来对这个方法来代码测试；"
				}
			]
		},
		{
			"ID": "20230402222917-nw8wqy1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-nw8wqy1",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "有类A和 类B 代码如下："
				}
			]
		},
		{
			"ID": "20230402222917-84q8a3r",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230402222917-84q8a3r",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "package com.spring.extension.beanFactoryPostProcessor.bean;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author 钢牌讲师-子路\n * @date 2021/3/2218:41\n */\n@Slf4j(topic = \"e\")\npublic class A {\n  B b;\n  public void setB(B b) {\n    this.b = b;\n  }\n  \n  public void printInfo(){\n    log.debug(\"bean-b:{}\",b);\n  }\n  \n}\n\n--------------------------------------------------------------------------------------\n\n\n\npackage com.spring.extension.beanFactoryPostProcessor.bean;\n\nimport org.springframework.stereotype.Component;\npublic class B {\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230402222917-oln5rcv",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230402222917-oln5rcv",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230402222917-8p7e4bv",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230402222917-8p7e4bv",
						"updated": "20230402222917"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "在一个A类当中由一个属性B，并且提供了setter方法，当中有一个"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "printInfo"
						},
						{
							"Type": "NodeText",
							"Data": "​方法主要来打印b是否有值"
						}
					]
				}
			]
		},
		{
			"ID": "20230402222917-utbyljs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-utbyljs",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "测试类代码如下："
				}
			]
		},
		{
			"ID": "20230402222917-sodanwe",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230402222917-sodanwe",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Slf4j(topic = \"e\")\npublic class TestBeanFactoryPostProcessor {\n\n\tpublic static void main(String[] args) {\n\t\n\t\tAnnotationConfigApplicationContext applicationContext =\n\t\t\t\tnew AnnotationConfigApplicationContext();\n\t\tClass[] clazz = new Class[]{A.class,B.class};\n\t\tapplicationContext.register(clazz);\n\t\tapplicationContext.refresh();\n\t\tapplicationContext.getBean(A.class).printInfo();\n\t}\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230402222917-m1ui310",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230402222917-m1ui310",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230402222917-p7chyrz",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230402222917-p7chyrz",
						"updated": "20230402222917"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "这里需要说明的是，我是把A.class和B.class直接注册给了spring容器\n而没有采用平常那种通过配置类扫描的方式来启动spring容器\n这么做的主要原因是因为我机器上的bean太多了，如果采用扫描可能会影响结果\n通过这种手动注册方式，可以很方便的控制我的环境，和扫描没有区别"
						}
					]
				}
			]
		},
		{
			"ID": "20230402222917-0tdmx5j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-0tdmx5j",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上面的代码比较简单，就是相当于spring容器当中扫描到了A和B两个类，然后调用A的printinfo方法打印看看b是否有值；讲道理这个时候b肯定等于null，因为虽然A当中由b属性，但是并没有通过任何手段去注入B，故而他肯定为null；"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "运行过程和结果："
				},
				{
					"Type": "NodeText",
					"Data": "\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/20210324201215778-20230402222916-76us5cz.gif"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n接下来给属性b加上"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "@Autowired"
				},
				{
					"Type": "NodeText",
					"Data": "​注解再次允许b肯定不为null这个过于简单笔者变不截图做解释了；"
				}
			]
		},
		{
			"ID": "20230402222917-jme16fr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-jme16fr",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "跟着来测试"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ignoreDependencyType"
				},
				{
					"Type": "NodeText",
					"Data": "​这个api，新建一个类"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "TestIgnoreDependencyType"
				},
				{
					"Type": "NodeText",
					"Data": "​让他实现"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "BeanFactoryPostProcessor"
				},
				{
					"Type": "NodeText",
					"Data": "​这个接口,然后在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "postProcessBeanFactory"
				},
				{
					"Type": "NodeText",
					"Data": "​方法里面调用"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ignoreDependencyType"
				},
				{
					"Type": "NodeText",
					"Data": "​设置B.class，让所有bean在注入B类型的bean的时候忽略；"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "代码如下："
				}
			]
		},
		{
			"ID": "20230402222917-93xjif7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230402222917-93xjif7",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\n/**\n * @author 钢牌讲师-子路\n * @date 2021/3/2218:39\n * 主要来测试ignoreDependencyType 这个API\n */\n@Slf4j(topic = \"e\")\npublic class TestIgnoreDependencyType implements BeanFactoryPostProcessor {\n\t@Override\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tlog.debug(\"TestIgnoreDependencyType--execute  测试这个方法是否被执行了\");\n\t\t//设置所有自动注入的属性如果类型为B则忽略\n\t\tbeanFactory.ignoreDependencyType(B.class);\n\t}\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230402222917-tcww8q9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-tcww8q9",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "跟着修改测试类，把TestIgnoreDependencyType这个类也加入到容器当中，因为如果你把这个类加入到容器则spring无法发现这个类（再次强调，为了保持环境的干净我没有用扫描，而是用到那个类就手动注册哪个类），"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "修改后的测试类："
				}
			]
		},
		{
			"ID": "20230402222917-n6cpoqq",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230402222917-n6cpoqq",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Slf4j(topic = \"e\")\npublic class TestBeanFactoryPostProcessor {\n\n\tpublic static void main(String[] args) {\n\n\t\tAnnotationConfigApplicationContext applicationContext =\n\t\t\t\tnew AnnotationConfigApplicationContext();\n\t\t\t\n\t\t//多添加了一个类给spring容器\n\t\tClass[] clazz = new Class[]{A.class,B.class,TestIgnoreDependencyType.class};\n\t\n\t\tapplicationContext.register(clazz);\n\t\tapplicationContext.refresh();\n\n\t\tapplicationContext.getBean(A.class).printInfo();\n\n\n\t}\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230402222917-geb4ivf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-geb4ivf",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后允许测试类，讲道理这个时候b要为null才符合spring提供这个方法的意义（忽略B类型的注入）；\n但是结果还是b不等于null；"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "运行结果如下图："
				}
			]
		},
		{
			"ID": "20230402222917-st7w54b",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-st7w54b",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/20210324203827626-20230402222916-wm7ww3o.gif"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230402222917-t1aj7wn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-t1aj7wn",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为什么b还是不为null呢？原因有两\n​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "原因1"
				},
				{
					"Type": "NodeText",
					"Data": "​、因为"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ignoreDependencyType"
				},
				{
					"Type": "NodeText",
					"Data": "​这个api上的javadoc有明确说明需要上自动注入的情况下才会生效，可能有人会说难道这里的b不是自动注入？确实不是这个我在前面那个毁三观的自动注入博文里面有解释，下面还有评论说@Autowired是自动注入；其实这里就更加能证明@Autowired不是自动注入，最多算半自动注入，所以导致了"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ignoreDependencyType"
				},
				{
					"Type": "NodeText",
					"Data": "​这个方法没有生效\n我们先解决第一个问题，把A的自动注入模型改成自动注入；怎么改呢？其实这也是我们得到"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "beanFactory"
				},
				{
					"Type": "NodeText",
					"Data": "​这个对象之后能够做的事情之一——修改"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "beanDefinition"
				},
				{
					"Type": "NodeText",
					"Data": "​(前面我们提到，所谓的bean工厂处理器，到底能处理什么，修改一个beanDefintion其实也算我们做的处理之一)；故而修改"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "TestIgnoreDependencyType"
				},
				{
					"Type": "NodeText",
					"Data": "​的代码如下"
				}
			]
		},
		{
			"ID": "20230402222917-bhgnxnc",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230402222917-bhgnxnc",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/**\n * @author 钢牌讲师-子路\n * @date 2021/3/2218:39\n * 主要来测试ignoreDependencyType 这个API\n */\n@Slf4j(topic = \"e\")\npublic class TestIgnoreDependencyType implements BeanFactoryPostProcessor {\n\t@Override\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tlog.debug(\"TestIgnoreDependencyType--execute  测试这个方法是否被执行了\");\n\n\t\t//获取A的BeanDefinition\n\t\tAnnotatedGenericBeanDefinition a =\n\t\t\t\t(AnnotatedGenericBeanDefinition) beanFactory.getBeanDefinition(\"a\");\n\t\n\t\t//修改A这个bean的注入模型为自动注入bytype\n\t\ta.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);\n\n\n\t\t//设置所有自动注入的属性如果类型为B则忽略\n\t\tbeanFactory.ignoreDependencyType(B.class);\n\t}\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230402222917-716vdbx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-716vdbx",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后再次运行，但是结果依然b不等于null，因为我们前面说过原因有两，目前我们只是解决了第一个原因，所以结果还是不等于null，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "结果如下图:"
				},
				{
					"Type": "NodeText",
					"Data": "\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/20210324205129590-20230402222916-itnijdj.gif"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230402222917-ovvjk9l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-ovvjk9l",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "原因2、"
				},
				{
					"Type": "NodeText",
					"Data": " A的模型虽然被改成了自动注入模型，但是b属性的注入模式还是手动注入，也就是属性看有单独体现注入模型，那么类的注入模型对这个被单独指定过注入模型的属性已经无效了，但是对其他没有被指定注入模型的属性还是生效的，比如A里面还有个属性x，而这个x，没有指定注入模型，则会沿用类的注入模型；所以得把b上面的注解去掉，那么就能生效了，这个时候b就等于null了；\n"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "运行结果如下图："
				}
			]
		},
		{
			"ID": "20230402222917-6rqm3ab",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-6rqm3ab",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/20210324205927538-20230402222917-20rdbhd.gif"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230402222917-ueat54o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-ueat54o",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "到这里我们已经看到了这个方法的作用了——为容器当中所有自动注入的bean忽略给定的类型依赖项；\n当然有的人可能会认为b等于null可能不是因为"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "beanFactory.ignoreDependencyType(B.class);"
				},
				{
					"Type": "NodeText",
					"Data": "​引起的；所以笔者还是不怕麻烦的再次证明一下，把这行代码删了再来看结果那么b肯定不等于null了（因为A的自动注入模型是自动注入，而你又提供了setter方法，故而b肯定能被注入进来）；"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "结果如下图："
				},
				{
					"Type": "NodeText",
					"Data": "\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/20210324211453685-20230402222915-ep2vf87.gif"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230402222917-s1kehlf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-s1kehlf",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "好了到现在我们已经把ignoreDependencyType这个api彻底搞懂了；过几天更新其他api；接下来传销一波：传销之前先说一下笔者再写这篇博客的时候看到了一件非常欣慰的事情，是笔者自己的群里的网友聊天"
				}
			]
		},
		{
			"ID": "20230402222917-jyrlj1l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-jyrlj1l",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/20210324212237591-20230402222916-mg3ffw9.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230402222917-fxwe6vb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-fxwe6vb",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/20210324212324405-20230402222916-yiq5kv6.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230402222917-qzo78cw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230402222917-qzo78cw",
				"updated": "20230402222917"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "非常感谢这位CSDN的博主对笔者的肯定，其实我以前讲的spring"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://so.csdn.net/so/search?q=%E6%BA%90%E7%A0%81\u0026spm=1001.2101.3001.7020",
					"TextMarkTextContent": "源码"
				},
				{
					"Type": "NodeText",
					"Data": "并没有达到自己的期望，因为以前在公司里面讲课又各种限制；所以一直没有讲好，甚至很多东西都一带而过；"
				}
			]
		}
	]
}