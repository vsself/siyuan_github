{
	"ID": "20230331084824-oy0l1zu",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230331084824-oy0l1zu",
		"title": "Spring源码分析衍生篇五：AutowiredAnnotationBeanPostProcessor_postprocessor inject_猫吻鱼的博客-CSDN博客",
		"updated": "20230331084824"
	},
	"Children": [
		{
			"ID": "20230331084824-nvleniu",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331084824-nvleniu",
				"updated": "20230331084824"
			}
		},
		{
			"ID": "20230331084824-iom3xr4",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230331084824-iom3xr4",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"ID": "20230331084824-nj6h5ve",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331084824-nj6h5ve",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-j9krlh5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-j9krlh5",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/106411232",
									"TextMarkTextContent": "https://blog.csdn.net/qq_36882793/article/details/106411232"
								}
							]
						}
					]
				},
				{
					"ID": "20230331084824-1elced8",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331084824-1elced8",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-gn7cnlm",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-gn7cnlm",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "文章目录一、前言二、AutowiredAnnotationBeanPostProcessor三、determineCandidateConstructors四、postProcessProperties \u0026 postProcessPropertyValues1. findAutowiringMetadata一、前言本文是 Spring源码分析：单例bean的获取 - createBean  的衍生文章。主要是因为本人菜鸡，在分析源码的过程中还有一些其他的内容不理解，故开设衍生篇来完善内容以学习。"
								}
							]
						}
					]
				},
				{
					"ID": "20230331084824-lswipsm",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331084824-lswipsm",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-fxblnu8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-fxblnu8",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2023-03-31 08:48:24"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230331084824-cc8fdjs",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331084824-cc8fdjs",
				"updated": "20230331084824"
			}
		},
		{
			"ID": "20230331084824-bcso3qz",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230331084824-bcso3qz",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "文章目录"
				}
			]
		},
		{
			"ID": "20230331084824-ies1qr8",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230331084824-ies1qr8",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"ID": "20230331084824-x7hxkdr",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331084824-x7hxkdr",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-sdjwq8p",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-sdjwq8p",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/106411232#_1",
									"TextMarkTextContent": "一、前言"
								}
							]
						}
					]
				},
				{
					"ID": "20230331084824-gkn93gc",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331084824-gkn93gc",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-jc9gnf7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-jc9gnf7",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/106411232#AutowiredAnnotationBeanPostProcessor_8",
									"TextMarkTextContent": "二、AutowiredAnnotationBeanPostProcessor"
								}
							]
						}
					]
				},
				{
					"ID": "20230331084824-yiv5u1c",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331084824-yiv5u1c",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-r5ywe07",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-r5ywe07",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/106411232#determineCandidateConstructors_43",
									"TextMarkTextContent": "三、determineCandidateConstructors"
								}
							]
						}
					]
				},
				{
					"ID": "20230331084824-j1349me",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331084824-j1349me",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-mgp8u2c",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-mgp8u2c",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/106411232#postProcessProperties__postProcessPropertyValues_228",
									"TextMarkTextContent": "四、postProcessProperties \u0026amp; postProcessPropertyValues"
								}
							]
						}
					]
				},
				{
					"ID": "20230331084824-fg3glzx",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331084824-fg3glzx",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-pztwwoi",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20230331084824-pztwwoi",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"ID": "20230331084824-wmujn1q",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230331084824-wmujn1q",
										"updated": "20230331084824"
									},
									"Children": [
										{
											"ID": "20230331084824-squn3th",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230331084824-squn3th",
												"updated": "20230331084824"
											},
											"Children": [
												{
													"Type": "NodeTextMark",
													"TextMarkType": "a",
													"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/106411232#1_findAutowiringMetadata_263",
													"TextMarkTextContent": "1. findAutowiringMetadata"
												}
											]
										}
									]
								},
								{
									"ID": "20230331084824-vgmbgar",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230331084824-vgmbgar",
										"updated": "20230331084824"
									},
									"Children": [
										{
											"ID": "20230331084824-h3zd6ti",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230331084824-h3zd6ti",
												"updated": "20230331084824"
											},
											"Children": [
												{
													"Type": "NodeTextMark",
													"TextMarkType": "a",
													"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/106411232#2_InjectionMetadatainject_357",
													"TextMarkTextContent": "2. InjectionMetadata#inject"
												}
											]
										}
									]
								},
								{
									"ID": "20230331084824-r6tk8gv",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230331084824-r6tk8gv",
										"updated": "20230331084824"
									},
									"Children": [
										{
											"ID": "20230331084824-ayug8ib",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230331084824-ayug8ib",
												"updated": "20230331084824"
											},
											"Children": [
												{
													"Type": "NodeTextMark",
													"TextMarkType": "a",
													"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/106411232#3_AutowiredAnnotationBeanPostProcessorAutowiredFieldElementinject_404",
													"TextMarkTextContent": "3. AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject"
												}
											]
										}
									]
								},
								{
									"ID": "20230331084824-enhjbpp",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230331084824-enhjbpp",
										"updated": "20230331084824"
									},
									"Children": [
										{
											"ID": "20230331084824-w505xcp",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230331084824-w505xcp",
												"updated": "20230331084824"
											},
											"Children": [
												{
													"Type": "NodeTextMark",
													"TextMarkType": "a",
													"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/106411232#4_AutowiredAnnotationBeanPostProcessorAutowiredMethodElementinject_466",
													"TextMarkTextContent": "4. AutowiredAnnotationBeanPostProcessor.AutowiredMethodElement#inject"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20230331084824-3j7t4n8",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331084824-3j7t4n8",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-60jvhat",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-60jvhat",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/106411232#postProcessMergedBeanDefinition_531",
									"TextMarkTextContent": "五、postProcessMergedBeanDefinition"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230331084824-v92737s",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331084824-v92737s",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一、前言"
				}
			]
		},
		{
			"ID": "20230331084824-am6y9o0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-am6y9o0",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "本文是 Spring源码分析："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/106299180",
					"TextMarkTextContent": "Spring源码分析四：bean的属性注入 - populateBean"
				},
				{
					"Type": "NodeText",
					"Data": " 的衍生文章。主要是因为本人菜鸡，在分析源码的过程中还有一些其他的内容不理解，故开设衍生篇来完善内容以学习。"
				}
			]
		},
		{
			"ID": "20230331084824-o5eh4fc",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331084824-o5eh4fc",
				"updated": "20230331084824"
			}
		},
		{
			"ID": "20230331084824-7f308t0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-7f308t0",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/106040809",
					"TextMarkTextContent": "Spring源码分析衍生篇四：后处理器 BeanPostProcessor"
				},
				{
					"Type": "NodeText",
					"Data": " 中我们介绍了 BeanPostProcessor 后处理器的基本使用。本篇我们来介绍其中的 一个相当重要的实现类 ："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "AutowiredAnnotationBeanPostProcessor"
				},
				{
					"Type": "NodeText",
					"Data": "​， "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "AutowiredAnnotationBeanPostProcessor"
				},
				{
					"Type": "NodeText",
					"Data": "​ 完成了 Spring基本的属性注入功能(@Autowired、@Value 、@Inject 注解功能)。下面我们来详细介绍。"
				}
			]
		},
		{
			"ID": "20230331084824-jlgd6q5",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331084824-jlgd6q5",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "二、AutowiredAnnotationBeanPostProcessor"
				}
			]
		},
		{
			"ID": "20230331084824-50mbn58",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-50mbn58",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下面是 AutowiredAnnotationBeanPostProcessor 的结构图图。\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/20200523142807968-20230331084824-b9yu8h3.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n可以看到 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "AutowiredAnnotationBeanPostProcessor"
				},
				{
					"Type": "NodeText",
					"Data": "​ 继承"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "InstantiationAwareBeanPostProcessorAdapter"
				},
				{
					"Type": "NodeText",
					"Data": "​类、实现 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "MergedBeanDefinitionPostProcessor"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "PriorityOrdered"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "BeanFactoryAware"
				},
				{
					"Type": "NodeText",
					"Data": "​ 接口。"
				}
			]
		},
		{
			"ID": "20230331084824-wl78c28",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-wl78c28",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "个人理解："
				}
			]
		},
		{
			"ID": "20230331084824-smqqmaw",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230331084824-smqqmaw",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"ID": "20230331084824-x8gkupm",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331084824-x8gkupm",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-fdzebvx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-fdzebvx",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "继承"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "InstantiationAwareBeanPostProcessorAdapter"
								},
								{
									"Type": "NodeText",
									"Data": "​、实现 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "MergedBeanDefinitionPostProcessor"
								},
								{
									"Type": "NodeText",
									"Data": "​ 是为了根据后处理器的调用时机来完成一些功能。"
								}
							]
						}
					]
				},
				{
					"ID": "20230331084824-gmdfrmt",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331084824-gmdfrmt",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-48e5thg",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-48e5thg",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "实现 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "PriorityOrdered"
								},
								{
									"Type": "NodeText",
									"Data": "​ 接口是为了标注自身优先注入。"
								}
							]
						}
					]
				},
				{
					"ID": "20230331084824-9hmutxe",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331084824-9hmutxe",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-6d5nrtj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-6d5nrtj",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "实现 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "BeanFactoryAware"
								},
								{
									"Type": "NodeText",
									"Data": "​ 是为了拿到 BeanFactory。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230331084824-613en42",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-613en42",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在进行下面讲解之前，先了解一下"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "AutowiredAnnotationBeanPostProcessor"
				},
				{
					"Type": "NodeText",
					"Data": "​ 中的一个Set集合 autowiredAnnotationTypes 。 autowiredAnnotationTypes 集合中保存了该类会处理的注解。"
				}
			]
		},
		{
			"ID": "20230331084824-wj1h7lk",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331084824-wj1h7lk",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\tprivate final Set\u003cClass\u003c? extends Annotation\u003e\u003e autowiredAnnotationTypes = new LinkedHashSet\u003c\u003e(4);\n\n\t...\n\tpublic AutowiredAnnotationBeanPostProcessor() { \n\t\tthis.autowiredAnnotationTypes.add(Autowired.class);\n\t\tthis.autowiredAnnotationTypes.add(Value.class);\n\t\ttry { \n\t\t\tthis.autowiredAnnotationTypes.add((Class\u003c? extends Annotation\u003e)\n\t\t\t\t\tClassUtils.forName(\"javax.inject.Inject\", AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));\n\t\t\tlogger.trace(\"JSR-330 'javax.inject.Inject' annotation found and supported for autowiring\");\n\t\t}\n\t\tcatch (ClassNotFoundException ex) { \n\t\t\t// JSR-330 API not available - simply skip.\n\t\t}\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331084824-n7jocxk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-n7jocxk",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以看到的是 在 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "AutowiredAnnotationBeanPostProcessor"
				},
				{
					"Type": "NodeText",
					"Data": "​初始化的时， autowiredAnnotationTypes 中添加了三个注解"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "@Autowired"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "@Value"
				},
				{
					"Type": "NodeText",
					"Data": "​、 和通过反射得到的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "javax.inject.Inject"
				},
				{
					"Type": "NodeText",
					"Data": "​。这三个注解也就是本类负责解析的三个注解了(@Inject 并不一定能加载到，看用户是否引入相应的包)。"
				}
			]
		},
		{
			"ID": "20230331084824-z4cjkbg",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331084824-z4cjkbg",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "三、determineCandidateConstructors"
				}
			]
		},
		{
			"ID": "20230331084824-nihyvp4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-nihyvp4",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "determineCandidateConstructors"
				},
				{
					"Type": "NodeText",
					"Data": "​ 方法是 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "InstantiationAwareBeanPostProcessorAdapter"
				},
				{
					"Type": "NodeText",
					"Data": "​ 接口中的方法。其作用是从 注入bean的所有构造函数中过滤出可以作为构造注入的构造函数列表。"
				}
			]
		},
		{
			"ID": "20230331084824-u3jsjvw",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331084824-u3jsjvw",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Override\n\t@Nullable\n\tpublic Constructor\u003c?\u003e[] determineCandidateConstructors(Class\u003c?\u003e beanClass, final String beanName)\n\t\t\tthrows BeanCreationException { \n\n\t\t// Let's check for lookup methods here...\n\t\t// 在这里首先处理了@Lookup注解\n\t\t// 判断是否已经解析过 。lookupMethodsChecked 作为一个缓存集合，保存已经处理过的bean\n\t\tif (!this.lookupMethodsChecked.contains(beanName)) { \n\t\t\tif (AnnotationUtils.isCandidateClass(beanClass, Lookup.class)) { \n\t\t\t\ttry { \n\t\t\t\t\tClass\u003c?\u003e targetClass = beanClass;\n\t\t\t\t\tdo { \n\t\t\t\t\t\t// 遍历bean中的每一个方法\n\t\t\t\t\t\tReflectionUtils.doWithLocalMethods(targetClass, method -\u003e { \n\t\t\t\t\t\t\t// 判断 方法是否被 @Lookup 修饰\n\t\t\t\t\t\t\tLookup lookup = method.getAnnotation(Lookup.class);\n\t\t\t\t\t\t\tif (lookup != null) { \n\t\t\t\t\t\t\t\tAssert.state(this.beanFactory != null, \"No BeanFactory available\");\n\t\t\t\t\t\t\t\t// 如果被@Lookup 修饰，则封装后保存到RootBeanDefinition 的methodOverrides 属性中，在 SimpleInstantiationStrategy#instantiate(RootBeanDefinition, String, BeanFactory) 进行了cglib的动态代理。\n\t\t\t\t\t\t\t\tLookupOverride override = new LookupOverride(method, lookup.value());\n\t\t\t\t\t\t\t\ttry { \n\t\t\t\t\t\t\t\t\tRootBeanDefinition mbd = (RootBeanDefinition)\n\t\t\t\t\t\t\t\t\t\t\tthis.beanFactory.getMergedBeanDefinition(beanName);\n\t\t\t\t\t\t\t\t\tmbd.getMethodOverrides().addOverride(override);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) { \n\t\t\t\t\t\t\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\t\t\t\t\t\t\"Cannot apply @Lookup to beans without corresponding bean definition\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\ttargetClass = targetClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\twhile (targetClass != null \u0026\u0026 targetClass != Object.class);\n\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ex) { \n\t\t\t\t\tthrow new BeanCreationException(beanName, \"Lookup method resolution failed\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 将已经解析好的beanName 添加到缓存中\n\t\t\tthis.lookupMethodsChecked.add(beanName);\n\t\t}\n\n\t\t// Quick check on the concurrent map first, with minimal locking.\n\t\t// 这里开始处理构造函数\n\t\t// 获取bean的所有候选构造函数\n\t\tConstructor\u003c?\u003e[] candidateConstructors = this.candidateConstructorsCache.get(beanClass);\n\t\tif (candidateConstructors == null) { \n\t\t\t// Fully synchronized resolution now...\n\t\t\tsynchronized (this.candidateConstructorsCache) { \n\t\t\t\tcandidateConstructors = this.candidateConstructorsCache.get(beanClass);\n\t\t\t\t// 如果构造函数为null，则通过反射获取\n\t\t\t\tif (candidateConstructors == null) { \n\t\t\t\t\tConstructor\u003c?\u003e[] rawCandidates;\n\t\t\t\t\ttry { \n\t\t\t\t\t\trawCandidates = beanClass.getDeclaredConstructors();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) { \n\t\t\t\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\t\t\t\"Resolution of declared constructors on bean Class [\" + beanClass.getName() +\n\t\t\t\t\t\t\t\t\"] from ClassLoader [\" + beanClass.getClassLoader() + \"] failed\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tList\u003cConstructor\u003c?\u003e\u003e candidates = new ArrayList\u003c\u003e(rawCandidates.length);\n\t\t\t\t\t// @Autowired(required = true) 的构造函数,有且只能有一个\n\t\t\t\t\tConstructor\u003c?\u003e requiredConstructor = null;\n\t\t\t\t\t// 默认的无参构造函数\n\t\t\t\t\tConstructor\u003c?\u003e defaultConstructor = null;\n\t\t\t\t\t// 针对 Kotlin 语言的构造函数，不太明白，一般为null\n\t\t\t\t\tConstructor\u003c?\u003e primaryConstructor = BeanUtils.findPrimaryConstructor(beanClass);\n\t\t\t\t\tint nonSyntheticConstructors = 0;\n\t\t\t\t\tfor (Constructor\u003c?\u003e candidate : rawCandidates) { \n\t\t\t\t\t\t// 构造函数是否是非合成，一般我们自己创建的都是非合成的。Java在编译过程中可能会出现一些合成的构造函数\n\t\t\t\t\t\tif (!candidate.isSynthetic()) { \n\t\t\t\t\t\t\tnonSyntheticConstructors++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (primaryConstructor != null) { \n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 遍历autowiredAnnotationTypes 集合，判断当前构造函数是否被 autowiredAnnotationTypes集合中的注解修饰,若未被修饰，则返回null\n\t\t\t\t\t\t// autowiredAnnotationTypes 集合中的注解在一开始就说了是 @Autowired、@Value 和 @Inject 三个。 \n\t\t\t\t\t\tMergedAnnotation\u003c?\u003e ann = findAutowiredAnnotation(candidate);\n\t\t\t\t\t\tif (ann == null) { \n\t\t\t\t\t\t\t// 如果未被修饰，这里判断是否是 Cglib 的代理类，如果是则获取原始类，否则直接返回beanClass\n\t\t\t\t\t\t\tClass\u003c?\u003e userClass = ClassUtils.getUserClass(beanClass);\n\t\t\t\t\t\t\t// 如果这里不相等，肯定是通过 cglib的代理类，这里的userClass 就是原始类，再次判断构造函数是否包含指定注解\n\t\t\t\t\t\t\tif (userClass != beanClass) { \n\t\t\t\t\t\t\t\ttry { \n\t\t\t\t\t\t\t\t\tConstructor\u003c?\u003e superCtor =\n\t\t\t\t\t\t\t\t\t\t\tuserClass.getDeclaredConstructor(candidate.getParameterTypes());\n\t\t\t\t\t\t\t\t\tann = findAutowiredAnnotation(superCtor);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (NoSuchMethodException ex) { \n\t\t\t\t\t\t\t\t\t// Simply proceed, no equivalent superclass constructor found...\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\tif (ann != null) { \n\t\t\t\t\t\t\t// 如果已经找到了必须装配的构造函数(requiredConstructor  != null)，那么当前这个就是多余的，则抛出异常\n\t\t\t\t\t\t\tif (requiredConstructor != null) { \n\t\t\t\t\t\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\t\t\t\t\t\"Invalid autowire-marked constructor: \" + candidate +\n\t\t\t\t\t\t\t\t\t\t\". Found constructor with 'required' Autowired annotation already: \" +\n\t\t\t\t\t\t\t\t\t\trequiredConstructor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// 确定是否是必须的，@Autowired 和@Inject 默认为true。@Autowired 可以通过 required 修改\n\t\t\t\t\t\t\tboolean required = determineRequiredStatus(ann);\n\t\t\t\t\t\t\tif (required) { \n\t\t\t\t\t\t\t\t// 如果当前构造函数为必须注入，但是候选列表不为空，则说明已经有构造函数适配，则抛出异常。就是只要有required = true的构造函数就不允许存在其他可注入的构造函数\n\t\t\t\t\t\t\t\tif (!candidates.isEmpty()) { \n\t\t\t\t\t\t\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\t\t\t\t\t\t\"Invalid autowire-marked constructors: \" + candidates +\n\t\t\t\t\t\t\t\t\t\t\t\". Found constructor with 'required' Autowired annotation: \" +\n\t\t\t\t\t\t\t\t\t\t\tcandidate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// 到这一步，说明当前构造函数是必须的，且目前没有其他构造函数候选\n\t\t\t\t\t\t\t\t// 直接将当前构造函数作为必须构造函数\n\t\t\t\t\t\t\t\trequiredConstructor = candidate;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// 添加到候选列表\n\t\t\t\t\t\t\tcandidates.add(candidate);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 如果 构造函数参数数量为0，则是默认构造函数，使用默认构造函数\n\t\t\t\t\t\telse if (candidate.getParameterCount() == 0) { \n\t\t\t\t\t\t\tdefaultConstructor = candidate;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 如果候选构造函数不为空\n\t\t\t\t\tif (!candidates.isEmpty()) { \n\t\t\t\t\t\t// Add default constructor to list of optional constructors, as fallback.\n\t\t\t\t\t\tif (requiredConstructor == null) { \n\t\t\t\t\t\t\tif (defaultConstructor != null) { \n\t\t\t\t\t\t\t\tcandidates.add(defaultConstructor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (candidates.size() == 1 \u0026\u0026 logger.isInfoEnabled()) { \n\t\t\t\t\t\t\t\tlogger.info(\"Inconsistent constructor declaration on bean with name '\" + beanName +\n\t\t\t\t\t\t\t\t\t\t\"': single autowire-marked constructor flagged as optional - \" +\n\t\t\t\t\t\t\t\t\t\t\"this constructor is effectively required since there is no \" +\n\t\t\t\t\t\t\t\t\t\t\"default constructor to fall back to: \" + candidates.get(0));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcandidateConstructors = candidates.toArray(new Constructor\u003c?\u003e[0]);\n\t\t\t\t\t}\n\t\t\t\t\t// 如果 当前bean只有一个有参构造函数，那么将此构造函数作为候选列表返回(这就代表，如果bean中只有一个有参构造函数并不需要使用特殊注解，也会作为构造函数进行注入)\n\t\t\t\t\telse if (rawCandidates.length == 1 \u0026\u0026 rawCandidates[0].getParameterCount() \u003e 0) { \n\t\t\t\t\t\tcandidateConstructors = new Constructor\u003c?\u003e[] { rawCandidates[0]};\n\t\t\t\t\t}\n\t\t\t\t\t//下面这一段判断不是太理解\n\t\t\t\t\telse if (nonSyntheticConstructors == 2 \u0026\u0026 primaryConstructor != null \u0026\u0026\n\t\t\t\t\t\t\tdefaultConstructor != null \u0026\u0026 !primaryConstructor.equals(defaultConstructor)) { \n\t\t\t\t\t\tcandidateConstructors = new Constructor\u003c?\u003e[] { primaryConstructor, defaultConstructor};\n\t\t\t\t\t}\n\t\t\t\t\telse if (nonSyntheticConstructors == 1 \u0026\u0026 primaryConstructor != null) { \n\t\t\t\t\t\tcandidateConstructors = new Constructor\u003c?\u003e[] { primaryConstructor};\n\t\t\t\t\t}\n\t\t\t\t\telse { \n\t\t\t\t\t\tcandidateConstructors = new Constructor\u003c?\u003e[0];\n\t\t\t\t\t}\n\t\t\t\t\tthis.candidateConstructorsCache.put(beanClass, candidateConstructors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (candidateConstructors.length \u003e 0 ? candidateConstructors : null);\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331084824-9hx4ipy",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331084824-9hx4ipy",
				"updated": "20230331084824"
			}
		},
		{
			"ID": "20230331084824-f59ple5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-f59ple5",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里的构造函数选取规则大致如下："
				}
			]
		},
		{
			"ID": "20230331084824-91ij6og",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230331084824-91ij6og",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"ID": "20230331084824-x5p4yc9",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230331084824-x5p4yc9",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-uw9ppsz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-uw9ppsz",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "解析"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "@Lookup"
								},
								{
									"Type": "NodeText",
									"Data": "​ 注解的方法，保存到 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "RootBeanDefinition"
								},
								{
									"Type": "NodeText",
									"Data": "​ 中"
								}
							]
						}
					]
				},
				{
					"ID": "20230331084824-r709tew",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230331084824-r709tew",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-471akz3",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-471akz3",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "从缓存中获取筛选好的构造函数列表，若有直接返回，没有则进行下一步"
								}
							]
						}
					]
				},
				{
					"ID": "20230331084824-ronk5v6",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230331084824-ronk5v6",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-ow319u2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-ow319u2",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "通过反射获取bean 的所有构造函数，并进行构造函数遍历。筛选每个构造函数是否被 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "@Autowired、@Inject"
								},
								{
									"Type": "NodeText",
									"Data": "​ 注解修饰。"
								}
							]
						}
					]
				},
				{
					"ID": "20230331084824-vaxcrf5",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20230331084824-vaxcrf5",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-ai5cvfc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-ai5cvfc",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "当前构造函数没有被修饰，则判断当前bean是否 是 Cglib动态代理类，如果是，则获取原始类的构造函数，再判断 构造函数是否被 @Autowired、@Inject 注解修饰。"
								}
							]
						}
					]
				},
				{
					"ID": "20230331084824-wp25xsu",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20230331084824-wp25xsu",
						"updated": "20230331084824"
					},
					"Children": [
						{
							"ID": "20230331084824-guprdem",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331084824-guprdem",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果第三步或者第四步成功，则根据如下规则筛选"
								}
							]
						},
						{
							"ID": "20230331084824-valkfqs",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20230331084824-valkfqs",
								"updated": "20230331084824"
							},
							"Children": [
								{
									"ID": "20230331084824-hmtvbob",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230331084824-hmtvbob",
										"updated": "20230331084824"
									},
									"Children": [
										{
											"ID": "20230331084824-ugxt2a8",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230331084824-ugxt2a8",
												"updated": "20230331084824"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "如果有一个必须注入的构造函数("
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "@Autowired(required =true)"
												},
												{
													"Type": "NodeText",
													"Data": "​ 或者 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "@Inject"
												},
												{
													"Type": "NodeText",
													"Data": "​ )，则不允许有其他候选构造函数出现。有且只能筛选出一个必须注入的构造函数"
												}
											]
										}
									]
								},
								{
									"ID": "20230331084824-xcol7o7",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230331084824-xcol7o7",
										"updated": "20230331084824"
									},
									"Children": [
										{
											"ID": "20230331084824-qqig8nx",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230331084824-qqig8nx",
												"updated": "20230331084824"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "如果不存在必须注入的构造含函数 （"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "@Autowired(required =false)"
												},
												{
													"Type": "NodeText",
													"Data": "​ 或者 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "@Inject"
												},
												{
													"Type": "NodeText",
													"Data": "​) ，则允许多个候选注入构造函数出现（"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "@Autowired(required = false"
												},
												{
													"Type": "NodeText",
													"Data": "​) 修饰的构造函数）。并且将这个几个候选构造函数返回"
												}
											]
										}
									]
								},
								{
									"ID": "20230331084824-sb04929",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230331084824-sb04929",
										"updated": "20230331084824"
									},
									"Children": [
										{
											"ID": "20230331084824-k2o027m",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230331084824-k2o027m",
												"updated": "20230331084824"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "如果bean有且只有一个构造函数，即使没有被注解修饰，也会调用该构造函数作为bean创建的构造函使用"
												}
											]
										}
									]
								},
								{
									"ID": "20230331084824-bd3ywf3",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230331084824-bd3ywf3",
										"updated": "20230331084824"
									},
									"Children": [
										{
											"ID": "20230331084824-04r84q1",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230331084824-04r84q1",
												"updated": "20230331084824"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "上面三种情况都不满足，就按照指定的规则来进行判断返回候选列表("
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "sub",
													"TextMarkTextContent": "其实是我没看懂else if 后面的逻辑"
												},
												{
													"Type": "NodeText",
													"Data": " )"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230331084824-ikrca9q",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331084824-ikrca9q",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "四、postProcessProperties \u0026 postProcessPropertyValues"
				}
			]
		},
		{
			"ID": "20230331084824-ft79k08",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-ft79k08",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在这两个方法中完成了"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "@Autowired、@Inject、 @Value"
				},
				{
					"Type": "NodeText",
					"Data": "​ 注解的解析。"
				}
			]
		},
		{
			"ID": "20230331084824-qqoum9l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-qqoum9l",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在调用 postProcessProperties 时正是完成Bean 属性注入的时候，详情请看 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/106299180",
					"TextMarkTextContent": "Spring源码分析四：bean的属性注入 - populateBean"
				},
				{
					"Type": "NodeText",
					"Data": "。这里不多讲。"
				}
			]
		},
		{
			"ID": "20230331084824-avm9peq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-avm9peq",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在postProcessProperties 方法中完成了Bean 中"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "@Autowired、@Inject、 @Value"
				},
				{
					"Type": "NodeText",
					"Data": "​ 注解的解析并注入的功能。"
				}
			]
		},
		{
			"ID": "20230331084824-9fqriz8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-9fqriz8",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "具体代码如下："
				}
			]
		},
		{
			"ID": "20230331084824-tjekg1z",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331084824-tjekg1z",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\t@Override\n\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) { \n\t\t// 筛选出需要注入的属性类型\n\t\tInjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);\n\t\ttry { \n\t\t\t// 进行属性注入\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (BeanCreationException ex) { \n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) { \n\t\t\tthrow new BeanCreationException(beanName, \"Injection of autowired dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}\n\n\t@Deprecated\n\t@Override\n\t// 过时方法\n\tpublic PropertyValues postProcessPropertyValues(\n\t\t\tPropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) { \n\n\t\treturn postProcessProperties(pvs, bean, beanName);\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331084824-aho7vls",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331084824-aho7vls",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1. findAutowiringMetadata"
				}
			]
		},
		{
			"ID": "20230331084824-nb0ci4l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-nb0ci4l",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上面可以看到，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "findAutowiringMetadata"
				},
				{
					"Type": "NodeText",
					"Data": "​完成了对需要注入属性的筛选工作，将筛选通过的bean信息缓存到injectionMetadataCache 中，表示当前加载的bean需要注入的bean属性，下面来分析如何完成。\n注： 这个方法第一次调用是在 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "postProcessMergedBeanDefinition"
				},
				{
					"Type": "NodeText",
					"Data": "​ 方法中，后续的调用都是从缓存中获取了"
				}
			]
		},
		{
			"ID": "20230331084824-h557xol",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331084824-h557xol",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\tprivate InjectionMetadata findAutowiringMetadata(String beanName, Class\u003c?\u003e clazz, @Nullable PropertyValues pvs) { \n\t\t// Fall back to class name as cache key, for backwards compatibility with custom callers.\n\t\tString cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());\n\t\t// Quick check on the concurrent map first, with minimal locking.\n\t\t// 从缓存中获取metadata\n\t\tInjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);\n\t\t// 如果需要刷新  ： metadata == null || metadata.needsRefresh(clazz)\n\t\tif (InjectionMetadata.needsRefresh(metadata, clazz)) { \n\t\t\tsynchronized (this.injectionMetadataCache) { \n\t\t\t\tmetadata = this.injectionMetadataCache.get(cacheKey);\n\t\t\t\tif (InjectionMetadata.needsRefresh(metadata, clazz)) { \n\t\t\t\t\tif (metadata != null) { \n\t\t\t\t\t\tmetadata.clear(pvs);\n\t\t\t\t\t}\n\t\t\t\t\t// 创建 metadata \n\t\t\t\t\tmetadata = buildAutowiringMetadata(clazz);\n\t\t\t\t\tthis.injectionMetadataCache.put(cacheKey, metadata);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn metadata;\n\t}\n\t// 核心的筛选功能方法\n\tprivate InjectionMetadata buildAutowiringMetadata(final Class\u003c?\u003e clazz) { \n\t\t// 确定给定的类是否适合携带指定的注释，比如一些注释只能用在方法或者类上\n\t\tif (!AnnotationUtils.isCandidateClass(clazz, this.autowiredAnnotationTypes)) { \n\t\t\treturn InjectionMetadata.EMPTY;\n\t\t}\n\n\t\tList\u003cInjectionMetadata.InjectedElement\u003e elements = new ArrayList\u003c\u003e();\n\t\tClass\u003c?\u003e targetClass = clazz;\n\n\t\tdo { \n\t\t\tfinal List\u003cInjectionMetadata.InjectedElement\u003e currElements = new ArrayList\u003c\u003e();\n\t\t\t// 遍历类中的每个属性，判断属性是否包含指定的属性(通过 findAutowiredAnnotation 方法)\n\t\t\t// 如果存在则保存，这里注意，属性保存的类型是 AutowiredFieldElement\n\t\t\tReflectionUtils.doWithLocalFields(targetClass, field -\u003e { \n\t\t\t\tMergedAnnotation\u003c?\u003e ann = findAutowiredAnnotation(field);\n\t\t\t\tif (ann != null) { \n\t\t\t\t\tif (Modifier.isStatic(field.getModifiers())) { \n\t\t\t\t\t\tif (logger.isInfoEnabled()) { \n\t\t\t\t\t\t\tlogger.info(\"Autowired annotation is not supported on static fields: \" + field);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tboolean required = determineRequiredStatus(ann);\n\t\t\t\t\tcurrElements.add(new AutowiredFieldElement(field, required));\n\t\t\t\t}\n\t\t\t});\n\t\t\t// 遍历类中的每个方法，判断属性是否包含指定的属性(通过 findAutowiredAnnotation 方法)\n\t\t\t// 如果存在则保存，这里注意，方法保存的类型是 AutowiredMethodElement\n\t\t\tReflectionUtils.doWithLocalMethods(targetClass, method -\u003e { \n\t\t\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n\t\t\t\tif (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) { \n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tMergedAnnotation\u003c?\u003e ann = findAutowiredAnnotation(bridgedMethod);\n\t\t\t\tif (ann != null \u0026\u0026 method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) { \n\t\t\t\t\tif (Modifier.isStatic(method.getModifiers())) { \n\t\t\t\t\t\tif (logger.isInfoEnabled()) { \n\t\t\t\t\t\t\tlogger.info(\"Autowired annotation is not supported on static methods: \" + method);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (method.getParameterCount() == 0) { \n\t\t\t\t\t\tif (logger.isInfoEnabled()) { \n\t\t\t\t\t\t\tlogger.info(\"Autowired annotation should only be used on methods with parameters: \" +\n\t\t\t\t\t\t\t\t\tmethod);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tboolean required = determineRequiredStatus(ann);\n\t\t\t\t\tPropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n\t\t\t\t\tcurrElements.add(new AutowiredMethodElement(method, required, pd));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\telements.addAll(0, currElements);\n\t\t\ttargetClass = targetClass.getSuperclass();\n\t\t}\n\t\twhile (targetClass != null \u0026\u0026 targetClass != Object.class);\n\t\t// 将结果返回\n\t\treturn InjectionMetadata.forElements(elements, clazz);\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331084824-12h4xlk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-12h4xlk",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "总计 : 遍历当前bean中的所有属性和方法，如果包含指定属性，则保存起来。属性保存的类型是"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong code",
					"TextMarkTextContent": "AutowiredFieldElement"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": ", 方法保存的类型是 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong code",
					"TextMarkTextContent": "AutowiredMethodElement"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "。"
				}
			]
		},
		{
			"ID": "20230331084824-q1h2l2i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-q1h2l2i",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "注： "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong code",
					"TextMarkTextContent": "AutowiredFieldElement"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": " 和 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong code",
					"TextMarkTextContent": "AutowiredMethodElement"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": " 是 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong code",
					"TextMarkTextContent": "AutowiredAnnotationBeanPostProcessor"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": " 的内部类"
				}
			]
		},
		{
			"ID": "20230331084824-v9sc9ly",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331084824-v9sc9ly",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2. InjectionMetadata#inject"
				}
			]
		},
		{
			"ID": "20230331084824-58p3u6q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-58p3u6q",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "筛选出需要注入的元素，则开始进行注入，这里可以看到，inject 的实现很简单，遍历所有元素，调用元素的 inject 方法。不过这里就知道上面针对属性和方法，保存的类型分别是 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "AutowiredFieldElement"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "AutowiredMethodElement"
				},
				{
					"Type": "NodeText",
					"Data": "​。所以属性调用的是AutowiredFieldElement.inject， 方法调用的是 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "AutowiredMethodElement.inject"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230331084824-w9cerha",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331084824-w9cerha",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\tpublic void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable { \n\t\tCollection\u003cInjectedElement\u003e checkedElements = this.checkedElements;\n\t\tCollection\u003cInjectedElement\u003e elementsToIterate =\n\t\t\t\t(checkedElements != null ? checkedElements : this.injectedElements);\n\t\tif (!elementsToIterate.isEmpty()) { \n\t\t\tfor (InjectedElement element : elementsToIterate) { \n\t\t\t\tif (logger.isTraceEnabled()) { \n\t\t\t\t\tlogger.trace(\"Processing injected element of bean '\" + beanName + \"': \" + element);\n\t\t\t\t}\n\t\t\t\telement.inject(target, beanName, pvs);\n\t\t\t}\n\t\t}\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331084824-x36u1gr",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331084824-x36u1gr",
				"updated": "20230331084824"
			}
		},
		{
			"ID": "20230331084824-ytmqop1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-ytmqop1",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "这里我们需要注意："
				},
				{
					"Type": "NodeText",
					"Data": "\n在 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "findAutowiringMetadata"
				},
				{
					"Type": "NodeText",
					"Data": "​ 中添加的注入元素的顺序先添加属性元素，再添加方法元素。\n那么在 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "InjectionMetadata#inject"
				},
				{
					"Type": "NodeText",
					"Data": "​ 的遍历中也是先遍历属性元素，再遍历方法元素。那么就可以知道，​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "方法注入的优先级要高于属性注入"
				},
				{
					"Type": "NodeText",
					"Data": "​，因为方法注入在属性注入后，会将属性注入的结果覆盖掉。"
				}
			]
		},
		{
			"ID": "20230331084824-sb4hjb3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-sb4hjb3",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如 ："
				}
			]
		},
		{
			"ID": "20230331084824-sfmusca",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331084824-sfmusca",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@RestController\npublic class DemoController { \n    @Autowired\n    private DemoService demoService;\n\n    @Autowired\n    public void setDemoService(DemoService demoService) { \n        this.demoService = new DemoServiceImpl(\"setter\");\n    }\n\n    public DemoController(DemoService demoService) { \n        this.demoService = new DemoServiceImpl(\"构造\");\n    }\n\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331084824-ozssul9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-ozssul9",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "最终注入的 DemoService 是 设值注入的 结果。"
				}
			]
		},
		{
			"ID": "20230331084824-umni7xw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-umni7xw",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/20200704113413855-20230331084824-41qy0hi.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230331084824-t5ty5qs",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331084824-t5ty5qs",
				"updated": "20230331084824"
			}
		},
		{
			"ID": "20230331084824-pjb49p8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-pjb49p8",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "跑题了，下面来看看属性注入和方法注入的具体实现"
				}
			]
		},
		{
			"ID": "20230331084824-oi4ge7b",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331084824-oi4ge7b",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3. AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject"
				}
			]
		},
		{
			"ID": "20230331084824-sfsb5w3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-sfsb5w3",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "AutowiredFieldElement#inject"
				},
				{
					"Type": "NodeText",
					"Data": "​ 针对属性的注入实现。具体实现如下："
				}
			]
		},
		{
			"ID": "20230331084824-gp93yit",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331084824-gp93yit",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable { \n\t\t\tField field = (Field) this.member;\n\t\t\tObject value;\n\t\t\t// 如果缓存，从缓存中获取\n\t\t\tif (this.cached) { \n\t\t\t\t// 判断 如果  cachedFieldValue instanceof DependencyDescriptor。则调用 resolveDependency 方法重新加载。\n\t\t\t\tvalue = resolvedCachedArgument(beanName, this.cachedFieldValue);\n\t\t\t}\n\t\t\telse { \n\t\t\t\t// 否则调用了 resolveDependency 方法。这个在前篇讲过，在 populateBean 方法中按照类型注入的时候就是通过此方法，也就是说明了 @Autowired 和 @Inject默认是 按照类型注入的\n\t\t\t\tDependencyDescriptor desc = new DependencyDescriptor(field, this.required);\n\t\t\t\tdesc.setContainingClass(bean.getClass());\n\t\t\t\tSet\u003cString\u003e autowiredBeanNames = new LinkedHashSet\u003c\u003e(1);\n\t\t\t\tAssert.state(beanFactory != null, \"No BeanFactory available\");\n\t\t\t\tTypeConverter typeConverter = beanFactory.getTypeConverter();\n\t\t\t\ttry { \n\t\t\t\t\tvalue = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) { \n\t\t\t\t\tthrow new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex);\n\t\t\t\t}\n\t\t\t\tsynchronized (this) { \n\t\t\t\t\t// 如果没有缓存，则开始缓存\n\t\t\t\t\tif (!this.cached) { \n\t\t\t\t\t\tif (value != null || this.required) { \n\t\t\t\t\t\t\t// 这里先缓存一下 desc，如果下面 utowiredBeanNames.size() \u003e 1。则在上面从缓存中获取的时候会重新获取。\n\t\t\t\t\t\t\tthis.cachedFieldValue = desc;\n\t\t\t\t\t\t\t// 注册依赖bean\n\t\t\t\t\t\t\tregisterDependentBeans(beanName, autowiredBeanNames);\n\t\t\t\t\t\t\t// 如果按照类型只查到一个bean(因为可能存在多个类型相同，name不同的bean)，则缓存\n\t\t\t\t\t\t\tif (autowiredBeanNames.size() == 1) { \n\t\t\t\t\t\t\t\tString autowiredBeanName = autowiredBeanNames.iterator().next();\n\t\t\t\t\t\t\t\tif (beanFactory.containsBean(autowiredBeanName) \u0026\u0026\n\t\t\t\t\t\t\t\t\t\tbeanFactory.isTypeMatch(autowiredBeanName, field.getType())) { \n\t\t\t\t\t\t\t\t\tthis.cachedFieldValue = new ShortcutDependencyDescriptor(\n\t\t\t\t\t\t\t\t\t\t\tdesc, autowiredBeanName, field.getType());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { \n\t\t\t\t\t\t\tthis.cachedFieldValue = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.cached = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value != null) { \n\t\t\t\t// 通过反射，给属性赋值\n\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\tfield.set(bean, value);\n\t\t\t}\n\t\t}\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331084824-smumiia",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-smumiia",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里需要注意的是：在没有缓存的时候，调用的是 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "beanFactory.resolveDependency"
				},
				{
					"Type": "NodeText",
					"Data": "​ 方法。这个方法在 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/106299180",
					"TextMarkTextContent": "Spring源码分析四：bean的属性注入 - populateBean"
				},
				{
					"Type": "NodeText",
					"Data": " 中有过详细解读。简单来说，Spring 通过类型来查找bean就是通过该方法实现的，所以这里说明了 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "@Autowired"
				},
				{
					"Type": "NodeText",
					"Data": "​ 和 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "@Inject"
				},
				{
					"Type": "NodeText",
					"Data": "​ 默认都是按照类型注入的。"
				}
			]
		},
		{
			"ID": "20230331084824-f7ikucr",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331084824-f7ikucr",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4. AutowiredAnnotationBeanPostProcessor.AutowiredMethodElement#inject"
				}
			]
		},
		{
			"ID": "20230331084824-zb725tt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-zb725tt",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "AutowiredFieldElement#inject"
				},
				{
					"Type": "NodeText",
					"Data": "​ 针对方法的注入实现。具体实现如下："
				}
			]
		},
		{
			"ID": "20230331084824-m1inaws",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331084824-m1inaws",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\tprotected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable { \n\t\t\t// 检测是否可以跳过\n\t\t\tif (checkPropertySkipping(pvs)) { \n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// 获取方法\n\t\t\tMethod method = (Method) this.member;\n\t\t\tObject[] arguments;\n\t\t\t// 如果缓存从缓存中虎丘\n\t\t\tif (this.cached) { \n\t\t\t\t// Shortcut for avoiding synchronization...\n\t\t\t\targuments = resolveCachedArguments(beanName);\n\t\t\t}\n\t\t\telse { \n\t\t\t\t// 获取方法的参数，从Spring 容器中获取(缓存中没有则尝试创建)\n\t\t\t\tint argumentCount = method.getParameterCount();\n\t\t\t\targuments = new Object[argumentCount];\n\t\t\t\tDependencyDescriptor[] descriptors = new DependencyDescriptor[argumentCount];\n\t\t\t\tSet\u003cString\u003e autowiredBeans = new LinkedHashSet\u003c\u003e(argumentCount);\n\t\t\t\tAssert.state(beanFactory != null, \"No BeanFactory available\");\n\t\t\t\tTypeConverter typeConverter = beanFactory.getTypeConverter();\n\t\t\t\t// 遍历参数从容器中获取\n\t\t\t\tfor (int i = 0; i \u003c arguments.length; i++) { \n\t\t\t\t\tMethodParameter methodParam = new MethodParameter(method, i);\n\t\t\t\t\tDependencyDescriptor currDesc = new DependencyDescriptor(methodParam, this.required);\n\t\t\t\t\tcurrDesc.setContainingClass(bean.getClass());\n\t\t\t\t\tdescriptors[i] = currDesc;\n\t\t\t\t\ttry { \n\t\t\t\t\t\t// 根据类型从容器中获取\n\t\t\t\t\t\tObject arg = beanFactory.resolveDependency(currDesc, beanName, autowiredBeans, typeConverter);\n\t\t\t\t\t\tif (arg == null \u0026\u0026 !this.required) { \n\t\t\t\t\t\t\targuments = null;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targuments[i] = arg;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (BeansException ex) { \n\t\t\t\t\t\tthrow new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(methodParam), ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 进行缓存\n\t\t\t\t...\n\t\t\t}\n\t\t\tif (arguments != null) { \n\t\t\t\ttry { \n\t\t\t\t\t// 通过反射，调用注解标注的方法\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tmethod.invoke(bean, arguments);\n\t\t\t\t}\n\t\t\t\tcatch (InvocationTargetException ex) { \n\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331084824-tirkqv2",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331084824-tirkqv2",
				"updated": "20230331084824"
			}
		},
		{
			"ID": "20230331084824-ijzoiil",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-ijzoiil",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "总结："
				},
				{
					"Type": "NodeText",
					"Data": "\n​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong strong code",
					"TextMarkTextContent": "AutowiredAnnotationBeanPostProcessor"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": " 的属性注入是通过类型注入的，如果是属性，则直接从Spring容器中根据类型获取bean，通过反射赋值。如果是方法，则获取方法的参数列表，从容器中获取对应的参数，获取到后通过反射调用方法。"
				}
			]
		},
		{
			"ID": "20230331084824-eqiaov5",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331084824-eqiaov5",
				"updated": "20230331084824"
			}
		},
		{
			"ID": "20230331084824-km7xpjn",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331084824-km7xpjn",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "五、postProcessMergedBeanDefinition"
				}
			]
		},
		{
			"ID": "20230331084824-v4u9tc0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-v4u9tc0",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "该方法是在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": ".AbstractAutowireCapableBeanFactory#doCreateBean"
				},
				{
					"Type": "NodeText",
					"Data": "​， 创建bean的时候进行的调用了 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition"
				},
				{
					"Type": "NodeText",
					"Data": "​。如下：\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/20210112202925854-20230331084824-ujjnc43.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230331084824-lal4176",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-lal4176",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition的实现如下："
				}
			]
		},
		{
			"ID": "20230331084824-n7sfevp",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331084824-n7sfevp",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\t@Override\n\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class\u003c?\u003e beanType, String beanName) { \n\t\tInjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null);\n\t\tmetadata.checkConfigMembers(beanDefinition);\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331084824-esf1jqs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-esf1jqs",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "findAutowiringMetadata(beanName, beanType, null);"
				},
				{
					"Type": "NodeText",
					"Data": "​ 在上面我们已经解析过了，可以很明显知道，Spring在这里做了一个缓存，因为"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "postProcessMergedBeanDefinition"
				},
				{
					"Type": "NodeText",
					"Data": "​ 的调用时机早于 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "postProcessProperties \u0026amp; postProcessPropertyValues"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230331084824-tyczm83",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-tyczm83",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "InjectionMetadata#checkConfigMembers"
				},
				{
					"Type": "NodeText",
					"Data": "​ 这里个人认为是做了一个注入对象的缓存"
				}
			]
		},
		{
			"ID": "20230331084824-7xiokkm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331084824-7xiokkm",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\tpublic void checkConfigMembers(RootBeanDefinition beanDefinition) { \n\t\tSet\u003cInjectedElement\u003e checkedElements = new LinkedHashSet\u003c\u003e(this.injectedElements.size());\n\t\t// 遍历待注入的 bean(被封装成了 element )\n\t\tfor (InjectedElement element : this.injectedElements) { \n\t\t\t// 获取 Member，包含了 bean 信息\n\t\t\tMember member = element.getMember();\n\t\t\t// 如果没被缓存则进行缓存，否则直接跳过\n\t\t\tif (!beanDefinition.isExternallyManagedConfigMember(member)) { \n\t\t\t\tbeanDefinition.registerExternallyManagedConfigMember(member);\n\t\t\t\tcheckedElements.add(element);\n\t\t\t\tif (logger.isTraceEnabled()) { \n\t\t\t\t\tlogger.trace(\"Registered injected element on class [\" + this.targetClass.getName() + \"]: \" + element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.checkedElements = checkedElements;\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331084824-9p41ai5",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331084824-9p41ai5",
				"updated": "20230331084824"
			}
		},
		{
			"ID": "20230331084824-rmv6vq7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331084824-rmv6vq7",
				"updated": "20230331084824"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "以上：内容部分参考《Spring源码深度解析》如有侵扰，联系删除。 内容仅用于自我记录学习使用。如有错误，欢迎指正"
				}
			]
		}
	]
}