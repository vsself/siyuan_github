{
	"ID": "20230404010557-ay5o2aj",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230404010557-ay5o2aj",
		"title": "吃透Spring源码（十九）：CGLIB动态代理创建过程_吃透Java的博客-CSDN博客",
		"updated": "20230404010557"
	},
	"Children": [
		{
			"ID": "20230404010557-qptsas8",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230404010557-qptsas8",
				"updated": "20230404010557"
			}
		},
		{
			"ID": "20230404010557-2gnftpk",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404010557-2gnftpk",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"ID": "20230404010557-aqv8ijs",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404010557-aqv8ijs",
						"updated": "20230404010557"
					},
					"Children": [
						{
							"ID": "20230404010557-j1gisxc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404010557-j1gisxc",
								"updated": "20230404010557"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/114707651",
									"TextMarkTextContent": "https://blog.csdn.net/u013277209/article/details/114707651"
								}
							]
						}
					]
				},
				{
					"ID": "20230404010557-ji79ofk",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404010557-ji79ofk",
						"updated": "20230404010557"
					},
					"Children": [
						{
							"ID": "20230404010557-2s3cy41",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404010557-2s3cy41",
								"updated": "20230404010557"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​\t\tCGLIB(Code Generation Library)是一个开源项目！是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。​\t\tCGLIB是一个强大的高性能的代码生成包。它广泛的被许多AOP的框架使用，例如Spring AOP为他们提供方法的interception（拦截）。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。除了CGLIB包，脚本语言例如Groovy和BeanShell，也是使用ASM来生成jav"
								}
							]
						}
					]
				},
				{
					"ID": "20230404010557-84guc4a",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404010557-84guc4a",
						"updated": "20230404010557"
					},
					"Children": [
						{
							"ID": "20230404010557-lhzhkhb",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404010557-lhzhkhb",
								"updated": "20230404010557"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2023-04-04 01:05:57"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404010557-jcgdiwq",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230404010557-jcgdiwq",
				"updated": "20230404010557"
			}
		},
		{
			"ID": "20230404010557-5j61pbd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-5j61pbd",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://so.csdn.net/so/search?q=CGLIB\u0026spm=1001.2101.3001.7020",
					"TextMarkTextContent": "CGLIB"
				},
				{
					"Type": "NodeText",
					"Data": "(Code Generation Library)是一个开源项目！是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。"
				}
			]
		},
		{
			"ID": "20230404010557-o7cozzw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-o7cozzw",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ CGLIB是一个强大的高性能的代码生成包。它广泛的被许多"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://so.csdn.net/so/search?q=AOP\u0026spm=1001.2101.3001.7020",
					"TextMarkTextContent": "AOP"
				},
				{
					"Type": "NodeText",
					"Data": "的框架使用，例如Spring AOP为他们提供方法的interception（拦截）。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。除了CGLIB包，脚本语言例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。"
				}
			]
		},
		{
			"ID": "20230404010557-iwqrc2n",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230404010557-iwqrc2n",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一，例子准备"
				}
			]
		},
		{
			"ID": "20230404010557-qqtft4d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-qqtft4d",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "MyCalculator.java"
				}
			]
		},
		{
			"ID": "20230404010557-dc1ro1m",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-dc1ro1m",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\npublic class MyCalculator { \n    public int add(int i, int j) { \n        int result = i + j;\n        return result;\n    }\n\n    public int sub(int i, int j) { \n        int result = i - j;\n        return result;\n    }\n\n    public int mult(int i, int j) { \n        int result = i * j;\n        return result;\n    }\n\n    public int div(int i, int j) { \n        int result = i / j;\n        return result;\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-efa63w3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-efa63w3",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "MyCglib.java"
				}
			]
		},
		{
			"ID": "20230404010557-41vvnte",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-41vvnte",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class MyCglib implements MethodInterceptor { \n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { \n        Object o1 = methodProxy.invokeSuper(o, objects);\n        return o1;\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-mtx2xzo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-mtx2xzo",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "MyTest.java"
				}
			]
		},
		{
			"ID": "20230404010557-moj83qs",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-moj83qs",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class MyTest { \n    public static void main(String[] args) { \n        //动态代理创建的class文件存储到本地\n        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY,\"d:\\\\code\");\n        //通过cglib动态代理获取代理对象的过程，创建调用的对象\n        Enhancer enhancer = new Enhancer();\n        //设置enhancer对象的父类\n        enhancer.setSuperclass(MyCalculator.class);\n        //设置enhancer的回调对象\n        enhancer.setCallback(new MyCglib());\n        //创建代理对象\n        MyCalculator myCalculator = (MyCalculator) enhancer.create();\n        //通过代理对象调用目标方法\n        myCalculator.add(1,1);\n        System.out.println(myCalculator.getClass());\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-f5hkhst",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230404010557-f5hkhst",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "二，实现原理"
				}
			]
		},
		{
			"ID": "20230404010557-jf32nco",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-jf32nco",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 利用cglib实现动态代理的时候，必须要实现MethodInterceptor接口，此接口源码如下："
				}
			]
		},
		{
			"ID": "20230404010557-nceb1dh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-nceb1dh",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "MethodInterceptor.java"
				}
			]
		},
		{
			"ID": "20230404010557-0xr55hx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-0xr55hx",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public interface MethodInterceptor\nextends Callback\n{ \n \t/*\n \t此方法用来实现方法的拦截，四个参数分别表示的含义：\n \tobj:表示增强的对象，即实现这个接口类的一个对象\n \tmethod：表示要拦截的方法\n \targs：表示被拦截的方法的参数\n \tproxy:表示要触发父类的方法对象\n \t*/\n    public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,\n                               MethodProxy proxy) throws Throwable;\n\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-zlnb9ck",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-zlnb9ck",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​我们创建了一个cglib的Enhancer对象，并且设置了父类、回调函数等参数，最重要的入口函数是create()方法："
				}
			]
		},
		{
			"ID": "20230404010557-6y6nrrz",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404010557-6y6nrrz",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1、Enhancer.create()"
				}
			]
		},
		{
			"ID": "20230404010557-sqn58o9",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-sqn58o9",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "    /**\n     * 如果必须要创建一个新类，那么就用指定的回调对象创建一个新的对象实例，使用的父类的参数的构造方法来实\t * 例化父类的部分\n     */\n    public Object create() { \n        //不作代理类限制\n        classOnly = false;\n        //没有构造参数类型\n        argumentTypes = null;\n        //执行创建\n        return createHelper();\n    }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-dnatmqb",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404010557-dnatmqb",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2、Enhancer.createHelper()"
				}
			]
		},
		{
			"ID": "20230404010557-dxijspo",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-dxijspo",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": " private Object createHelper() { \n     \t//校验callbackTypes、filter是否为空，以及为空时的处理\n        preValidate();\n     \t// 通过newInstance方法来创建EnhancerKey对象\n        Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,\n                ReflectUtils.getNames(interfaces),\n                filter == ALL_ZERO ? null : new WeakCacheKey\u003cCallbackFilter\u003e(filter),\n                callbackTypes,\n                useFactory,\n                interceptDuringConstruction,\n                serialVersionUID);\n     \t// 设置当前enhancer的代理类的key标识\n        this.currentKey = key;\n     \t// 调用父类即AbstractClassGenerator的创建代理类\n        Object result = super.create(key);\n        return result;\n    }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-al004ij",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-al004ij",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "preValidate()"
				}
			]
		},
		{
			"ID": "20230404010557-fckhe94",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-fckhe94",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": " private void preValidate() { \n        if (callbackTypes == null) { \n            //确定传入的callback类型\n            callbackTypes = CallbackInfo.determineTypes(callbacks, false);\n            validateCallbackTypes = true;\n        }\n        if (filter == null) { \n            if (callbackTypes.length \u003e 1) { \n                throw new IllegalStateException(\"Multiple callback types possible but no filter specified\");\n            }\n            filter = ALL_ZERO;\n        }\n    }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-lig8bes",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-lig8bes",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "private static final CallbackInfo[] CALLBACKS = { \n        new CallbackInfo(NoOp.class, NoOpGenerator.INSTANCE),\n        new CallbackInfo(MethodInterceptor.class, MethodInterceptorGenerator.INSTANCE),\n        new CallbackInfo(InvocationHandler.class, InvocationHandlerGenerator.INSTANCE),\n        new CallbackInfo(LazyLoader.class, LazyLoaderGenerator.INSTANCE),\n        new CallbackInfo(Dispatcher.class, DispatcherGenerator.INSTANCE),\n        new CallbackInfo(FixedValue.class, FixedValueGenerator.INSTANCE),\n        new CallbackInfo(ProxyRefDispatcher.class, DispatcherGenerator.PROXY_REF_INSTANCE),\n    };\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-iffqr6z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-iffqr6z",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 该方法主要是做验证并确定CallBack类型，我们使用的是MethodInterceptor,然后创建当前代理类的标识代理类，用这个标识代理类调用（AbstractClassGenerator）的create(key)方法创建，下面我们开始分析标识代理类创建逻辑 以及后面父类创建我们需要的代理类的逻辑。"
				}
			]
		},
		{
			"ID": "20230404010557-scdthk5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-scdthk5",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 标识代理类的创建类成员变量即KEY_FACTORY是创建代理类的核心"
				}
			]
		},
		{
			"ID": "20230404010557-l8iyt1g",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404010557-l8iyt1g",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3、标识代理类"
				}
			]
		},
		{
			"ID": "20230404010557-o302c7n",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230404010557-o302c7n",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.1、KEY_FACTORY"
				}
			]
		},
		{
			"ID": "20230404010557-guq7ohr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-guq7ohr",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 追踪源码可以看到，KEY_FACTORY在Enhancer的初始化即会创建一个final的静态变量"
				}
			]
		},
		{
			"ID": "20230404010557-onp1lg1",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-onp1lg1",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "    private static final EnhancerKey KEY_FACTORY =\n      (EnhancerKey)KeyFactory.create(EnhancerKey.class, KeyFactory.HASH_ASM_TYPE, null);\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-2gs2qbe",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230404010557-2gs2qbe",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.2、Keyfactory_create方法"
				}
			]
		},
		{
			"ID": "20230404010557-it5uolo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-it5uolo",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这儿可以看到使用key工厂创建出对应class的代理类，后面的KeyFactory_HASH_ASM_TYPE即代理类中创建HashCode方法的策略。我们接着点击源码查看"
				}
			]
		},
		{
			"ID": "20230404010557-qcb03gx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-qcb03gx",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public static KeyFactory create(ClassLoader loader, Class keyInterface, KeyFactoryCustomizer customizer,\n                                    List\u003cKeyFactoryCustomizer\u003e next) { \n        //创建一个最简易的代理类生成器 即只会生成HashCode equals toString newInstance方法\n        Generator gen = new Generator();\n        //设置接口为enhancerKey类型\n        gen.setInterface(keyInterface);\n\n        if (customizer != null) { \n            //添加定制器\n            gen.addCustomizer(customizer);\n        }\n        if (next != null \u0026\u0026 !next.isEmpty()) { \n            for (KeyFactoryCustomizer keyFactoryCustomizer : next) { \n                //添加定制器\n                gen.addCustomizer(keyFactoryCustomizer);\n            }\n        }\n        //设置生成器的类加载器\n        gen.setClassLoader(loader);\n        //生成enhancerKey的代理类\n        return gen.create();\n    }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-k71sgfl",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230404010557-k71sgfl",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.3、Generator的create方法"
				}
			]
		},
		{
			"ID": "20230404010557-da2o064",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-da2o064",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这儿创建了一个简易的代理类生成器(KeyFactory的内部类Generator ，与Enhancer一样继承自抽象类AbstractClassGenerator)来生成我们需要的标识代理类，我们接着看gen.create()方法"
				}
			]
		},
		{
			"ID": "20230404010557-ob9rwy0",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-ob9rwy0",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public KeyFactory create() { 　　　　　　　　\n    //设置了该生成器生成代理类的名字前缀，即我们的接口名Enhancer.enhancerKey\n            setNamePrefix(keyInterface.getName());\n            return (KeyFactory)super.create(keyInterface.getName());\n        }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-2oojbc8",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230404010557-2oojbc8",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.4、AbstractClassGenerator的create(Key)方法"
				}
			]
		},
		{
			"ID": "20230404010557-z1jhlun",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-z1jhlun",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "protected Object create(Object key) { \n        try { \n            //获取到当前生成器的类加载器\n            ClassLoader loader = getClassLoader();\n            //当前类加载器对应的缓存  缓存key为类加载器，缓存的value为ClassLoaderData  这个类后面会再讲\n            Map\u003cClassLoader, ClassLoaderData\u003e cache = CACHE;\n            //先从缓存中获取下当前类加载器所有加载过的类\n            ClassLoaderData data = cache.get(loader);\n            //如果为空\n            if (data == null) { \n                synchronized (AbstractClassGenerator.class) { \n                    cache = CACHE;\n                    data = cache.get(loader);\n                    //经典的防止并发修改 二次判断\n                    if (data == null) { \n                        //新建一个缓存Cache  并将之前的缓存Cache的数据添加进来 并将已经被gc回收的数据给清除掉\n                        Map\u003cClassLoader, ClassLoaderData\u003e newCache = new WeakHashMap\u003cClassLoader, ClassLoaderData\u003e(cache);\n                        //新建一个当前加载器对应的ClassLoaderData 并加到缓存中  但ClassLoaderData中此时还没有数据\n                        data = new ClassLoaderData(loader);\n                        newCache.put(loader, data);\n                        //刷新全局缓存\n                        CACHE = newCache;\n                    }\n                }\n            }\n            //设置一个全局key \n            this.key = key;\n          \n            //在刚创建的data(ClassLoaderData)中调用get方法 并将当前生成器，\n            //以及是否使用缓存的标识穿进去 系统参数 System.getProperty(\"cglib.useCache\", \"true\")  \n            //返回的是生成好的代理类的class信息\n            Object obj = data.get(this, getUseCache());\n            //如果为class则实例化class并返回  就是我们需要的代理类\n            if (obj instanceof Class) { \n                return firstInstance((Class) obj);\n            }\n            //如果不是则说明是实体  则直接执行另一个方法返回实体\n            return nextInstance(obj);\n        } catch (RuntimeException e) { \n            throw e;\n        } catch (Error e) { \n            throw e;\n        } catch (Exception e) { \n            throw new CodeGenerationException(e);\n        }\n    }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-w2cy2k1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-w2cy2k1",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 这个方法可以看到主要为根据类加载器定义一个缓存，里面装载了缓存的类信息，然后调用这个ClassLoaderData的get方法获取到数据，如果为class信息 那么直接使用反射实例化，如果返回的是实体类，则解析实体类的信息，调用其newInstance方法重新生成一个实例(cglib的代理类都会生成newInstance方法)"
				}
			]
		},
		{
			"ID": "20230404010557-el81xir",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230404010557-el81xir",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.5、data.get(this,getUseCache)"
				}
			]
		},
		{
			"ID": "20230404010557-sgytc2k",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-sgytc2k",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public Object get(AbstractClassGenerator gen, boolean useCache) { \n            //如果不用缓存  (默认使用)\n            if (!useCache) { \n                //则直接调用生成器的命令\n              return gen.generate(ClassLoaderData.this);\n            } else { \n              //从缓存中获取值\n              Object cachedValue = generatedClasses.get(gen);\n              //解包装并返回\n              return gen.unwrapCachedValue(cachedValue);\n            }\n        }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-8bvgmqg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-8bvgmqg",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 如果可以用缓存则调用缓存，不能调用缓存则直接生成， 这儿我们先看调用缓存的，在之前的步骤中，我们设置了一个key为ClassLoader，值为ClassLoaderData的缓存，这儿我们new了一个ClassLoaderData 并将类加载器传了进去 ，并且设置了这个Generator的key，我们看下new的逻辑"
				}
			]
		},
		{
			"ID": "20230404010557-uaxycqe",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-uaxycqe",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public ClassLoaderData(ClassLoader classLoader) { \n            //判断类加载器不能为空 \n            if (classLoader == null) { \n                throw new IllegalArgumentException(\"classLoader == null is not yet supported\");\n            }\n            //设置类加载器   弱引用 即在下次垃圾回收时就会进行回收\n            this.classLoader = new WeakReference\u003cClassLoader\u003e(classLoader);\n            //新建一个回调函数  这个回调函数的作用在于缓存中没获取到值时  调用传入的生成的生成代理类并返回\n            Function\u003cAbstractClassGenerator, Object\u003e load =\n                    new Function\u003cAbstractClassGenerator, Object\u003e() { \n                        public Object apply(AbstractClassGenerator gen) { \n                            Class klass = gen.generate(ClassLoaderData.this);\n                            return gen.wrapCachedClass(klass);\n                        }\n                    };\n            //为这个ClassLoadData新建一个缓存类   这个loadingcache稍后会讲      \n            generatedClasses = new LoadingCache\u003cAbstractClassGenerator, Object, Object\u003e(GET_KEY, load);\n        }\n      \n      \n private static final Function\u003cAbstractClassGenerator, Object\u003e GET_KEY = new Function\u003cAbstractClassGenerator, Object\u003e() { \n     public Object apply(AbstractClassGenerator gen) { \n         return gen.key;\n     }\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-23c3xj4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-23c3xj4",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 可以看到每个类加载器都对应着一个代理类缓存对象 ，这里面定义了类加载器，缓存调用没查询到的调用函数，以及新建了一个LoadingCache来缓存这个类加载器对应的缓存，这儿传入的两个参数，load代表缓存查询失败时的回调函数，而GET_KEY则是回调时获取调用生成器的key 即4中传入的key 也即是我们的代理类标识符。 然后我们接着看generatedClasses.get(gen);的方法"
				}
			]
		},
		{
			"ID": "20230404010557-d5b3hdw",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230404010557-d5b3hdw",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.6、generatedClasses.get(gen);"
				}
			]
		},
		{
			"ID": "20230404010557-2losgpc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-2losgpc",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 这个方法主要传入代理类生成器 并根据代理类生成器获取值返回。这儿主要涉及到的类就是LoadingCache，这个类可以看做是某个CLassLoader对应的所有代理类缓存库，是真正缓存东西的地方。我们分析下这个类"
				}
			]
		},
		{
			"ID": "20230404010557-p6o8xyu",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-p6o8xyu",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class LoadingCache\u003cK, KK, V\u003e { \n    protected final ConcurrentMap\u003cKK, Object\u003e map;\n    protected final Function\u003cK, V\u003e loader;\n    protected final Function\u003cK, KK\u003e keyMapper;\n\n    public static final Function IDENTITY = new Function() { \n        public Object apply(Object key) { \n            return key;\n        }\n    };\n    //初始化类  kemapper代表获取某个代理类生成器的标识，loader即缓存查找失败后的回调函数\n    public LoadingCache(Function\u003cK, KK\u003e keyMapper, Function\u003cK, V\u003e loader) { \n        this.keyMapper = keyMapper;\n        this.loader = loader;\n        //这个map是缓存代理类的地方\n        this.map = new ConcurrentHashMap\u003cKK, Object\u003e();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static \u003cK\u003e Function\u003cK, K\u003e identity() { \n        return IDENTITY;\n    }\n    //这儿key是代理类生成器\n    public V get(K key) { \n        //获取到代理类生成器的标识\n        final KK cacheKey = keyMapper.apply(key);\n        //根据缓代理类生成器的标识获取代理类\n        Object v = map.get(cacheKey);\n        //如果结果不为空且不是FutureTask 即线程池中用于获取返回结果的接口\n        if (v != null \u0026\u0026 !(v instanceof FutureTask)) { \n            //直接返回\n            return (V) v;\n        }\n        //否则就是没查询到  或者还未处理完\n        return createEntry(key, cacheKey, v);\n    }\n\n    protected V createEntry(final K key, KK cacheKey, Object v) { \n        //初始化任务task\n        FutureTask\u003cV\u003e task;\n        //初始化创建标识\n        boolean creator = false;\n        if (v != null) { \n            // 则说明这是一个FutureTask \n            task = (FutureTask\u003cV\u003e) v;\n        } else { \n            //否则还没开始创建这个代理类  直接创建任务  \n            task = new FutureTask\u003cV\u003e(new Callable\u003cV\u003e() { \n                public V call() throws Exception { \n                    //这儿会直接调用生成器的generate方法\n                    return loader.apply(key);\n                }\n            });\n            //将这个任务推入缓存Map  如果对应key已经有则返回已经有的task，\n            Object prevTask = map.putIfAbsent(cacheKey, task);\n            //如果为null则代表还没有创建  标识更新为true 且运行这个任务\n            if (prevTask == null) { \n                // creator does the load\n                creator = true;\n                task.run();\n            } \n            //如果是task  说明另一个线程已经创建了task\n            else if (prevTask instanceof FutureTask) { \n                task = (FutureTask\u003cV\u003e) prevTask;\n            } \n            //到这儿说明另一个线程已经执行完了  直接返回\n            else { \n                return (V) prevTask;\n            }\n          \n            //上面的一堆判断主要是为了防止并发出现的问题\n        }\n      \n        V result;\n        try { \n            //到这儿说明任务执行完并拿到对应的代理类了\n            result = task.get();\n        } catch (InterruptedException e) { \n            throw new IllegalStateException(\"Interrupted while loading cache item\", e);\n        } catch (ExecutionException e) { \n            Throwable cause = e.getCause();\n            if (cause instanceof RuntimeException) { \n                throw ((RuntimeException) cause);\n            }\n            throw new IllegalStateException(\"Unable to load cache item\", cause);\n        }\n        //如果这次执行是新建的\n        if (creator) { \n            //将之前的FutureTask缓存直接覆盖为实际的代理类信息\n            map.put(cacheKey, result);\n        }\n        //返回结果\n        return result;\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-holw0x3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-holw0x3",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通过上面的分析可以得知，这个类主要作用是传入代理类生成器，根据这个代理类生成器以及代理类生成器的key来获取缓存，如果没有获取到则构建一个FutureTask来回调我们之前初始化时传入的 回调函数，并调用其中的apply方法，而具体调用的则是我们传入的代理类生成器的generate(LoadClassData)方法，将返回值覆盖之前的FutureTask成为真正的缓存。所以这个类的主要作用还是缓存。 这样则和5中不使用缓存时调用了一样的方法。所以我们接着来分析生成方法 generate(ClassLoadData),这儿因为我们使用的代理类生成器是Genrator，该类没有重写generate方法，所以回到了父类AbstractClassGenerator的generate方法"
				}
			]
		},
		{
			"ID": "20230404010557-djw3bsb",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230404010557-djw3bsb",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.7、AbstractClassGenerator.generate 方法"
				}
			]
		},
		{
			"ID": "20230404010557-zi4xtqm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-zi4xtqm",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "protected Class generate(ClassLoaderData data) { \n        Class gen;\n        Object save = CURRENT.get();\n        //当前的代理类生成器存入ThreadLocal中\n        CURRENT.set(this);\n        try { \n            //获取到ClassLoader\n            ClassLoader classLoader = data.getClassLoader();\n            //判断不能为空\n            if (classLoader == null) { \n                throw new IllegalStateException(\"ClassLoader is null while trying to define class \" +\n                        getClassName() + \". It seems that the loader has been expired from a weak reference somehow. \" +\n                        \"Please file an issue at cglib's issue tracker.\");\n            }\n            synchronized (classLoader) { \n             //生成代理类名字\n              String name = generateClassName(data.getUniqueNamePredicate()); \n             //缓存中存入这个名字\n              data.reserveName(name);\n              //当前代理类生成器设置类名\n              this.setClassName(name);\n            }\n            //尝试从缓存中获取类\n            if (attemptLoad) { \n                try { \n                    //要是能获取到就直接返回了  即可能出现并发 其他线程已经加载\n                    gen = classLoader.loadClass(getClassName());\n                    return gen;\n                } catch (ClassNotFoundException e) { \n                    // 发现异常说明没加载到 不管了\n                }\n            }\n            //生成字节码\n            byte[] b = strategy.generate(this);\n            //获取到字节码代表的class的名字\n            String className = ClassNameReader.getClassName(new ClassReader(b));\n            //核实是否为protect\n            ProtectionDomain protectionDomain = getProtectionDomain();\n            synchronized (classLoader) {  // just in case\n                //如果不是protect\n                if (protectionDomain == null) { \n                    //根据字节码 类加载器 以及类名字  将class加载到内存中\n                    gen = ReflectUtils.defineClass(className, b, classLoader);\n                } else { \n                    //根据字节码 类加载器 以及类名字 以及找到的Protect级别的实体 将class加载到内存中\n                    gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);\n                }\n            }\n　　　　　　　 //返回生成的class信息\n            return gen;\n        } catch (RuntimeException e) { \n            throw e;\n        } catch (Error e) { \n            throw e;\n        } catch (Exception e) { \n            throw new CodeGenerationException(e);\n        } finally { \n            CURRENT.set(save);\n        }\n    }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-hwxpkqm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-hwxpkqm",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 这个方法主要设置了下当前类生成器的类名，然后调用stratege的generate方法返回字节码，根据字节码 类名 类加载器将字节码所代表的类加载到内存中，这个功能看一下大概就懂，我们接下来主要分析字节码生成方法"
				}
			]
		},
		{
			"ID": "20230404010557-6ixfp2z",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230404010557-6ixfp2z",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.8、DefaultGeneratorStrategy.generate(ClassGenerator cg)"
				}
			]
		},
		{
			"ID": "20230404010557-rezg6eu",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-rezg6eu",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public byte[] generate(ClassGenerator cg) throws Exception { \n        //创建一个写入器\n        DebuggingClassWriter cw = getClassVisitor();\n        //加入自己的转换逻辑后执行代理类生成器的generateClass方法\n        transform(cg).generateClass(cw);\n        //将cw写入的东西转换为byte数组返回\n        return transform(cw.toByteArray());\n    }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-9nxhcqj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-9nxhcqj",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 这里面主要是新建一个写入器，然后执行我们代理类生成器的generateClass方法将class信息写入这个ClassWriter 最后将里面的东西转换为byte数组返回，所以又回到了我们的代理类生成器的generateClass方法，这儿进入的是Generator的generateClass方法"
				}
			]
		},
		{
			"ID": "20230404010557-mkj46na",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230404010557-mkj46na",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.9、Generator.generateClass（ClassVisitor v）"
				}
			]
		},
		{
			"ID": "20230404010557-qwtilik",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-qwtilik",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//该方法为字节码写入方法 为最后一步\n public void generateClass(ClassVisitor v) { \n            //创建类写入聚合对象\n            ClassEmitter ce = new ClassEmitter(v);\n            //找到被代理类的newInstance方法 如果没有会报异常  由此可知 如果想用Generator代理类生成器  必须要有newInstance方法\n            Method newInstance = ReflectUtils.findNewInstance(keyInterface);\n            //如果被代理类的newInstance不为Object则报异常  此处我们代理的Enchaer.EnhancerKey newInstance方法返回值为Object\n            if (!newInstance.getReturnType().equals(Object.class)) { \n                throw new IllegalArgumentException(\"newInstance method must return Object\");\n            }\n            //找到newInstance方法的所有参数类型 并当做成员变量 \n            Type[] parameterTypes = TypeUtils.getTypes(newInstance.getParameterTypes());\n          \n            //1.创建类开始写入类头   版本号  访问权限  类名等通用信息\n            ce.begin_class(Constants.V1_8,\n                           Constants.ACC_PUBLIC,\n                           getClassName(), \n                           KEY_FACTORY,\n                           new Type[]{  Type.getType(keyInterface) },\n                           Constants.SOURCE_FILE);\n            //2.写入无参构造方法             \n            EmitUtils.null_constructor(ce);\n            //3.写入newInstance方法\n            EmitUtils.factory_method(ce, ReflectUtils.getSignature(newInstance));\n          \n            int seed = 0;\n            //4.开始构造 有参构造方法\n            CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC,\n                                            TypeUtils.parseConstructor(parameterTypes),\n                                            null);\n            e.load_this();\n            //4.1有参构造中调用父类构造方法  即super.构造方法() \n            e.super_invoke_constructor();\n            e.load_this();\n            //4.2找到传入的定制器 例如一开始传入的hashCode方法定制器\n            List\u003cFieldTypeCustomizer\u003e fieldTypeCustomizers = getCustomizers(FieldTypeCustomizer.class);\n            //4.3遍历成员变量即newInstance方法的所有参数\n            for (int i = 0; i \u003c parameterTypes.length; i++) { \n                Type parameterType = parameterTypes[i];\n                Type fieldType = parameterType;\n                for (FieldTypeCustomizer customizer : fieldTypeCustomizers) { \n                    fieldType = customizer.getOutType(i, fieldType);\n                }\n                seed += fieldType.hashCode();\n                //4.3将这些参数全部声明到写入类中\n                ce.declare_field(Constants.ACC_PRIVATE | Constants.ACC_FINAL,\n                                 getFieldName(i),\n                                 fieldType,\n                                 null);\n                e.dup();\n                e.load_arg(i);\n                for (FieldTypeCustomizer customizer : fieldTypeCustomizers) { \n                    customizer.customize(e, i, parameterType);\n                }\n                //4.4设置每个成员变量的值  即我们常见的有参构造中的this.xx = xx\n                e.putfield(getFieldName(i));\n            }\n            //设置返回值\n            e.return_value();\n            //有参构造及成员变量写入完成\n            e.end_method();\n          \n            /*************************到此已经在class中写入了成员变量  写入实现了newInstance方法  写入无参构造  写入了有参构造 *************************/\n          \n            // 5.写入hashcode方法\n            e = ce.begin_method(Constants.ACC_PUBLIC, HASH_CODE, null);\n            int hc = (constant != 0) ? constant : PRIMES[(int)(Math.abs(seed) % PRIMES.length)];\n            int hm = (multiplier != 0) ? multiplier : PRIMES[(int)(Math.abs(seed * 13) % PRIMES.length)];\n            e.push(hc);\n            for (int i = 0; i \u003c parameterTypes.length; i++) { \n                e.load_this();\n                e.getfield(getFieldName(i));\n                EmitUtils.hash_code(e, parameterTypes[i], hm, customizers);\n            }\n            e.return_value();\n            //hashcode方法结束\n            e.end_method();\n\n            // 6.写入equals方法\n            e = ce.begin_method(Constants.ACC_PUBLIC, EQUALS, null);\n            Label fail = e.make_label();\n            e.load_arg(0);\n            e.instance_of_this();\n            e.if_jump(e.EQ, fail);\n            for (int i = 0; i \u003c parameterTypes.length; i++) { \n                e.load_this();\n                e.getfield(getFieldName(i));\n                e.load_arg(0);\n                e.checkcast_this();\n                e.getfield(getFieldName(i));\n                EmitUtils.not_equals(e, parameterTypes[i], fail, customizers);\n            }\n            e.push(1);\n            e.return_value();\n            e.mark(fail);\n            e.push(0);\n            e.return_value();\n            //equals方法结束\n            e.end_method();\n\n            // 7.写入toString方法\n            e = ce.begin_method(Constants.ACC_PUBLIC, TO_STRING, null);\n            e.new_instance(Constants.TYPE_STRING_BUFFER);\n            e.dup();\n            e.invoke_constructor(Constants.TYPE_STRING_BUFFER);\n            for (int i = 0; i \u003c parameterTypes.length; i++) { \n                if (i \u003e 0) { \n                    e.push(\", \");\n                    e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n                }\n                e.load_this();\n                e.getfield(getFieldName(i));\n                EmitUtils.append_string(e, parameterTypes[i], EmitUtils.DEFAULT_DELIMITERS, customizers);\n            }\n            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, TO_STRING);\n            e.return_value();\n            //toString方法结束\n            e.end_method();\n            //类写入结束  至此类信息收集完成 并全部写入ClassVisitor\n            ce.end_class();\n        }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-gfpmq5y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-gfpmq5y",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 这个方法主要将一个完整的类信息写入ClassVisitor中，例如目前实现的Enhancer.EnhancerKey代理，即实现了newInstance方法， 重写了HashCode,toSting,equals方法，并将newInstance的所有参数作为了成员变量，这儿我们也可以看下具体实现newInstance方法的逻辑 即这个代码 EmitUtils.factory_method(ce, ReflectUtils.getSignature(newInstance)); 如果有兴趣可以去研究asm字节码写入的操作"
				}
			]
		},
		{
			"ID": "20230404010557-e9f255r",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-e9f255r",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public static void factory_method(ClassEmitter ce, Signature sig) \n    { \n        //开始写入方法\n        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);\n        //写入 一个创建对象命令  即new命令\n        e.new_instance_this();\n        e.dup();\n        //加载参数命令\n        e.load_args();\n        //执行该类的有参构造命令\n        e.invoke_constructor_this(TypeUtils.parseConstructor(sig.getArgumentTypes()));\n        //将上面指令执行的值返回\n        e.return_value();\n        //结束写入方法\n        e.end_method();\n    }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-h8agmbr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-h8agmbr",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 可以得知 我们通过Generator创建的代理类大致内容应该如下，Enhancer.EhancerKey代理类字节码的class内容应该是把参数换为newInstance中的参数"
				}
			]
		},
		{
			"ID": "20230404010557-qwi766f",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-qwi766f",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class EnhancerKeyProxy extends xxx implements xxx{ \n\n private paramA;\n private paramB;\n private paramC;\n \n public EnhancerKeyProxy() { \n         super.xxx();\n }\n public EnhancerKeyProxy(paramA, paramB,paramC) { \n       super.xxx();\n       this.paramA = paramA\n       this.paramB = paramB\n       this.paramC = paramC\n    }\n\n public Object newInstance(paramA,paramB,paramC){ \n        EnhancerKeyProxy param = new EnhancerKeyProxy(o);\n        return param;\n }\n \n  public int hashCode(){ \n      ...\n  }\n   public String toString(){ \n      ...\n  }\n  \n  public boolean equals(Object o){ \n      ...\n  }\n\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-cqueo79",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-cqueo79",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 最后执行传入的ClassVisitor 即我们传入的实例DebuggingClassWriter的toByteArray即可以将写入的内容转换为byte[]返回"
				}
			]
		},
		{
			"ID": "20230404010557-0yaciwy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-0yaciwy",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 至此 我们的成功的生成了Enhancer.EnhancerKey的代理类，也就是我们需要的代理类标识类 用来标识被代理的类，这个代理类主要用来作为被代理类的标识，在进行缓存时作为判断相等的依据。可以看到 cglib代理主要也是利用我们传入的被代理类信息来生成对应的代理类字节码，然后用类加载器加载到内存中。虽然我们的实际的代理任务才刚刚开始，但是要了解的东西已经基本上差不多了，对具体的我们案例中的ProxyFactory代理时，只是生成器Enhancer对比生成器Generator在生成过程中重写了一些操作而已。"
				}
			]
		},
		{
			"ID": "20230404010557-61rozma",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404010557-61rozma",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4、回到步骤2，接着向下看执行的过程"
				}
			]
		},
		{
			"ID": "20230404010557-hxi0zqc",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-hxi0zqc",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "private Object createHelper() { \n        preValidate();\n        //获取到了代理类标识类\n        Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,\n                ReflectUtils.getNames(interfaces),\n                filter == ALL_ZERO ? null : new WeakCacheKey\u003cCallbackFilter\u003e(filter),\n                callbackTypes,\n                useFactory,\n                interceptDuringConstruction,\n                serialVersionUID);\n        //设置当前enhancer正在代理生成的类信息\n        this.currentKey = key;\n        //调用父类的create(key方法)\n        Object result = super.create(key);\n        return result;\n    }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-s96z8ew",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-s96z8ew",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 可以看到获取到代理类标志类后 将其设置为当前代理类生成器的正在代理的类 并同样调用父类AbstractClassGenerator中create(key)的方法,下面开始分析Ehancer生成器的逻辑，由于部分逻辑和Generator生成器一致"
				}
			]
		},
		{
			"ID": "20230404010557-lq6q8rr",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404010557-lq6q8rr",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "5、AbstractClassGenerator.create方法"
				}
			]
		},
		{
			"ID": "20230404010557-obqsjxc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-obqsjxc",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 这个逻辑和上述步骤一致，查询当前key即代理类标志类对应的ClassLoadData缓存，如果没有则建一个空的缓存并初始化一个对应的ClassLoadData,传入相应的生成器，生成失败回调函数等"
				}
			]
		},
		{
			"ID": "20230404010557-p0dk82m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-p0dk82m",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "按照同样的逻辑一直走到generate(ClassLoadData)方法时，由于Enhancer生成器重写了这个方法 所以我们分析Enahncer的生成逻辑"
				}
			]
		},
		{
			"ID": "20230404010557-z6sn675",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404010557-z6sn675",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "6、Enhancer.generate(ClassLoadData data)"
				}
			]
		},
		{
			"ID": "20230404010557-8gqbymz",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-8gqbymz",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Override\n    protected Class generate(ClassLoaderData data) { \n        validate();\n        if (superclass != null) { \n            setNamePrefix(superclass.getName());\n        } else if (interfaces != null) { \n            setNamePrefix(interfaces[ReflectUtils.findPackageProtected(interfaces)].getName());\n        }\n        return super.generate(data);\n    }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-ztjxdtf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-ztjxdtf",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 可以发现ehancer生成器只是做了个检查命名操作 在上面的Generator中也是做了个命名操作，然后继续执行父类的generate(data)方法，这个和上述步骤一致，我们主要看其中生成字节码的方法，即最后调用的Enhancer.generatorClass(ClassVisitor c)方法，"
				}
			]
		},
		{
			"ID": "20230404010557-38r0j8z",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404010557-38r0j8z",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "7、Enhancer.generatorClass(ClassVisitor c)"
				}
			]
		},
		{
			"ID": "20230404010557-e71td3m",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404010557-e71td3m",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public void generateClass(ClassVisitor v) throws Exception { \n        //声明需代理的类 或者接口\n        Class sc = (superclass == null) ? Object.class : superclass;\n        //检查 final类无法被继承\n        if (TypeUtils.isFinal(sc.getModifiers()))\n            throw new IllegalArgumentException(\"Cannot subclass final class \" + sc.getName());\n        //找到该类所有声明了的构造函数\n        List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));\n        //去掉private之类的不能被继承的构造函数\n        filterConstructors(sc, constructors);\n\n        // Order is very important: must add superclass, then\n        // its superclass chain, then each interface and\n        // its superinterfaces.\n        //这儿顺序非常重要  上面是源码的注释  直接留着  相信大家都能看懂 \n      \n        //声明代理类方法集合\n        List actualMethods = new ArrayList();\n        //声明代理接口接口方法集合\n        List interfaceMethods = new ArrayList();\n        //声明所有必须为public的方法集合  这儿主要是代理接口接口的方法\n        final Set forcePublic = new HashSet();\n        //即通过传入的代理类 代理接口，遍历所有的方法并放入对应的集合\n        getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);\n      \n        //对所有代理类方法修饰符做处理 \n        List methods = CollectionUtils.transform(actualMethods, new Transformer() { \n            public Object transform(Object value) { \n                Method method = (Method)value;\n                int modifiers = Constants.ACC_FINAL\n                    | (method.getModifiers()\n                       \u0026 ~Constants.ACC_ABSTRACT\n                       \u0026 ~Constants.ACC_NATIVE\n                       \u0026 ~Constants.ACC_SYNCHRONIZED);\n                if (forcePublic.contains(MethodWrapper.create(method))) { \n                    modifiers = (modifiers \u0026 ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;\n                }\n                return ReflectUtils.getMethodInfo(method, modifiers);\n            }\n        });\n        //创建类写入器\n        ClassEmitter e = new ClassEmitter(v);\n      \n        //1.开始创建类  并写入基本信息  如java版本，类修饰符 类名等\n        if (currentData == null) { \n        e.begin_class(Constants.V1_8,\n                      Constants.ACC_PUBLIC,\n                      getClassName(),\n                      Type.getType(sc),\n                      (useFactory ?\n                       TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :\n                       TypeUtils.getTypes(interfaces)),\n                      Constants.SOURCE_FILE);\n        } else { \n            e.begin_class(Constants.V1_8,\n                    Constants.ACC_PUBLIC,\n                    getClassName(),\n                    null,\n                    new Type[]{ FACTORY},\n                    Constants.SOURCE_FILE);\n        }\n        List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());\n        //2. 声明一个private boolean 类型的属性：CGLIB$BOUND\n        e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null);\n        //3. 声明一个public static Object 类型的属性：CGLIB$FACTORY_DATA\n        e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, null);\n        // 这个默认为true  如果为false则会声明一个private boolean 类型的属性：CGLIB$CONSTRUCTED\n        if (!interceptDuringConstruction) { \n            e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, null);\n        }\n        //4. 声明一个public static final 的ThreadLocal：ThreadLocal\n        e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\n        //5. 声明一个public static final 的CallBack类型的数组：CGLIB$STATIC_CALLBACKS\n        e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null);\n        //如果serialVersionUID不为null  则设置一个public static final 的Long类型 serialVersionUID\n        if (serialVersionUID != null) { \n            e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);\n        }\n      \n        //遍历CallBackTypes 即我们构建Enhancer是setCallBack的所有类的类型  本案例中是methodInterceptor 并且只传入了一个\n        for (int i = 0; i \u003c callbackTypes.length; i++) { \n            //6.声明一个private 的传入的CallBack类型的属性：CGLIB$CALLBACK_0 (从0开始编号，)\n            e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null);\n        }\n        //7声明一个private static 的传入的Object类型的属性：CGLIB$CALLBACK_FILTER\n        e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, null);\n      \n        //判断currentData\n        if (currentData == null) { \n            //8.为null则开始声明所有的代理类方法的变量 以及其具体的重写实现方法，还有static初始化执行代码块\n            emitMethods(e, methods, actualMethods);\n            //9.声明构造函数\n            emitConstructors(e, constructorInfo);\n        } else { \n            //声明默认构造函数\n            emitDefaultConstructor(e);\n        }\n        //\n        emitSetThreadCallbacks(e);\n        emitSetStaticCallbacks(e);\n        emitBindCallbacks(e);\n        //如果currentData不为null\n        if (useFactory || currentData != null) { \n            //获取到所有CallBack索引数组\n            int[] keys = getCallbackKeys();\n            //10.声明三个newInstance方法\n            //只有一个callback参数\n            emitNewInstanceCallbacks(e);\n            //参数为callback数组\n            emitNewInstanceCallback(e);\n            //参数为callback数组 以及附带的一些参数\n            emitNewInstanceMultiarg(e, constructorInfo);\n            //11.声明getCallBack方法\n            emitGetCallback(e, keys);\n            //12.声明setCallBack方法\n            emitSetCallback(e, keys);\n            //12.声明setCallBacks方法\n            emitGetCallbacks(e);\n            //12.声明setCallBacks方法\n            emitSetCallbacks(e);\n        }\n        //类声明结束\n        e.end_class();\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404010557-d02zyhr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404010557-d02zyhr",
				"updated": "20230404010557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​ 可以看到这儿也是声明一个写入类 然后按照Ehancer的代理生成策略写入符合的class信息然后返回，最红依旧会执行toByteArray方法返回byte[]数组，这样则又回到了步骤中 根据类加载器 字节码数组来动态将代理类加载进内存中的方法了。最后我们回到根据class获取实例的代码即可返回被代理实例。 而我们执行方法时执行的是代理类中对应的方法，然后调用我们传入的callback执行 原理和jdk动态代理类似，至此 cglib动态代理源码分析到此结束。"
				}
			]
		}
	]
}