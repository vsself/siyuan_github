{
	"ID": "20230328232810-m16tkeq",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230328232810-m16tkeq",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20230328232916-e5ez34d\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230329004907-vuy2v8t\u0026quot;,\u0026quot;scrollTop\u0026quot;:5616,\u0026quot;focusId\u0026quot;:\u0026quot;20230328233946-2wz92e3\u0026quot;,\u0026quot;focusStart\u0026quot;:72,\u0026quot;focusEnd\u0026quot;:106}",
		"title": "3. Spring Bean populateBean",
		"updated": "20230329004907"
	},
	"Children": [
		{
			"ID": "20230328232916-e5ez34d",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230328232916-e5ez34d",
				"updated": "20230328232916"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "前言"
				}
			]
		},
		{
			"ID": "20230328232950-n7zlhje",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328232950-n7zlhje",
				"updated": "20230328233037"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上一篇文章"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref",
					"TextMarkBlockRefID": "20230328173958-llgoycm",
					"TextMarkBlockRefSubtype": "d",
					"TextMarkTextContent": "2. Spring Bean实例化"
				},
				{
					"Type": "NodeText",
					"Data": "中完成了bean的实例化过程 ，但是属性内容还没有注入，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "本文就是将bean的属性进行注入的过程"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20230328233153-f7nhkxw",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230328233153-f7nhkxw",
				"updated": "20230328233153"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一、populateBean - 概述"
				}
			]
		},
		{
			"ID": "20230328233213-xwevnhz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328233213-xwevnhz",
				"updated": "20230328233213"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们这里先整体过一遍代码，后面进行每一步的详细解读。"
				}
			]
		},
		{
			"ID": "20230328233213-n9tqk2x",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328233213-n9tqk2x",
				"updated": "20230329000156"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// AbstractAutowireCapableBeanFactory#populateBean\n\t// beanName : bean 的name\n\t// mbd  :  bean的定义信息\n\t// bw  : bean实例的包装类型，里面有bean的实例\n\tprotected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n\t\tif (bw == null) {\n\t\t\t //没有属性抛出异常\n\t\t\tif (mbd.hasPropertyValues()) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Skip property population phase for null instance.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n\t\t// state of the bean before properties are set. This can be used, for example,\n\t\t// to support styles of field injection.\n\t\t//\n\t\tboolean continueWithPropertyPopulation = true;\n         //mbd.isSynthetic() 合成类\n\t\t//todo 第五次---判断属性是否填充：InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation\n\t\t// 给InstantiationAwareBeanPostProcessor最后一次机会在属性设置前来改变bean\n\t\tif (!mbd.isSynthetic() \u0026\u0026 hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (BeanPostProcessor bp : getBeanPostProcessors()) {\n\t\t\t\tif (bp instanceof InstantiationAwareBeanPostProcessor) {\n\t\t\t\t\tInstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n\t\t\t\t\tif (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n\t\t\t\t\t\tcontinueWithPropertyPopulation = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\tif (!continueWithPropertyPopulation) {\n\t\t\treturn;\n\t\t}\n\t\t//获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值\n\t\t//这个是程序员在 bd中 写入的属性rootBeanDefinition.getPropertyValues().add(\"type\",\"男的\");\n\t\tPropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);\n \n\t\t 2. 自动装配 ：autowiring自动装配的。根据名称或类型自动注入\n\t\tif (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n\t\t\t\tmbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n \n \n\t\t\tMutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n \n\t\t\t// Add property values based on autowire by name if applicable.\n\t\t\t//根据Bean名称进行autowiring自动装配处理\n\t\t\tif (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n\t\t\t\tautowireByName(beanName, mbd, bw, newPvs);\n\t\t\t}\n \n\t\t\t// Add property values based on autowire by type if applicable.\n\t\t\t//根据Bean类型进行autowiring自动装配处理\n\t\t\tif (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n\t\t\t\tautowireByType(beanName, mbd, bw, newPvs);\n\t\t\t}\n \n\t\t\tpvs = newPvs;\n\t\t}\n\t\t//对非autowiring的属性进行依赖注入处理\n\t\t// 后处理器已经初始化\n\t\tboolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n\t\tboolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n \n\t\tif (hasInstAwareBpps || needsDepCheck) {\n\t\t\tif (pvs == null) {\n\t\t\t\tpvs = mbd.getPropertyValues();\n\t\t\t}\n\t\t\tPropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n\t\t\tif (hasInstAwareBpps) {\n\t\t\t\t//TODO 获取的bean所有后置处理器找到 所有需要注入的属性\n\t\t\t\t// 这里会进行 @Autowired 和 @Resource 的注入工作\n\t\t\t\t// 属性填充InstantiationAwareBeanPostProcessor\n\t\t\t\tfor (BeanPostProcessor bp : getBeanPostProcessors()) {\n\t\t\t\t\tif (bp instanceof InstantiationAwareBeanPostProcessor) {\n\t\t\t\t\t\tInstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n\t\t\t\t\t\t//下面是完成属性注入的\n\t\t\t\t\t\tpvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n\t\t\t\t\t\t// 如果postProcessProperties 返回null，再调用 postProcessPropertyValues这个过时的方法\n\t\t\t\t\t\tif (pvs == null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (needsDepCheck) {\n\t\t\t\t// 依赖检查，对应 depends-on 属性，3.0 已弃用\n\t\t\t\tcheckDependencies(beanName, mbd, filteredPds, pvs);\n\t\t\t}\n\t\t}\n\t\tif (pvs != null) {\n\t\t\t 4. 将属性应用到bean中\n\t\t\tapplyPropertyValues(beanName, mbd, bw, pvs);\n\t\t}\n\t}\n————————————————\n版权声明：本文为CSDN博主「大龄码农生活」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_36697880/article/details/113854056\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328233230-xzq7q3o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328233230-xzq7q3o",
				"updated": "20230328233235"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "从上看下来，整个流程如下："
				}
			]
		},
		{
			"ID": "20230328233245-afuwnlk",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230328233245-afuwnlk",
				"updated": "20230328233522"
			},
			"Children": [
				{
					"ID": "20230328233513-x17jhyo",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230328233513-x17jhyo",
						"updated": "20230328233513"
					},
					"Children": [
						{
							"ID": "20230328233513-junj58r",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328233513-junj58r",
								"updated": "20230328233513"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation 方法，可以决定程序是否继续进行属性填充。只要有一个 InstantiationAwareBeanPostProcessor 返回false，都会终止属性填充的过程。这个过程属于实例化 后置阶段上上文已经描述过了\n"
								}
							]
						}
					]
				},
				{
					"ID": "20230328233516-2lzgf6c",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230328233516-2lzgf6c"
					},
					"Children": [
						{
							"ID": "20230328233516-pdujg89",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328233516-pdujg89"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "自动装配 ：autowiring自动装配的。根据注入类型（name或type），提取依赖的bean，并统一存入到 propertyValues 中。\n"
								}
							]
						}
					]
				},
				{
					"ID": "20230328233519-3w9lhd5",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230328233519-3w9lhd5",
						"updated": "20230328233522"
					},
					"Children": [
						{
							"ID": "20230328233519-8r8w6p6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328233519-8r8w6p6",
								"updated": "20230328233522"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "@Autowired 和 @Resource 的属性注入工作，调用后置处理器应用 InstantiationAwareBeanPostProcessor#postProcessProperties 方法，对属性获取完毕填充前对属性的再次处理。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230328233557-4dpd0dj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328233557-4dpd0dj",
				"updated": "20230328233606"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "有两个实现类型 ："
				}
			]
		},
		{
			"ID": "20230328233611-kczi3v0",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230328233611-kczi3v0",
				"updated": "20230328233619"
			},
			"Children": [
				{
					"ID": "20230328233619-w5povxi",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230328233619-w5povxi",
						"updated": "20230328233619"
					},
					"Children": [
						{
							"ID": "20230328233619-uv23f4b",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328233619-uv23f4b",
								"updated": "20230328233619"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "AutowiredAnnotationBeanPostProcessor 中的实现类 处理 @Autowired 注解的"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230328233557-sdwir3g",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230328233557-sdwir3g",
				"updated": "20230328233621"
			},
			"Children": [
				{
					"ID": "20230328233616-9940ias",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230328233616-9940ias",
						"updated": "20230328233621"
					},
					"Children": [
						{
							"ID": "20230328233616-7upbacg",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328233616-7upbacg",
								"updated": "20230328233621"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "AutowiredAnnotationBeanPostProcessor 中的实现类 处理 @Autowired 注解的"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230328233644-k8c1ufv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328233644-k8c1ufv",
				"updated": "20230328233645"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "将所有 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "propertyValues"
				},
				{
					"Type": "NodeText",
					"Data": "​ 中的属性填充至 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "BeanWrapper"
				},
				{
					"Type": "NodeText",
					"Data": "​ 中。"
				}
			]
		},
		{
			"ID": "20230328233647-bqhmaf9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328233647-bqhmaf9",
				"updated": "20230328233652"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "在这里方法里按照如下顺序调用了后处理器"
				}
			]
		},
		{
			"ID": "20230328233654-cmh4w0x",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230328233654-cmh4w0x",
				"updated": "20230328233708"
			},
			"Children": [
				{
					"ID": "20230328233708-3di8j31",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230328233708-3di8j31",
						"updated": "20230328233708"
					},
					"Children": [
						{
							"ID": "20230328233708-drakfny",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328233708-drakfny",
								"updated": "20230328233708"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation ： 是否使用 InstantiationAwareBeanPostProcessor进行属性装配\n"
								}
							]
						}
					]
				},
				{
					"ID": "20230328233713-c3gaei0",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230328233713-c3gaei0"
					},
					"Children": [
						{
							"ID": "20230328233713-kkuubbn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328233713-kkuubbn"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "InstantiationAwareBeanPostProcessor.postProcessProperties ： 进行属性装配"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230328233736-1cgg2fh",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230328233736-1cgg2fh",
				"updated": "20230328233736"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "二、populateBean - 详解"
				}
			]
		},
		{
			"ID": "20230328233742-xfjkakb",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230328233742-xfjkakb",
				"updated": "20230328233742"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.1. 属性填充判断"
				}
			]
		},
		{
			"ID": "20230328233743-pvv5agp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328233743-pvv5agp",
				"updated": "20230328233810"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个的上文中已经描述过了这里就简单贴出代码"
				}
			]
		},
		{
			"ID": "20230328233812-pok4txk",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328233812-pok4txk",
				"updated": "20230328233825"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//mbd.isSynthetic() 合成类\n\t\t//todo 第五次---判断属性是否填充：InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation\n\t\t// 给InstantiationAwareBeanPostProcessor最后一次机会在属性设置前来改变bean\n\t\tif (!mbd.isSynthetic() \u0026\u0026 hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (BeanPostProcessor bp : getBeanPostProcessors()) {\n\t\t\t\tif (bp instanceof InstantiationAwareBeanPostProcessor) {\n\t\t\t\t\tInstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n\t\t\t\t\tif (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n\t\t\t\t\t\tcontinueWithPropertyPopulation = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n————————————————\n版权声明：本文为CSDN博主「大龄码农生活」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_36697880/article/details/113854056\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328233826-lq03i7d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328233826-lq03i7d",
				"updated": "20230328233844"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如下，这里调用了InstantiationAwareBeanPostProcessor #postProcessAfterInstantiation 方法来决定是否继续注入属性。该方法正常返回true。如果返回false 则将取消对此bean调用任何后续的InstantiationAwareBeanPostProcessor 方法。"
				}
			]
		},
		{
			"ID": "20230328233840-f0h6pko",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230328233840-f0h6pko",
				"updated": "20230328233840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.2、自动装配 ：autowiring自动装配的"
				}
			]
		},
		{
			"ID": "20230328233853-dpr2hns",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328233853-dpr2hns",
				"updated": "20230328233858"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在下面这段代码中，对 autowiring自动装配中根据名称或类型自动注入的种类进行自动装配。"
				}
			]
		},
		{
			"ID": "20230328233912-c9a23z0",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328233912-c9a23z0",
				"updated": "20230328233915"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": " \n    \t\t 2. 自动装配 ：autowiring自动装配的。根据名称或类型自动注入\n\t\tif (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n\t\t\t\tmbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n \n \n\t\t\tMutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n \n\t\t\t// Add property values based on autowire by name if applicable.\n\t\t\t//根据Bean名称进行autowiring自动装配处理\n\t\t\tif (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n\t\t\t\tautowireByName(beanName, mbd, bw, newPvs);\n\t\t\t}\n \n\t\t\t// Add property values based on autowire by type if applicable.\n\t\t\t//根据Bean类型进行autowiring自动装配处理\n\t\t\tif (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n\t\t\t\tautowireByType(beanName, mbd, bw, newPvs);\n\t\t\t}\n \n\t\t\tpvs = newPvs;\n\t\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328233929-tihp7wv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328233929-tihp7wv",
				"updated": "20230328233930"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这一段代码的目的是，如果bean在声明的时候指定了自动注入类型是 byName或者byType，则会根据这个规则，对 bean内部的排除某些特定的属性(排除规则后面详解)， 进行byName 或者 byType的自动装配。"
				}
			]
		},
		{
			"ID": "20230328233937-3dj71mt",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230328233937-3dj71mt",
				"updated": "20230328233937"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.2.1、自动装配 - autowireByName"
				}
			]
		},
		{
			"ID": "20230328233937-v2hy83p",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328233937-v2hy83p",
				"updated": "20230328233944"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//根据名称对属性进行自动依赖注入\n\tprotected void autowireByName(\n\t\t\tString beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n \n\t\t//对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符串，URL等都是简单属性)进行处理\n\t\tString[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\t\tfor (String propertyName : propertyNames) {\n\t\t\t//如果Spring IOC容器中包含指定名称的Bean\n\t\t\tif (containsBean(propertyName)) {\n\t\t\t\t//调用getBean方法向IOC容器索取指定名称的Bean实例，迭代触发属性的初始化和依赖注入\n\t\t\t\tObject bean = getBean(propertyName);\n\t\t\t\t//为指定名称的属性赋予属性值\n\t\t\t\tpvs.add(propertyName, bean);\n\t\t\t\t//指定名称属性注册依赖Bean名称，进行属性依赖注入\n\t\t\t\tregisterDependentBean(propertyName, beanName);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Added autowiring by name from bean name '\" + beanName +\n\t\t\t\t\t\t\t\"' via property '\" + propertyName + \"' to bean named '\" + propertyName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Not autowiring property '\" + propertyName + \"' of bean '\" + beanName +\n\t\t\t\t\t\t\t\"' by name: no matching bean found\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328233946-2wz92e3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328233946-2wz92e3",
				"updated": "20230328233959"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以看到，byName 的处理逻辑很简单，一句话概括，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "获取需要注入的bean然后递归调用getBean获取bean进行注入。"
				},
				{
					"Type": "NodeText",
					"Data": " 关于 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "unsatisfiedNonSimpleProperties"
				},
				{
					"Type": "NodeText",
					"Data": "​ 方法在后面有讲解。"
				}
			]
		},
		{
			"ID": "20230328234017-1185r9b",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230328234017-1185r9b",
				"updated": "20230328234017"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.2.2、 自动装配 - autowireByType"
				}
			]
		},
		{
			"ID": "20230328234018-c4k8y4y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328234018-c4k8y4y",
				"updated": "20230328234034"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "byType 的装配和 byName 对我们感觉来说似乎没什么差异，但是在实际实现上却截然不同，代码也复杂的多。具体代码如下："
				}
			]
		},
		{
			"ID": "20230328234035-f02vasz",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328234035-f02vasz",
				"updated": "20230328234042"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\tprotected void autowireByType(\n\t\t\tString beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n \n\t\t//获取用户定义的类型转换器\n\t\tTypeConverter converter = getCustomTypeConverter();\n\t\tif (converter == null) {\n\t\t\tconverter = bw;\n\t\t}\n \n\t\t//存放解析的要注入的属性\n\t\tSet\u003cString\u003e autowiredBeanNames = new LinkedHashSet\u003c\u003e(4);\n\t\t//对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符\n\t\t//URL等都是简单属性)进行处理\n\t\tString[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\t\tfor (String propertyName : propertyNames) {\n\t\t\ttry {\n\t\t\t\t//获取指定属性名称的属性描述器\n\t\t\t\tPropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);\n\t\t\t\t// Don't try autowiring by type for type Object: never makes sense,\n\t\t\t\t// even if it technically is a unsatisfied, non-simple property.\n\t\t\t\t//不对Object类型的属性进行autowiring自动依赖注入\n\t\t\t\tif (Object.class != pd.getPropertyType()) {\n\t\t\t\t\t//获取属性的setter方法\n\t\t\t\t\tMethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);\n\t\t\t\t\t// Do not allow eager init for type matching in case of a prioritized post-processor.\n\t\t\t\t\t//检查指定类型是否可以被转换为目标对象的类型\n\t\t\t\t\tboolean eager = !PriorityOrdered.class.isInstance(bw.getWrappedInstance());\n\t\t\t\t\t//创建一个要被注入的依赖描述\n\t\t\t\t\tDependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);\n\t\t\t\t\t//根据容器的Bean定义解析依赖关系，返回所有要被注入的Bean对象\n\t\t\t\t\tObject autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);\n\t\t\t\t\tif (autowiredArgument != null) {\n\t\t\t\t\t\t//为属性赋值所引用的对象\n\t\t\t\t\t\tpvs.add(propertyName, autowiredArgument);\n\t\t\t\t\t}\n\t\t\t\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\t\t\t\t//指定名称属性注册依赖Bean名称，进行属性依赖注入\n\t\t\t\t\t\tregisterDependentBean(autowiredBeanName, beanName);\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Autowiring by type from bean name '\" + beanName + \"' via property '\" +\n\t\t\t\t\t\t\t\t\tpropertyName + \"' to bean named '\" + autowiredBeanName + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//释放已自动注入的属性\n\t\t\t\t\tautowiredBeanNames.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tthrow new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);\n\t\t\t}\n\t\t}\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328234043-qxeecta",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328234043-qxeecta",
				"updated": "20230328234118"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下面提两点 ："
				}
			]
		},
		{
			"ID": "20230328234119-r8oi08t",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230328234119-r8oi08t",
				"updated": "20230328234131"
			},
			"Children": [
				{
					"ID": "20230328234131-te37moy",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230328234131-te37moy",
						"updated": "20230328234131"
					},
					"Children": [
						{
							"ID": "20230328234131-fyucjk4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328234131-fyucjk4",
								"updated": "20230328234131"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "关于 registerDependentBean 方法，我们在之前的文章中有过解释，详阅 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://blog.csdn.net/qq_36882793/article/details/105667530",
									"TextMarkTextContent": "Spring 源码分析三 ：bean的加载① - doGetBean概述"
								}
							]
						}
					]
				},
				{
					"ID": "20230328234137-at6gxp7",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230328234137-at6gxp7"
					},
					"Children": [
						{
							"ID": "20230328234137-rtjh43p",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328234137-rtjh43p",
								"updated": "20230328234138"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "这里面的主要的逻辑被封装到了"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "DefaultListableBeanFactory#resolveDependency"
								},
								{
									"Type": "NodeText",
									"Data": "​ 方法的具体实现我们在后继查看。目前我所知另外调用地方："
								}
							]
						},
						{
							"ID": "20230328234158-a60f0i4",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20230328234158-a60f0i4"
							},
							"Children": [
								{
									"ID": "20230328234156-e0gniq9",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20230328234156-e0gniq9"
									},
									"Children": [
										{
											"ID": "20230328234156-rsqm813",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230328234156-rsqm813",
												"updated": "20230328234159"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "​"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "AutowiredAnnotationBeanPostProcessor#postProcessProperties"
												},
												{
													"Type": "NodeText",
													"Data": "​  中注入处理 @Autowired 注入的时候也调用了该方法"
												}
											]
										}
									]
								},
								{
									"ID": "20230328234209-nbt9x98",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20230328234209-nbt9x98"
									},
									"Children": [
										{
											"ID": "20230328234209-jxih7bg",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230328234209-jxih7bg",
												"updated": "20230328234214"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "ConstructorResolver#autowireConstructor 在 resolveAutowiredArgument( methodParam, beanName, autowiredBeanNames, converter, fallback); 时也调用了该方法。"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230328234232-jashhhg",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230328234232-jashhhg",
				"updated": "20230328234232"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.3、排除规则 - unsatisfiedNonSimpleProperties"
				}
			]
		},
		{
			"ID": "20230328234153-15v3gpr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328234153-15v3gpr",
				"updated": "20230328234247"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "autowireByName"
				},
				{
					"Type": "NodeText",
					"Data": "​ 和 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "autowireByType"
				},
				{
					"Type": "NodeText",
					"Data": "​方法中，都有如下一行代码"
				}
			]
		},
		{
			"ID": "20230328234253-sji9l0w",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328234253-sji9l0w",
				"updated": "20230328234300"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328234300-0n0ma4l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328234300-0n0ma4l",
				"updated": "20230328234309"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "unsatisfiedNonSimpleProperties"
				},
				{
					"Type": "NodeText",
					"Data": "​ 方法中，对Bean 的属性进行了过滤，得到了需要自动装配的属性。我们来详细看看里面的内容。"
				}
			]
		},
		{
			"ID": "20230328234311-tmzxbgt",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328234311-tmzxbgt",
				"updated": "20230328234316"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "protected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) {\n\t\tSet\u003cString\u003e result = new TreeSet\u003c\u003e();\n\t\t// 获取bean 的property 属性\n\t\tPropertyValues pvs = mbd.getPropertyValues();\n\t\t// 获取 bw 中的属性描述\n\t\tPropertyDescriptor[] pds = bw.getPropertyDescriptors();\n\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\t// if  pd属性具有set方法 \u0026\u0026 依赖检查中没有被忽略 \u0026\u0026 没有被配置成 property 属性 \u0026\u0026 不是简单类型\n\t\t\tif (pd.getWriteMethod() != null \u0026\u0026 !isExcludedFromDependencyCheck(pd) \u0026\u0026 !pvs.contains(pd.getName()) \u0026\u0026\n\t\t\t\t\t!BeanUtils.isSimpleProperty(pd.getPropertyType())) {\n\t\t\t\t// 添加到需要装配的集合中\n\t\t\t\tresult.add(pd.getName());\n\t\t\t}\n\t\t}\n\t\t// 返回需要自动装配的bean集合\n\t\treturn StringUtils.toStringArray(result);\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328234328-n06aesu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328234328-n06aesu",
				"updated": "20230328234328"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以看到过滤条件"
				}
			]
		},
		{
			"ID": "20230328234328-ddiskfz",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230328234328-ddiskfz",
				"updated": "20230328234401"
			},
			"Children": [
				{
					"ID": "20230328234401-tpd4850",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230328234401-tpd4850",
						"updated": "20230328234401"
					},
					"Children": [
						{
							"ID": "20230328234401-vsdf5y0",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328234401-vsdf5y0",
								"updated": "20230328234401"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "装配 属性具有set 方法： 因为后面的装配是通过set方法装配\n"
								}
							]
						}
					]
				},
				{
					"ID": "20230328234403-jk1v2pa",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230328234403-jk1v2pa"
					},
					"Children": [
						{
							"ID": "20230328234403-pscw41c",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328234403-pscw41c"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "依赖检查中没有被忽略isExcludedFromDependencyCheck(pd)\n"
								}
							]
						}
					]
				},
				{
					"ID": "20230328234406-vda48au",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230328234406-vda48au"
					},
					"Children": [
						{
							"ID": "20230328234406-ji4unl3",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328234406-ji4unl3"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "没有被property 属性，因为这里property 会被单独处理，不需要在这里保存\n"
								}
							]
						}
					]
				},
				{
					"ID": "20230328234408-9xdgz87",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20230328234408-9xdgz87"
					},
					"Children": [
						{
							"ID": "20230328234408-0ky7q4m",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328234408-0ky7q4m",
								"updated": "20230328234412"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "不是简单类型，即不属于Void、void、 Enum、CharSequence、Number、Date、Temporal、URI、URL、Locale、Class 和 八大基本数据类型及其包装类型。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230328234423-o95v9gt",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230328234423-o95v9gt",
				"updated": "20230328234423"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3、@Autowired 和 @Resource 的注入工作"
				}
			]
		},
		{
			"ID": "20230328234427-4rj5qvf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328234427-4rj5qvf",
				"updated": "20230328234438"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里只要时候 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://www.cnblogs.com/elvinle/p/13384328.html",
					"TextMarkTextContent": " InstantiationAwareBeanPostProcessor#postProcessProperties"
				},
				{
					"Type": "NodeText",
					"Data": " 后置处理器处理"
				}
			]
		},
		{
			"ID": "20230328234441-f29chr3",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328234441-f29chr3",
				"updated": "20230328234527"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n\t\t\tif (hasInstAwareBpps) {\n\t\t\t\t//TODO 获取的bean所有后置处理器找到 所有需要注入的属性\n\t\t\t\t// 这里会进行 @Autowired 和 @Resource 的注入工作\n\t\t\t\t// 属性填充InstantiationAwareBeanPostProcessor\n\t\t\t\tfor (BeanPostProcessor bp : getBeanPostProcessors()) {\n\t\t\t\t\tif (bp instanceof InstantiationAwareBeanPostProcessor) {\n\t\t\t\t\t\tInstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n\t\t\t\t\t\t//下面是完成属性注入的\n\t\t\t\t\t\tpvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n\t\t\t\t\t\t// 如果postProcessProperties 返回null，再调用 postProcessPropertyValues这个过时的方法\n\t\t\t\t\t\tif (pvs == null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328234546-og5o7i4",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230328234546-og5o7i4",
				"updated": "20230328234546"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.1、第六次调用后置处理器 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://www.cnblogs.com/elvinle/p/13384328.html",
					"TextMarkTextContent": " InstantiationAwareBeanPostProcessor#postProcessProperties"
				}
			]
		},
		{
			"ID": "20230328234555-7wftp37",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328234555-7wftp37",
				"updated": "20230328234555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里通过 InstantiationAwareBeanPostProcessor #postProcessPropertyValues 方法完成了属性的注入。"
				}
			]
		},
		{
			"ID": "20230328234555-dxqv188",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230328234555-dxqv188",
				"updated": "20230328234605"
			},
			"Children": [
				{
					"ID": "20230328234605-sthcd7m",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230328234605-sthcd7m",
						"updated": "20230328234605"
					},
					"Children": [
						{
							"ID": "20230328234605-halggxn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328234605-halggxn",
								"updated": "20230328234605"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "AutowiredAnnotationBeanPostProcessor #postProcessPropertyValues中的实现类 处理 @Autowired 注解和@Value 注解的自动注入功能。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230328234555-2fadi73",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230328234555-2fadi73",
				"updated": "20230328234611"
			},
			"Children": [
				{
					"ID": "20230328234609-apa93gn",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230328234609-apa93gn",
						"updated": "20230328234611"
					},
					"Children": [
						{
							"ID": "20230328234609-op4wtmh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328234609-op4wtmh",
								"updated": "20230328234611"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "CommonAnnotationBeanPostProcessor#postProcessPropertyValues中的实现类 处理  @Resource注解、@PostConstruct等通用注解。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230328234620-xsramep",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230328234620-xsramep",
				"updated": "20230328234620"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.2、CommonAnnotationBeanPostProcessor#"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "postProcessPropertyValues"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230328234620-17zyhw7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328234620-17zyhw7",
				"updated": "20230328234628"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//处理属性值\n\t@Override\n\tpublic PropertyValues postProcessPropertyValues(\n\t\t\tPropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {\n \n\t\t//获取@Resource注解中配置的属性值元数据\n\t\tInjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);\n\t\ttry {\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328235720-ph0rzz5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235720-ph0rzz5",
				"updated": "20230328235720"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "获取@Resource注解中配置的属性值元数据"
				}
			]
		},
		{
			"ID": "20230328235726-w6x786n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235726-w6x786n",
				"updated": "20230328235726"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里主要是对 @Resource 进行注入findResourceMetadata在MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition的时候执行过."
				}
			]
		},
		{
			"ID": "20230328235729-n6ybwji",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235729-n6ybwji",
				"updated": "20230328235729"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以这里, 大概率是从缓存中拿取结果, 然后进行注入操作. 事实上, 也确实如此."
				}
			]
		},
		{
			"ID": "20230328235726-p8tjj5v",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328235726-p8tjj5v",
				"updated": "20230328235734"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/获取@Resource注解中配置的属性值元数据\n\tprivate InjectionMetadata findResourceMetadata(String beanName, final Class\u003c?\u003e clazz, @Nullable PropertyValues pvs) {\n\t\t// Fall back to class name as cache key, for backwards compatibility with custom callers.\n\t\tString cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());\n\t\t// Quick check on the concurrent map first, with minimal locking.\n\t\t//首先从容器缓存中查找\n\t\tInjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);\n\t\tif (InjectionMetadata.needsRefresh(metadata, clazz)) {\n\t\t\tsynchronized (this.injectionMetadataCache) {\n\t\t\t\tmetadata = this.injectionMetadataCache.get(cacheKey);\n\t\t\t\tif (InjectionMetadata.needsRefresh(metadata, clazz)) {\n\t\t\t\t\tif (metadata != null) {\n\t\t\t\t\t\tmetadata.clear(pvs);\n\t\t\t\t\t}\n\t\t\t\t\tmetadata = buildResourceMetadata(clazz);\n\t\t\t\t\tthis.injectionMetadataCache.put(cacheKey, metadata);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn metadata;\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328235736-uka9fjs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235736-uka9fjs",
				"updated": "20230328235741"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "metadata.inject(bean, beanName, pvs);"
				}
			]
		},
		{
			"ID": "20230328235742-7dcq52i",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328235742-7dcq52i",
				"updated": "20230328235748"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\tpublic void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {\n\t\t//\n\t\tCollection\u003cInjectedElement\u003e checkedElements = this.checkedElements;\n\t\tCollection\u003cInjectedElement\u003e elementsToIterate =\n\t\t\t\t(checkedElements != null ? checkedElements : this.injectedElements);\n\t\tif (!elementsToIterate.isEmpty()) {\n\t\t\tboolean debug = logger.isDebugEnabled();\n\t\t\tfor (InjectedElement element : elementsToIterate) {\n\t\t\t\tif (debug) {\n\t\t\t\t\tlogger.debug(\"Processing injected element of bean '\" + beanName + \"': \" + element);\n\t\t\t\t}\n\t\t\t\telement.inject(target, beanName, pvs);\n\t\t\t}\n\t\t}\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328235755-449tq35",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235755-449tq35",
				"updated": "20230328235755"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "element.inject(target, beanName, pvs);的实现类有三个"
				}
			]
		},
		{
			"ID": "20230328235755-t3131nv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235755-t3131nv",
				"updated": "20230328235755"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里最终会调用本类中的方法:"
				}
			]
		},
		{
			"ID": "20230328235758-ssiwicg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235758-ssiwicg",
				"updated": "20230328235758"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement#inject 方法"
				}
			]
		},
		{
			"ID": "20230328235755-36oknd5",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328235755-36oknd5",
				"updated": "20230328235803"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "protected void inject(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)\n\t\t\t\tthrows Throwable {\n \n\t\t\t//这里处理通过字段注入\n\t\t\tif (this.isField) {\n\t\t\t\tField field = (Field) this.member;\n\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\tfield.set(target, getResourceToInject(target, requestingBeanName));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (checkPropertySkipping(pvs)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t//这里处理通过方法注入\n\t\t\t\t\tMethod method = (Method) this.member;\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tmethod.invoke(target, getResourceToInject(target, requestingBeanName));\n\t\t\t\t}\n\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328235810-m24hn2p",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230328235810-m24hn2p",
				"updated": "20230328235810"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.3、AutowiredAnnotationBeanPostProcessor #"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "postProcessPropertyValues"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230328235812-dasjimk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235812-dasjimk",
				"updated": "20230328235817"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "大概逻辑是，获取被 @Autowired 修饰的 属性或者方法，如果是属性，则通过getBean 获取bean并注入，如果是方法，则获取方法参数后，invoke 方法(调用该方法，因为我们一般写的都是set方法，给属性注入赋值)。"
				}
			]
		},
		{
			"ID": "20230328235818-k95biaj",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328235818-k95biaj",
				"updated": "20230328235829"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//处理类中的属性\n\t@Override\n\tpublic PropertyValues postProcessPropertyValues(\n\t\t\tPropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException {\n \n\t\t//获取指定类中autowire相关注解的元信息\n\t\tInjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);\n\t\ttry {\n\t\t\t//对Bean的属性进行自动注入\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (BeanCreationException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Injection of autowired dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328235836-fq9xsna",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235836-fq9xsna",
				"updated": "20230328235836"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里主要是对 @Autowired 和 @Value 进行注入的. InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);"
				}
			]
		},
		{
			"ID": "20230328235836-iruqau4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235836-iruqau4",
				"updated": "20230328235836"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "findAutowiringMetadata在MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition的时候执行过."
				}
			]
		},
		{
			"ID": "20230328235836-7iyxb4j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235836-7iyxb4j",
				"updated": "20230328235836"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以此处, 是从缓存中拿取结果, 然后进行注入操作."
				}
			]
		},
		{
			"ID": "20230328235836-vasnfi6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235836-vasnfi6",
				"updated": "20230328235836"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "最终会调用本类中的方法:"
				}
			]
		},
		{
			"ID": "20230328235841-i3ii0h3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235841-i3ii0h3",
				"updated": "20230328235841"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject"
				}
			]
		},
		{
			"ID": "20230328235836-s7izr2k",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328235836-s7izr2k",
				"updated": "20230328235845"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//对字段进行注入\n\t\t@Override\n\t\tprotected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {\n\t\t\t//获取注入元素对象\n\t\t\tField field = (Field) this.member;\n\t\t\tObject value;\n\t\t\t//如果当前对象在容器中被缓存 默认为false.\n\t\t\tif (this.cached) {\n\t\t\t\t//根据Bean名称解析缓存中的字段值\n\t\t\t\tvalue = resolvedCachedArgument(beanName, this.cachedFieldValue);\n\t\t\t}\n\t\t\t//如果当前对象没有被容器缓存\n\t\t\telse {\n\t\t\t\t//创建一个字段依赖描述符\n\t\t\t\tDependencyDescriptor desc = new DependencyDescriptor(field, this.required);\n\t\t\t\tdesc.setContainingClass(bean.getClass());\n\t\t\t\tSet\u003cString\u003e autowiredBeanNames = new LinkedHashSet\u003c\u003e(1);\n\t\t\t\tAssert.state(beanFactory != null, \"No BeanFactory available\");\n\t\t\t\t//获取容器中的类型转换器\n\t\t\t\tTypeConverter typeConverter = beanFactory.getTypeConverter();\n\t\t\t\ttry {\n\t\t\t\t\t//根据容器中Bean定义，解析指定的依赖关系，获取需要依赖注入的对象\n\t\t\t\t\tvalue = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex);\n\t\t\t\t}\n\t\t\t\t//线程同步，确保容器中数据一致性\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\t//如果当前对象没有被容器缓存\n\t\t\t\t\tif (!this.cached) {\n\t\t\t\t\t\t//获取到了当前对象的依赖对象，并且required属性为true\n\t\t\t\t\t\tif (value != null || this.required) {\n\t\t\t\t\t\t\tthis.cachedFieldValue = desc;\n\t\t\t\t\t\t\t//为指定Bean注册依赖Bean\n\t\t\t\t\t\t\tregisterDependentBeans(beanName, autowiredBeanNames);\n\t\t\t\t\t\t\tif (autowiredBeanNames.size() == 1) {\n\t\t\t\t\t\t\t\tString autowiredBeanName = autowiredBeanNames.iterator().next();\n\t\t\t\t\t\t\t\t//如果容器中有指定名称的Bean对象\n\t\t\t\t\t\t\t\tif (beanFactory.containsBean(autowiredBeanName)) {\n\t\t\t\t\t\t\t\t\t// 依赖对象类型和字段类型匹配，默认按类型注入\n\t\t\t\t\t\t\t\t\tif (beanFactory.isTypeMatch(autowiredBeanName, field.getType())) {\n\t\t\t\t\t\t\t\t\t\t//创建一个依赖对象的引用，同时缓存\n\t\t\t\t\t\t\t\t\t\tthis.cachedFieldValue = new ShortcutDependencyDescriptor(\n\t\t\t\t\t\t\t\t\t\t\t\tdesc, autowiredBeanName, field.getType());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//如果获取的依赖关系为null，且获取required属性为false\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//将字段值的缓存设置为null\n\t\t\t\t\t\t\tthis.cachedFieldValue = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//容器已经对当前字段的值缓存\n\t\t\t\t\t\tthis.cached = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//如果字段依赖值不为null\n\t\t\tif (value != null) {\n\t\t\t\t//显式使用JDK的反射机制，设置自动的访问控制权限为允许访问\n\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t//TODO 为Bean对象的字段设置值 完成了属性填充\n\t\t\t\tfield.set(bean, value);\n\t\t\t}\n\t\t}\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328235852-ee8b5bs",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230328235852-ee8b5bs",
				"updated": "20230328235852"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.4、需要依赖注入的对象 DefaultListableBeanFactory#resolveDependency"
				}
			]
		},
		{
			"ID": "20230328235852-7jcbl67",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235852-7jcbl67",
				"updated": "20230328235852"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "根据容器中Bean定义，解析指定的依赖关系，获取需要依赖注入的对象。这里是很重要的方法在很多地方都使用到"
				}
			]
		},
		{
			"ID": "20230328235854-6iersvs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235854-6iersvs",
				"updated": "20230328235900"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);"
				}
			]
		},
		{
			"ID": "20230328235901-1vhtptr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235901-1vhtptr",
				"updated": "20230328235904"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency"
				}
			]
		},
		{
			"ID": "20230328235907-dhtgccg",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328235907-dhtgccg",
				"updated": "20230328235910"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\t@Override\n\t@Nullable\n\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t@Nullable Set\u003cString\u003e autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {\n \n\t\tdescriptor.initParameterNameDiscovery(getParameterNameDiscoverer());\n         // 针对不同类型的不同处理\n\t\tif (Optional.class == descriptor.getDependencyType()) {\n\t\t\treturn createOptionalDependency(descriptor, requestingBeanName);\n\t\t}\n\t\t//延迟加载\n\t\telse if (ObjectFactory.class == descriptor.getDependencyType() ||\n\t\t\t\tObjectProvider.class == descriptor.getDependencyType()) {\n\t\t\treturn new DependencyObjectProvider(descriptor, requestingBeanName);\n\t\t}\n\t\t//\n\t\telse if (javaxInjectProviderClass == descriptor.getDependencyType()) {\n\t\t\treturn new Jsr330ProviderFactory().createDependencyProvider(descriptor, requestingBeanName);\n\t\t}\n\t\telse {\n\t\t\t//ToDO 这个一般为空 这个是特殊情况 处理bean是否懒加载，如果懒加载，创建一个代理对象注入bean\n\t\t\tObject result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(\n\t\t\t\t\tdescriptor, requestingBeanName);\n\t\t\tif (result == null) {\n\t\t\t\t// 下面是正常情况\n\t\t\t\tresult = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328235921-cyj20d6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235921-cyj20d6",
				"updated": "20230328235921"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上面的逻辑比较清晰，对一些特殊的类型进行特殊处理，一般的通用处理都会调用 doResolveDependency 方法。这里我们不去关注特殊类型的处理，下面再来看看\nDefaultListableBeanFactory#doResolveDependency 方法，代码如下。"
				}
			]
		},
		{
			"ID": "20230328235925-sfbsnfo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235925-sfbsnfo",
				"updated": "20230328235925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "DefaultListableBeanFactory#doResolveDependency"
				}
			]
		},
		{
			"ID": "20230328235921-pjs4i6z",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328235921-pjs4i6z",
				"updated": "20230328235930"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\t@Nullable\n\tpublic Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set\u003cString\u003e autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {\n \n\t\tInjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);\n\t\ttry {\n\t\t\t//非正常情况\n\t\t\t// 尝试获取缓存\n\t\t\tObject shortcut = descriptor.resolveShortcut(this);\n\t\t\tif (shortcut != null) {\n\t\t\t\t// 存在缓存直接返回\n\t\t\t\treturn shortcut;\n\t\t\t}\n \n\t\t\t//获得需要注入属性的类型\n\t\t\tClass\u003c?\u003e type = descriptor.getDependencyType();\n\t\t\t// 取值@Value注解中的value属性中的值，这里取出的值是未经修改的值，即带有 ${} 标签的值。如果descriptor未被@Value标注，则返回null\n\t\t\tObject value = getAutowireCandidateResolver().getSuggestedValue(descriptor);\n\t\t\tif (value != null) {\n\t\t\t\t// 到这里说明属性被 @Value 注解修饰了，这里是解析 @Value 注解的逻辑\n\t\t\t\t// 如果value不为nul\n\t\t\t\tif (value instanceof String) {\n\t\t\t\t\t// 处理占位符如${}，做占位符的替换(不解析SP EL表达式)\n\t\t\t\t\tString strVal = resolveEmbeddedValue((String) value);\n\t\t\t\t\tBeanDefinition bd = (beanName != null \u0026\u0026 containsBean(beanName) ? getMergedBeanDefinition(beanName) : null);\n\t\t\t\t\t//解析SP EL(如#{})\n\t\t\t\t\tvalue = evaluateBeanDefinitionString(strVal, bd);\n\t\t\t\t}\n\t\t\t\t// 类型转换，把解析出来的结果转成type类型\n\t\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n\t\t\t\treturn (descriptor.getField() != null ?\n\t\t\t\t\t\tconverter.convertIfNecessary(value, type, descriptor.getField()) :\n\t\t\t\t\t\tconverter.convertIfNecessary(value, type, descriptor.getMethodParameter()));\n\t\t\t}\n \n\t\t\t//TODO 对集合类型进行处理，包括，Array、Collection、Map。后面详解\n\t\t\tObject multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t\tif (multipleBeans != null) {\n\t\t\t\t// 如果解析出来集合类型，则直接返回\n\t\t\t\treturn multipleBeans;\n\t\t\t}\n \n\t\t\t//调用查找所有类型为type的实例，存放在matchingBeans \u003cbeanName, bean\u003e\n\t\t\t//  (在 resolveMultipleBeans 方法中也是核心也是调用该方法)。下面详解\n\t\t\tMap\u003cString, Object\u003e matchingBeans = findAutowireCandidates(beanName, type, descriptor);\n\t\t\tif (matchingBeans.isEmpty()) {\n\t\t\t\tif (isRequired(descriptor)) {\n\t\t\t\t\traiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n \n\t\t\tString autowiredBeanName;\n\t\t\tObject instanceCandidate;\n \n\t\t\t//TODO 这个是处理 这个是根据 类型找到多个bean(也就是实现类有多个)\n\t\t\t// 如果有多个bean 则在按照名字来匹配多个bean 找出来一个bean 用来注入\n\t\t\tif (matchingBeans.size() \u003e 1) {\n\t\t\t\t// 按以下顺序，找到符合条件的就直接返回\n\t\t\t\t// 1. 挑选出被标识为primary的bean\n\t\t\t\t// 2. 挑选标识了@Priority，且先级级最高的bean。可以不标识，一旦标识，不允许同一优先级的存在\n\t\t\t\tautowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);\n\t\t\t\tif (autowiredBeanName == null) {\n\t\t\t\t\tif (isRequired(descriptor) || !indicatesMultipleBeans(type)) {\n\t\t\t\t\t\t// 非集合类，找到了多个符合条件的Bean，抛出异常\n\t\t\t\t\t\treturn descriptor.resolveNotUnique(type, matchingBeans);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// In case of an optional Collection/Map, silently ignore a non-unique case:\n\t\t\t\t\t\t// possibly it was meant to be an empty collection of multiple regular beans\n\t\t\t\t\t\t// (before 4.3 in particular when we didn't even look for collection beans).\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//根据名字从 根据类型的获得的matchingBeans 找到bean\n\t\t\t\tinstanceCandidate = matchingBeans.get(autowiredBeanName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We have exactly one match.\n\t\t\t\t// 如果只找到了唯一匹配的元素，则直接使用\n\t\t\t\tMap.Entry\u003cString, Object\u003e entry = matchingBeans.entrySet().iterator().next();\n\t\t\t\tautowiredBeanName = entry.getKey();\n\t\t\t\tinstanceCandidate = entry.getValue();\n\t\t\t}\n \n\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\t// 将待装配的Bean名称放入autowiredBeanNames集合里\n\t\t\t\tautowiredBeanNames.add(autowiredBeanName);\n\t\t\t}\n\t\t\tif (instanceCandidate instanceof Class) {\n\t\t\t\t// 这里又去调用 getBean 方法去获取bean\n\t\t\t\tinstanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);\n\t\t\t}\n\t\t\tObject result = instanceCandidate;\n\t\t\tif (result instanceof NullBean) {\n\t\t\t\tif (isRequired(descriptor)) {\n\t\t\t\t\t// 如果 result 是 NullBean类型，且 required = true，则抛出异常\n\t\t\t\t\traiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);\n\t\t\t\t}\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\t// 类型校验，确保类型与解析出来的Bean实例能够匹配\n\t\t\tif (!ClassUtils.isAssignableValue(type, result)) {\n\t\t\t\tthrow new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tfinally {\n\t\t\tConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n\t\t}\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328235936-kzgtp3z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235936-kzgtp3z",
				"updated": "20230328235936"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "DefaultListableBeanFactory#resolveMultipleBeans"
				}
			]
		},
		{
			"ID": "20230328235936-9w19hns",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235936-9w19hns",
				"updated": "20230328235936"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个方法是用来处理 数组、Collection、Map 类型的注入。具体实现如下："
				}
			]
		},
		{
			"ID": "20230328235938-m8zt91q",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328235938-m8zt91q",
				"updated": "20230328235943"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\tprivate Object resolveMultipleBeans(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set\u003cString\u003e autowiredBeanNames, @Nullable TypeConverter typeConverter) {\n \n\t\tfinal Class\u003c?\u003e type = descriptor.getDependencyType();\n\t\t// 如果是 StreamDependencyDescriptor 类型，则返回流的形式\n\t\tif (descriptor instanceof StreamDependencyDescriptor) {\n\t\t\tMap\u003cString, Object\u003e matchingBeans = findAutowireCandidates(beanName, type, descriptor);\n\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n\t\t\t}\n\t\t\tStream\u003cObject\u003e stream = matchingBeans.keySet().stream()\n\t\t\t\t\t.map(name -\u003e descriptor.resolveCandidate(name, type, this))\n\t\t\t\t\t.filter(bean -\u003e !(bean instanceof NullBean));\n\t\t\tif (((StreamDependencyDescriptor) descriptor).isOrdered()) {\n\t\t\t\tstream = stream.sorted(adaptOrderComparator(matchingBeans));\n\t\t\t}\n\t\t\treturn stream;\n\t\t}\n\t\t// 如果是 数组类型\n\t\telse if (type.isArray()) {\n\t\t\t// 确定最终类型\n\t\t\tClass\u003c?\u003e componentType = type.getComponentType();\n\t\t\tResolvableType resolvableType = descriptor.getResolvableType();\n\t\t\tClass\u003c?\u003e resolvedArrayType = resolvableType.resolve(type);\n\t\t\tif (resolvedArrayType != type) {\n\t\t\t\tcomponentType = resolvableType.getComponentType().resolve();\n\t\t\t}\n\t\t\tif (componentType == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// 根据属性类型找到 beanFactory 中所有类型的匹配bean\n\t\t\t// 返回值构成 ： key= 匹配的beanName, value= beanName对应的实例化bean，通过 getBean(beanName)获取。\n\t\t\tMap\u003cString, Object\u003e matchingBeans = findAutowireCandidates(beanName, componentType,\n\t\t\t\t\tnew MultiElementDescriptor(descriptor));\n\t\t\t// 如果是未找到匹配的bean，则返回null，\n\t\t\tif (matchingBeans.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// 保存所有适配的 beanName\n\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n\t\t\t}\n\t\t\t// 进行类型转换，将bean 转换为对应的type 类型。\n\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n\t\t\tObject result = converter.convertIfNecessary(matchingBeans.values(), resolvedArrayType);\n\t\t\tif (result instanceof Object[]) {\n\t\t\t\tComparator\u003cObject\u003e comparator = adaptDependencyComparator(matchingBeans);\n\t\t\t\tif (comparator != null) {\n\t\t\t\t\t// 排序\n\t\t\t\t\tArrays.sort((Object[]) result, comparator);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t// 对 Collection 类型的处理，逻辑基本同上，这里不再赘述\n\t\telse if (Collection.class.isAssignableFrom(type) \u0026\u0026 type.isInterface()) {\n\t\t\tClass\u003c?\u003e elementType = descriptor.getResolvableType().asCollection().resolveGeneric();\n\t\t\tif (elementType == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tMap\u003cString, Object\u003e matchingBeans = findAutowireCandidates(beanName, elementType,\n\t\t\t\t\tnew MultiElementDescriptor(descriptor));\n\t\t\tif (matchingBeans.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n\t\t\t}\n\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n\t\t\tObject result = converter.convertIfNecessary(matchingBeans.values(), type);\n\t\t\tif (result instanceof List) {\n\t\t\t\tif (((List\u003c?\u003e) result).size() \u003e 1) {\n\t\t\t\t\tComparator\u003cObject\u003e comparator = adaptDependencyComparator(matchingBeans);\n\t\t\t\t\tif (comparator != null) {\n\t\t\t\t\t\t((List\u003c?\u003e) result).sort(comparator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t// 对map类型的处理，逻辑类似上面\n\t\telse if (Map.class == type) {\n\t\t\tResolvableType mapType = descriptor.getResolvableType().asMap();\n\t\t\tClass\u003c?\u003e keyType = mapType.resolveGeneric(0);\n\t\t\tif (String.class != keyType) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tClass\u003c?\u003e valueType = mapType.resolveGeneric(1);\n\t\t\tif (valueType == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tMap\u003cString, Object\u003e matchingBeans = findAutowireCandidates(beanName, valueType,\n\t\t\t\t\tnew MultiElementDescriptor(descriptor));\n\t\t\tif (matchingBeans.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n\t\t\t}\n\t\t\treturn matchingBeans;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328235951-tagad9s",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235951-tagad9s",
				"updated": "20230328235951"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以看到的是，如果是集合类型，内部的核心方法也是 findAutowireCandidates 方法。所以下面还是来看 DefaultListableBeanFactory#findAutowireCandidates 方法。"
				}
			]
		},
		{
			"ID": "20230328235957-aad7264",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328235957-aad7264",
				"updated": "20230328235957"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "DefaultListableBeanFactory#findAutowireCandidates"
				}
			]
		},
		{
			"ID": "20230328235951-0sjvj5y",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328235951-0sjvj5y",
				"updated": "20230328235958"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\tprotected Map\u003cString, Object\u003e findAutowireCandidates(\n\t\t\t@Nullable String beanName, Class\u003c?\u003e requiredType, DependencyDescriptor descriptor) {\n\t\t// 根据 Class 类型，找到对应的候选beanName,\n\t\tString[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\tthis, requiredType, true, descriptor.isEager());\n\t\tMap\u003cString, Object\u003e result = new LinkedHashMap\u003c\u003e(candidateNames.length);\n\t\t// 这里我们一般不会涉及。如果注入的是 resolvableDependencies key类型，则会装配成value类型\n\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Object\u003e classObjectEntry : this.resolvableDependencies.entrySet()) {\n\t\t\tClass\u003c?\u003e autowiringType = classObjectEntry.getKey();\n\t\t\tif (autowiringType.isAssignableFrom(requiredType)) {\n\t\t\t\tObject autowiringValue = classObjectEntry.getValue();\n\t\t\t\tautowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);\n\t\t\t\tif (requiredType.isInstance(autowiringValue)) {\n\t\t\t\t\tresult.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 遍历候选的beanName\n\t\tfor (String candidate : candidateNames) {\n\t\t\t// 不是自引用 \u0026\u0026 允许被注入(autowire-candidate 标签指定) \n\t\t\tif (!isSelfReference(beanName, candidate) \u0026\u0026 isAutowireCandidate(candidate, descriptor)) {\n\t\t\t\t// 将结果添加到result中\n\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t}\n\t\t}\n\t\t// 如果目前找到的匹配的bean集合为空\n\t\tif (result.isEmpty()) {\n\t\t\t// Array || Collection || Map 。即是否表示多个bean的集合类型\n\t\t\tboolean multiple = indicatesMultipleBeans(requiredType);\n\t\t\t// Consider fallback matches if the first pass failed to find anything...\n\t\t\tDependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();\n\t\t\tfor (String candidate : candidateNames) {\n\t\t\t\t// 非自引用 \u0026\u0026 允许被注入 \u0026\u0026 (非集合类 || 解析 @Qualifier 注解或者 javax.inject.Qualifier类成功)\n\t\t\t\t// 这里开始分析解析的属性是否被 @Qualifier 注解或者 javax.inject.Qualifier类 限定符限定了\n\t\t\t\tif (!isSelfReference(beanName, candidate) \u0026\u0026 isAutowireCandidate(candidate, fallbackDescriptor) \u0026\u0026\n\t\t\t\t\t\t(!multiple || getAutowireCandidateResolver().hasQualifier(descriptor))) {\n\t\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 如果还没找到 \u0026\u0026 非集合类\n\t\t\tif (result.isEmpty() \u0026\u0026 !multiple) {\n\t\t\t\t// Consider self references as a final pass...\n\t\t\t\t// but in the case of a dependency collection, not the very same bean itself.\n\t\t\t\tfor (String candidate : candidateNames) {\n\t\t\t\t\t// 将自我引用视为最后一步。判断是不是自己引用自己\n\t\t\t\t\tif (isSelfReference(beanName, candidate) \u0026\u0026\n\t\t\t\t\t\t\t(!(descriptor instanceof MultiElementDescriptor) || !beanName.equals(candidate)) \u0026\u0026\n\t\t\t\t\t\t\tisAutowireCandidate(candidate, fallbackDescriptor)) {\n\t\t\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t...\n\n\tprivate void addCandidateEntry(Map\u003cString, Object\u003e candidates, String candidateName,\n\t\t\tDependencyDescriptor descriptor, Class\u003c?\u003e requiredType) {\n\t\t// 根据类型判断，如果是MultiElementDescriptor，获取后保存到候选列表中\n\t\tif (descriptor instanceof MultiElementDescriptor) {\n\t\t\tObject beanInstance = descriptor.resolveCandidate(candidateName, requiredType, this);\n\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\tcandidates.put(candidateName, beanInstance);\n\t\t\t}\n\t\t}\n\t\t// 如果 单例缓存中存在 ||  是 StreamDependencyDescriptor  的类型 \u0026\u0026  order = true\n\t\telse if (containsSingleton(candidateName) || (descriptor instanceof StreamDependencyDescriptor \u0026\u0026\n\t\t\t\t((StreamDependencyDescriptor) descriptor).isOrdered())) {\n\t\t\t// 调用了beanFacotory.getBean 方法获取bean\n\t\t\tObject beanInstance = descriptor.resolveCandidate(candidateName, requiredType, this);\n\t\t\t// 保存起来\n\t\t\tcandidates.put(candidateName, (beanInstance instanceof NullBean ? null : beanInstance));\n\t\t}\n\t\telse {\n\t\t\t// getType 调用了beanFacotory.getBean 方法\n\t\t\tcandidates.put(candidateName, getType(candidateName));\n\t\t}\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230329000006-i1wbhof",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230329000006-i1wbhof",
				"updated": "20230329000006"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里提两点："
				}
			]
		},
		{
			"ID": "20230329000012-q0ozsao",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230329000012-q0ozsao",
				"updated": "20230329000012"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里需要注意 resolvableDependencies。其在 DefaultListableBeanFactory#resolvableDependencies 定义如下，其作用是，当一些其他的类需要装配key类型的bean时，实际装配的类型是key对应的value 类型。"
				}
			]
		},
		{
			"ID": "20230329000006-8friqq2",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230329000006-8friqq2",
				"updated": "20230329000013"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\t/** Map from dependency type to corresponding autowired value. */\n\t// key 是映射值，value是实际注入值\n\tprivate final Map\u003cClass\u003c?\u003e, Object\u003e resolvableDependencies = new ConcurrentHashMap\u003c\u003e(16);\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230329000014-j14dlts",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230329000014-j14dlts",
				"updated": "20230329000017"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 Spring默认的代码中，仅仅有八个元素保存到其中，如下："
				}
			]
		},
		{
			"ID": "20230329000022-e5s59ph",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230329000022-e5s59ph",
				"updated": "20230329000022"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "20210121174448395"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/20210121174448395-20230329000022-6h4wmk9.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230329000031-cvvio8p",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230329000031-cvvio8p",
				"updated": "20230329000034"
			},
			"Children": [
				{
					"ID": "20230329000034-h5lp871",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230329000034-h5lp871",
						"updated": "20230329000034"
					},
					"Children": [
						{
							"ID": "20230329000034-97rlym5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230329000034-97rlym5",
								"updated": "20230329000034"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "从上面的代码可以看到，Spring寻找合适的bean的要求是一再放宽的 ： 非自引用 -\u003e 被 Qualifier 限定符修饰的bean -\u003e 自引用。"
								}
							]
						}
					]
				},
				{
					"ID": "20230329000040-19bv3c5",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230329000040-19bv3c5"
					},
					"Children": [
						{
							"ID": "20230329000040-jscyp49",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230329000040-jscyp49",
								"updated": "20230329000045"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "autowire-candidate ：xml中在注入bean 的时候有该属性。@Bean也有对应的属性。其作用是用来标记当前bean是否会被作为注入的候选bean。默认值 true：表示其他bean可以把当前bean作为属性注入。如果false:表示其他bean选在注入属性 bean时将忽略当前bean。这一点在上面的代码中也有体现。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230329000050-0wr59oj",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230329000050-0wr59oj",
				"updated": "20230329000050"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4. applyPropertyValues"
				}
			]
		},
		{
			"ID": "20230329000042-67tl2e7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230329000042-67tl2e7",
				"updated": "20230329000058"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上面只是将属性保存了起来，并未真正设置到bean中，这里设置到bean中"
				}
			]
		},
		{
			"ID": "20230329000059-ry6s21p",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230329000059-ry6s21p",
				"updated": "20230329000107"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {\n\t\tif (pvs.isEmpty()) {\n\t\t\treturn;\n\t\t}\n \n\t\tif (System.getSecurityManager() != null \u0026\u0026 bw instanceof BeanWrapperImpl) {\n\t\t\t((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());\n\t\t}\n \n\t\tMutablePropertyValues mpvs = null;\n\t\tList\u003cPropertyValue\u003e original;\n\t\t// 如果pvs 是 MutablePropertyValues 类型的封装\n\t\tif (pvs instanceof MutablePropertyValues) {\n\t\t\tmpvs = (MutablePropertyValues) pvs;\n\t\t\t// 如果 mpv 中的值类型已经转换完毕，则可以直接设置到BeanWrapper 中\n\t\t\tif (mpvs.isConverted()) {\n\t\t\t\t// Shortcut: use the pre-converted values as-is.\n\t\t\t\ttry {\n\t\t\t\t\tbw.setPropertyValues(mpvs);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Error setting property values\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 保存原始值，等待类型转换\n\t\t\toriginal = mpvs.getPropertyValueList();\n\t\t}\n\t\telse {\n\t\t\t// 保存原始值，等待类型转换\n\t\t\toriginal = Arrays.asList(pvs.getPropertyValues());\n\t\t}\n\t\t// 获取类型转换器\n\t\tTypeConverter converter = getCustomTypeConverter();\n\t\tif (converter == null) {\n\t\t\tconverter = bw;\n\t\t}\n\t\tBeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);\n \n\t\t// Create a deep copy, resolving any references for values.\n\t\t// 准备进行深拷贝\n\t\tList\u003cPropertyValue\u003e deepCopy = new ArrayList\u003c\u003e(original.size());\n\t\tboolean resolveNecessary = false;\n\t\t// 遍历属性，将属性转换为对应类的对应属性类型\n\t\tfor (PropertyValue pv : original) {\n\t\t\t// 如果已经转换之后直接保存\n\t\t\tif (pv.isConverted()) {\n\t\t\t\tdeepCopy.add(pv);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// 进行类型转换\n\t\t\t\tString propertyName = pv.getName();\n\t\t\t\tObject originalValue = pv.getValue();\n\t\t\t\tif (originalValue == AutowiredPropertyMarker.INSTANCE) {\n\t\t\t\t\tMethod writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod();\n\t\t\t\t\tif (writeMethod == null) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Autowire marker for property without write method: \" + pv);\n\t\t\t\t\t}\n\t\t\t\t\toriginalValue = new DependencyDescriptor(new MethodParameter(writeMethod, 0), true);\n\t\t\t\t}\n\t\t\t\tObject resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);\n\t\t\t\tObject convertedValue = resolvedValue;\n\t\t\t\n\t\t\t\tboolean convertible = bw.isWritableProperty(propertyName) \u0026\u0026\n\t\t\t\t\t\t!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);\n\t\t\t\tif (convertible) {\n\t\t\t\t\tconvertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);\n\t\t\t\t}\n\t\t\t\t// Possibly store converted value in merged bean definition,\n\t\t\t\t// in order to avoid re-conversion for every created bean instance.\n\t\t\t\tif (resolvedValue == originalValue) {\n\t\t\t\t\tif (convertible) {\n\t\t\t\t\t\tpv.setConvertedValue(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tdeepCopy.add(pv);\n\t\t\t\t}\n\t\t\t\telse if (convertible \u0026\u0026 originalValue instanceof TypedStringValue \u0026\u0026\n\t\t\t\t\t\t!((TypedStringValue) originalValue).isDynamic() \u0026\u0026\n\t\t\t\t\t\t!(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {\n\t\t\t\t\tpv.setConvertedValue(convertedValue);\n\t\t\t\t\tdeepCopy.add(pv);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolveNecessary = true;\n\t\t\t\t\tdeepCopy.add(new PropertyValue(pv, convertedValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (mpvs != null \u0026\u0026 !resolveNecessary) {\n\t\t\tmpvs.setConverted();\n\t\t}\n \n\t\t// Set our (possibly massaged) deep copy.\n\t\ttry {\n\t\t\tbw.setPropertyValues(new MutablePropertyValues(deepCopy));\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Error setting property values\", ex);\n\t\t}\n\t}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230329000115-tbis17o",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230329000115-tbis17o",
				"updated": "20230329000115"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "三、总结"
				}
			]
		},
		{
			"ID": "20230329000115-1sidtbh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230329000115-1sidtbh",
				"updated": "20230329000115"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "populateBean 在bean创建结束之后，完成了对 bean属性的注入。根据byName、byType 的不同类型注入有不同的解析方式。"
				}
			]
		},
		{
			"ID": "20230329004907-vuy2v8t",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230329004907-vuy2v8t"
			}
		}
	]
}