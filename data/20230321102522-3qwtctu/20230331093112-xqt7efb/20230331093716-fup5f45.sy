{
	"ID": "20230331093716-fup5f45",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230331093716-fup5f45",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20230331093716-8vzods6\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230331093716-qp2v04q\u0026quot;,\u0026quot;scrollTop\u0026quot;:10924,\u0026quot;focusId\u0026quot;:\u0026quot;20230331093716-8vzods6\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0}",
		"title": "Design patterns in Spring Framework - part 1",
		"updated": "20230331093752"
	},
	"Children": [
		{
			"ID": "20230331093716-8vzods6",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331093716-8vzods6",
				"updated": "20230331093716"
			}
		},
		{
			"ID": "20230331093716-kf3wftu",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230331093716-kf3wftu",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"ID": "20230331093716-ezywxtx",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331093716-ezywxtx",
						"updated": "20230331093716"
					},
					"Children": [
						{
							"ID": "20230331093716-d0706qo",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331093716-d0706qo",
								"updated": "20230331093716"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://www.waitingforcode.com/spring-framework/design-patterns-in-spring-framework-part-1/read",
									"TextMarkTextContent": "https://www.waitingforcode.com/spring-framework/design-patterns-in-spring-framework-part-1/read"
								}
							]
						}
					]
				},
				{
					"ID": "20230331093716-rvwe1em",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331093716-rvwe1em",
						"updated": "20230331093716"
					},
					"Children": [
						{
							"ID": "20230331093716-ewtlu6l",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331093716-ewtlu6l",
								"updated": "20230331093716"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Design patterns help to follow good practices of programming. Spring framework, as one of the most popular web frameworks, also uses some of them."
								}
							]
						}
					]
				},
				{
					"ID": "20230331093716-rlygo7y",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331093716-rlygo7y",
						"updated": "20230331093716"
					},
					"Children": [
						{
							"ID": "20230331093716-h5xyxfk",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331093716-h5xyxfk",
								"updated": "20230331093716"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2023-03-31 09:37:16"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230331093716-br328jk",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331093716-br328jk",
				"updated": "20230331093716"
			}
		},
		{
			"ID": "20230331093716-d2ho12k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-d2ho12k",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Design patterns help to follow good practices of programming. Spring framework, as one of the most popular web frameworks, also uses some of them."
				}
			]
		},
		{
			"ID": "20230331093716-rxpz2r7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-rxpz2r7",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "â€‹"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/deponc_book-20230331093716-b1ybku2.jpg"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "â€‹"
				}
			]
		},
		{
			"ID": "20230331093716-nq7362r",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230331093716-nq7362r",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "New ebook ðŸ”¥"
				}
			]
		},
		{
			"ID": "20230331093716-di6zakp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-di6zakp",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Data engineering patterns on the cloud"
				}
			]
		},
		{
			"ID": "20230331093716-0za5xzh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-0za5xzh",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Learn 84 ways to solve common data engineering problems with cloud services."
				}
			]
		},
		{
			"ID": "20230331093716-j2d6bjl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-j2d6bjl",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "ðŸ‘‰ "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://dataengineeringpatternsonthecloud.com/#form-section",
					"TextMarkTextContent": "I want my copy"
				}
			]
		},
		{
			"ID": "20230331093716-g0appco",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-g0appco",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "This article will show how which design patterns are used in Spring Framework. It's the first part of 5 articles dedicated to this subject. This time we'll discover 4 design patterns used in Spring framework: interpreted, builder, factory method and abstract factory. Each part will, first, explain the principles of given pattern. At the second time, a example of Spring use will be done."
				}
			]
		},
		{
			"ID": "20230331093716-ybgmz6y",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331093716-ybgmz6y",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring design pattern - interpreter"
				}
			]
		},
		{
			"ID": "20230331093716-kucjb1c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-kucjb1c",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "In real world, we, humans, need to interpret gestures. They can have, regarding to the culture, a different signification. It's our interpretation which gives them a meaning. In programming we need also to analyze one thing and decide what does it mean. We can do it with â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "interpreted design pattern"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹."
				}
			]
		},
		{
			"ID": "20230331093716-zfxkuft",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-zfxkuft",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "This pattern is based on expression and evaluator parts. The first one represents a thing to analyze. This analyze is made by evaluator which know the meaning of characters composing the expression. The operation of undesrtanding is made inside a context."
				}
			]
		},
		{
			"ID": "20230331093716-8157szp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-8157szp",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring uses this pattern mainly in "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "Spring Expression Language"
				},
				{
					"Type": "NodeText",
					"Data": " (SpEL). To remind quickly, SpEL is a language those expressions are analyzed and executed by Spring's "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.expression.ExpressionParser"
				},
				{
					"Type": "NodeText",
					"Data": " implementations. These implementations take SpEL expressions given as Strings and translate them into instances of â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.expression.Expression"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. The context component is represented by "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.expression.EvaluationContext"
				},
				{
					"Type": "NodeText",
					"Data": " implementations, as for example: StandardEvaluationContext."
				}
			]
		},
		{
			"ID": "20230331093716-ykqwrr3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-ykqwrr3",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "An example of SpEL can look like that:"
				}
			]
		},
		{
			"ID": "20230331093716-hggu80k",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331093716-hggu80k",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Writer writer = new Writer();\nwriter.setName(\"Writer's name\");\nStandardEvaluationContext modifierContext = new StandardEvaluationContext(subscriberContext);\nmodifierContext.setVariable(\"name\", \"Overriden writer's name\");\nparser.parseExpression(\"name = #name\").getValue(modifierContext);\nSystem.out.println(\"writer's name is : \" + writer.getName());\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331093716-52fd0rc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-52fd0rc",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "The output should print \"Overriden writer's name\". As you can see, the property of one object was modified through an expression \"name = #name\" which is understandable only by ExpressionParser thanks to provided context (modifierContext instance in previous sample)."
				}
			]
		},
		{
			"ID": "20230331093716-r03snpl",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331093716-r03snpl",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring design pattern - builder"
				}
			]
		},
		{
			"ID": "20230331093716-rduhzu0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-rduhzu0",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Builder design pattern"
				},
				{
					"Type": "NodeText",
					"Data": " is the first pattern belonging to the family of creational patterns. This pattern is used to simplify the construction of complex objects. To understand the concept, imagine an object illustrating programmer's CV. In this object we want to store the personal information (first name, address etc.) as well as technical information (knowing languages, realized projects etc.). The construction of this object could look like:"
				}
			]
		},
		{
			"ID": "20230331093716-c9hqd9l",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331093716-c9hqd9l",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// with constructor\nProgrammer programmer = new Programmer(\"first name\", \"last name\", \"address Street 39\", \"ZIP code\", \"City\", \"Country\", birthDateObject, new String[] {\"Java\", \"PHP\", \"Perl\", \"SQL\"}, new String[] {\"CRM system\", \"CMS system for government\"});\n// or with setters\nProgrammer programmer = new Programmer();\nprogrammer.setName(\"first name\");\nprogrammer.setLastName(\"last name\");\n// ... multiple lines after\nprogrammer.setProjects(new String[] {\"CRM system\", \"CMS system for government\"});\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331093716-wbe15ix",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-wbe15ix",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Builder allows us to decompose clearly the object construction by using internal builder object that passes the values to a parent class. In the case of our programmer, a builder could look like:"
				}
			]
		},
		{
			"ID": "20230331093716-m6emc06",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331093716-m6emc06",
				"updated": "20230331093727"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class BuilderTest {\n\n  @Test\n  public void test() {\n    Programmer programmer = new Programmer.ProgrammerBuilder().setFirstName(\"F\").setLastName(\"L\")\n            .setCity(\"City\").setZipCode(\"0000A\").setAddress(\"Street 39\")\n            .setLanguages(new String[] {\"bash\", \"Perl\"}).setProjects(new String[] {\"Linux kernel\"}).build();\n    assertTrue(\"Programmer should be 'F L' but was '\"+ programmer+\"'\", programmer.toString().equals(\"F L\"));\n  }\n\n}\n\nclass Programmer {\n  private String firstName;\n  private String lastName;\n  private String address;\n  private String zipCode;\n  private String city;\n  private String[] languages;\n  private String[] projects;\n  \n  private Programmer(String fName, String lName, String addr, String zip, String city, String[] langs, String[] projects) {\n    this.firstName = fName;\n    this.lastName = lName;\n    this.address = addr;\n    this.zipCode = zip;\n    this.city = city;\n    this.languages = langs;\n    this.projects = projects;\n  }\n  \n  public static class ProgrammerBuilder {\n    private String firstName;\n    private String lastName;\n    private String address;\n    private String zipCode;\n    private String city;\n    private String[] languages;\n    private String[] projects;\n  \n    public ProgrammerBuilder setFirstName(String firstName) {\n      this.firstName = firstName;\n      return this;\n    }\n  \n    public ProgrammerBuilder setLastName(String lastName) {\n      this.lastName = lastName;\n      return this;\n    }\n  \n    public ProgrammerBuilder setAddress(String address) {\n      this.address = address;\n      return this;\n    }\n  \n    public ProgrammerBuilder setZipCode(String zipCode) {\n      this.zipCode = zipCode;\n      return this;\n    }\n  \n    public ProgrammerBuilder setCity(String city) {\n      this.city = city;\n      return this;\n    }\n  \n    public ProgrammerBuilder setLanguages(String[] languages) {\n      this.languages = languages;\n      return this;\n    }\n    public ProgrammerBuilder setProjects(String[] projects) {\n      this.projects = projects;\n      return this;\n    }\n  \n    public Programmer build() {\n      return new Programmer(firstName, lastName, address, zipCode, city, languages, projects);\n    } \n  }\n  \n  @Override\n  public String toString() {\n    return this.firstName + \" \"+this.lastName;\n  }\n  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331093716-nzi7ftm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-nzi7ftm",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "As you can see, the complexity of object construction is hidden behind a builder, an internal static class that accepts the chained method invocation. In Spring, we can retrieve this logic in "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.beans.factory.support.BeanDefinitionBuilder"
				},
				{
					"Type": "NodeText",
					"Data": " class. It's a class that allows us to define a bean programatically. As we could see it in article about "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://www.waitingforcode.com/spring-framework/bean-factory-post-processor-beans-in-spring/read",
					"TextMarkTextContent": "bean factory post processors"
				},
				{
					"Type": "NodeText",
					"Data": ", BeanDefinitionBuilder contains several methods which set the values for associated implementation of "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "AbstractBeanDefinition"
				},
				{
					"Type": "NodeText",
					"Data": " abstract class, as scope, factory method, properties etc. To see how does it work, take a look on these methods:"
				}
			]
		},
		{
			"ID": "20230331093716-l54k1yf",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331093716-l54k1yf",
				"updated": "20230331093732"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class BeanDefinitionBuilder {\n\t   /**\n    * The {@code BeanDefinition} instance we are creating.\n    */\n  private AbstractBeanDefinition beanDefinition;\n\n  // ... some not important methods for this article\n\n  // Some of building methods\n  /**\n    * Set the name of the parent definition of this bean definition.\n    */\n  public BeanDefinitionBuilder setParentName(String parentName) {\n    this.beanDefinition.setParentName(parentName);\n    return this;\n  }\n\n  /**\n    * Set the name of the factory method to use for this definition.\n    */\n  public BeanDefinitionBuilder setFactoryMethod(String factoryMethod) {\n    this.beanDefinition.setFactoryMethodName(factoryMethod);\n    return this;\n  }\n\n  /**\n    * Add an indexed constructor arg value. The current index is tracked internally\n    * and all additions are at the present point.\n    * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}\n    */\n  @Deprecated\n  public BeanDefinitionBuilder addConstructorArg(Object value) {\n    return addConstructorArgValue(value);\n  }\n\n  /**\n    * Add an indexed constructor arg value. The current index is tracked internally\n    * and all additions are at the present point.\n    */\n  public BeanDefinitionBuilder addConstructorArgValue(Object value) {\n    this.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(\n                    this.constructorArgIndex++, value);\n    return this;\n  }\n\n  /**\n    * Add a reference to a named bean as a constructor arg.\n    * @see #addConstructorArgValue(Object)\n    */\n  public BeanDefinitionBuilder addConstructorArgReference(String beanName) {\n    this.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(\n                    this.constructorArgIndex++, new RuntimeBeanReference(beanName));\n    return this;\n  }\n\n  /**\n    * Add the supplied property value under the given name.\n    */\n  public BeanDefinitionBuilder addPropertyValue(String name, Object value) {\n    this.beanDefinition.getPropertyValues().add(name, value);\n    return this;\n  }\n\n  /**\n    * Add a reference to the specified bean name under the property specified.\n    * @param name the name of the property to add the reference to\n    * @param beanName the name of the bean being referenced\n    */\n  public BeanDefinitionBuilder addPropertyReference(String name, String beanName) {\n    this.beanDefinition.getPropertyValues().add(name, new RuntimeBeanReference(beanName));\n    return this;\n  }\n\n  /**\n    * Set the init method for this definition.\n    */\n  public BeanDefinitionBuilder setInitMethodName(String methodName) {\n    this.beanDefinition.setInitMethodName(methodName);\n    return this;\n  }\n\n  // Methods that can be used to construct BeanDefinition\n  /**\n    * Return the current BeanDefinition object in its raw (unvalidated) form.\n    * @see #getBeanDefinition()\n    */\n  public AbstractBeanDefinition getRawBeanDefinition() {\n    return this.beanDefinition;\n  }\n\n  /**\n    * Validate and return the created BeanDefinition object.\n    */\n  public AbstractBeanDefinition getBeanDefinition() {\n    this.beanDefinition.validate();\n    return this.beanDefinition;\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331093716-nv9pq18",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331093716-nv9pq18",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring design pattern - factory method"
				}
			]
		},
		{
			"ID": "20230331093716-j7isi8q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-j7isi8q",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "The second member of creational family is â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "factory method design pattern"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. It's completely adapted to working with dynamic environments as Spring framework. In fact, this pattern allows the initialization of object through a public static method, called factory method. In this conception, we need to define an interface to create the object. But the creation is made by the classes using the concerned object."
				}
			]
		},
		{
			"ID": "20230331093716-0hlv6pm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-0hlv6pm",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "But before jumping to Spring world, let's make a sample with Java code:"
				}
			]
		},
		{
			"ID": "20230331093716-u6pjhod",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331093716-u6pjhod",
				"updated": "20230331093738"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class FactoryMethodTest {\n\n  @Test\n  public void test() {\n    Meal fruit = Meal.valueOf(\"banana\");\n    Meal vegetable = Meal.valueOf(\"carrot\");\n    assertTrue(\"Banana should be a fruit but is \"+fruit.getType(), fruit.getType().equals(\"fruit\"));\n    assertTrue(\"Carrot should be a vegetable but is \"+vegetable.getType(), vegetable.getType().equals(\"vegetable\"));\n  }\n\n}\n\nclass Meal {\n    \n  private String type;\n\n  public Meal(String type) {\n    this.type = type;\n  }\n\n  public String getType() {\n    return this.type;\n  }\n\n  // Example of factory method - different object is created depending on current context\n  public static Meal valueOf(String ingredient) {\n    if (ingredient.equals(\"banana\")) {\n      return new Meal(\"fruit\");\n    }\n    return new Meal(\"vegetable\");\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331093716-9p1hqce",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-9p1hqce",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "In Spring we can create beans thanks to specified factory method. This method acts exactly as valueOf method seen in previous code sample. It's static and can take no or multiple parameters. To better understand the case, let's take a look on real example. The configuration first:"
				}
			]
		},
		{
			"ID": "20230331093716-cdpn7if",
			"Type": "NodeHTMLBlock",
			"Data": "\u003cpre class=\"xml hljs\"\u003e\u003cbean id=\"welcomerBean\" class=\"com.mysite.Welcomer\" factory-method=\"createWelcomer\"\u003e\n    \u003cconstructor-arg ref=\"messagesLocator\"\u003e\n\u003c/constructor-arg\u003e\u003c/bean\u003e\n\n\u003cbean id=\"messagesLocator\" class=\"com.mysite.MessageLocator\"\u003e\n\t\u003cproperty name=\"messages\" value=\"messages_file.properties\"\u003e\n\u003c/property\u003e\u003c/bean\u003e\n\u003c/pre\u003e",
			"Properties": {
				"id": "20230331093716-cdpn7if",
				"updated": "20230331093716"
			}
		},
		{
			"ID": "20230331093716-746b7gd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-746b7gd",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "And now the bean concerned by this initialization:"
				}
			]
		},
		{
			"ID": "20230331093716-qyy95w7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331093716-qyy95w7",
				"updated": "20230331093743"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class Welcomer {\n  private String message;\n  \n  public Welcomer(String message) {\n    this.message = message;\n  }\n\n  public static Welcomer createWelcomer(MessageLocator messagesLocator) {\n    Calendar cal = Calendar.getInstance();\n    String msgKey = \"welcome.pm\";\n    if (cal.get(Calendar.AM_PM) == Calendar.AM) {\n      msgKey = \"welcome.am\";\n    }\n    return new Welcomer(messagesLocator.getMessageByKey(msgKey));\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331093716-inwf5jk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-inwf5jk",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "When Spring will construct welcomerBean, it won't make it through classical constructor, but through defined static factory method, createWelcomer. Note also that this method accepts some of parameters (instance of MessageLocator bean holding all available messages) thanks to  tag, usually reserved to classic constructors."
				}
			]
		},
		{
			"ID": "20230331093716-65u6muz",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331093716-65u6muz",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring design pattern - abstract factory"
				}
			]
		},
		{
			"ID": "20230331093716-ydqujur",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-ydqujur",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "The last one, â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "abstract factory design pattern"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹, looks similar to factory method. The difference is that we can consider abstract factory as a factory in industrial meaning of this word, ie. as something that provides needed objects. Components of factory are: abstract factory, abstract product, product and client. To be more precise, abstract factory defines the way of constructing objects. Abstract product is a result of this construction. Product is a concrete result of the same construction. Client is somebody who demands the creation of products to abstract factory."
				}
			]
		},
		{
			"ID": "20230331093716-kywczm4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-kywczm4",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Once again, before going into Spring details, we'll start by illustrating this concept through sample Java code:"
				}
			]
		},
		{
			"ID": "20230331093716-qhre9cx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331093716-qhre9cx",
				"updated": "20230331093747"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class FactoryTest {\n\n  // Test method which is the client\n  @Test\n  public void test() {\n    Kitchen factory = new KitchenFactory();\n    KitchenMeal meal = factory.getMeal(\"P.1\");\n    KitchenMeal dessert = factory.getDessert(\"I.1\");\n    assertTrue(\"Meal's name should be 'protein meal' and was '\"+meal.getName()+\"'\", meal.getName().equals(\"protein meal\"));\n    assertTrue(\"Dessert's name should be 'ice-cream' and was '\"+dessert.getName()+\"'\", dessert.getName().equals(\"ice-cream\"));\n  }\n\n}\n\n// abstract factory\nabstract class Kitchen {\n  public abstract KitchenMeal getMeal(String preferency);\n  public abstract KitchenMeal getDessert(String preferency);\n}\n\n// concrete factory\nclass KitchenFactory extends Kitchen {\n  @Override\n  public KitchenMeal getMeal(String preferency) {\n    if (preferency.equals(\"F.1\")) {\n      return new FastFoodMeal();\n    } else if (preferency.equals(\"P.1\")) {\n      return new ProteinMeal();\n    }\n    return new VegetarianMeal();\n  }\n\n  @Override\n  public KitchenMeal getDessert(String preferency) {\n    if (preferency.equals(\"I.1\")) {\n      return new IceCreamMeal();\n    }\n    return null;\n  }\n}\n\n// abstract product\nabstract class KitchenMeal {\n  public abstract String getName();\n}\n\n// concrete products\nclass ProteinMeal extends KitchenMeal {\n  @Override\n  public String getName() {\n    return \"protein meal\";\n  }\n}\n\nclass VegetarianMeal extends KitchenMeal {\n  @Override\n  public String getName() {\n    return \"vegetarian meal\";\n  }\n}\n\nclass FastFoodMeal extends KitchenMeal {\n  @Override\n  public String getName() {\n    return \"fast-food meal\";\n  }\n}\n\nclass IceCreamMeal extends KitchenMeal {\n  @Override\n  public String getName() {\n    return \"ice-cream\";\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331093716-1xzdzy3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-1xzdzy3",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "As we can see in this example, abstract factory encapsulates the creation of objects. The objects creation can be make as well with factory method pattern as with classic constructor use. In Spring, the example of factory is â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.beans.factory.BeanFactory"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. Through its implementations we can access beans from Spring's container. Depending of adopted strategy, "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "getBean"
				},
				{
					"Type": "NodeText",
					"Data": " method can return already created object (shared instance, singleton scope) or initialize new one (prototype scope). Among the implementations of BeanFactory we can distinguish: ClassPathXmlApplicationContext, XmlWebApplicationContext, StaticWebApplicationContext, StaticPortletApplicationContext, GenericApplicationContext, StaticApplicationContext. Below you can find one example of use of factory in Spring web applications:"
				}
			]
		},
		{
			"ID": "20230331093716-38i5brv",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331093716-38i5brv",
				"updated": "20230331093752"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations={\"file:test-context.xml\"})\npublic class TestProduct {\n    \n  @Autowired\n  private BeanFactory factory;\n  \n  @Test\n  public void test() {\n    System.out.println(\"Concrete factory is: \"+factory.getClass());\n    assertTrue(\"Factory can't be null\", factory != null);\n    ShoppingCart cart = (ShoppingCart) factory.getBean(\"shoppingCart\");\n    assertTrue(\"Shopping cart object can't be null\", cart != null);\n    System.out.println(\"Found shopping cart bean:\"+cart.getClass());\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331093716-fu1quhy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-fu1quhy",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "In this case, the abstract factory is represented by BeanFactory interface. The concrete factory is printed in the first System.out and is the instance of â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.beans.factory.support.DefaultListableBeanFactory"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. The abstract product of it is an Object. Concrete product, in our case, is abstract product (Object) casted to ShoppingCart instance."
				}
			]
		},
		{
			"ID": "20230331093716-ffhyz8r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-ffhyz8r",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "This first article introduces to extremely interesting world of correctly organized programming thanks to design patterns. Here, we can see the use of interpreter, builder, factory method and factory in Spring framework. The first one is there to helps to interpret texts expressed in SpEL. The three last patterns belong to the family of creational design patterns and theirs main purpose in Spring consists on simplify the creation of objects. They do that by decomposing the initialization of complex objects (builder) or by centralizing the initialization at the commun point."
				}
			]
		},
		{
			"ID": "20230331093716-qp2v04q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093716-qp2v04q",
				"updated": "20230331093716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "The comments are moderated. I publish them when I answer, so don't worry if you don't see yours immediately :)"
				}
			]
		}
	]
}