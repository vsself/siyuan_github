{
	"ID": "20230331094046-55jnk26",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230331094046-55jnk26",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20230331094046-xmaieq9\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230331094046-0fwq0fx\u0026quot;,\u0026quot;scrollTop\u0026quot;:159.3333282470703,\u0026quot;focusId\u0026quot;:\u0026quot;20230331094046-xmaieq9\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0}",
		"title": "Design patterns in Spring Framework - part 4",
		"updated": "20230331094132"
	},
	"Children": [
		{
			"ID": "20230331094046-xmaieq9",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331094046-xmaieq9",
				"updated": "20230331094046"
			}
		},
		{
			"ID": "20230331094046-0pfyjfl",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230331094046-0pfyjfl",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"ID": "20230331094046-nou16nv",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331094046-nou16nv",
						"updated": "20230331094046"
					},
					"Children": [
						{
							"ID": "20230331094046-lh6ey4w",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331094046-lh6ey4w",
								"updated": "20230331094046"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://www.waitingforcode.com/spring-framework/design-patterns-in-spring-Framework-part-4/read",
									"TextMarkTextContent": "https://www.waitingforcode.com/spring-framework/design-patterns-in-spring-Framework-part-4/read"
								}
							]
						}
					]
				},
				{
					"ID": "20230331094046-e2189vb",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331094046-e2189vb",
						"updated": "20230331094046"
					},
					"Children": [
						{
							"ID": "20230331094046-ur9qsk4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331094046-ur9qsk4",
								"updated": "20230331094046"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "This article is the 4th about design patterns used in Spring framework. It'll present new 3 patterns implemented in this framework."
								}
							]
						}
					]
				},
				{
					"ID": "20230331094046-de2n1gm",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331094046-de2n1gm",
						"updated": "20230331094046"
					},
					"Children": [
						{
							"ID": "20230331094046-r07bi2b",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331094046-r07bi2b",
								"updated": "20230331094046"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2023-03-31 09:40:46"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230331094046-eztysdd",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331094046-eztysdd",
				"updated": "20230331094046"
			}
		},
		{
			"ID": "20230331094046-rawh4wx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-rawh4wx",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "This article is the 4th about design patterns used in Spring framework. It'll present new 3 patterns implemented in this framework."
				}
			]
		},
		{
			"ID": "20230331094046-paodlj1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-paodlj1",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "â€‹"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/deponc_book-20230331094046-00c9xzk.jpg"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "â€‹"
				}
			]
		},
		{
			"ID": "20230331094046-57nuj54",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230331094046-57nuj54",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "New ebook ðŸ”¥"
				}
			]
		},
		{
			"ID": "20230331094046-wr73nxw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-wr73nxw",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Data engineering patterns on the cloud"
				}
			]
		},
		{
			"ID": "20230331094046-66qhagl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-66qhagl",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Learn 84 ways to solve common data engineering problems with cloud services."
				}
			]
		},
		{
			"ID": "20230331094046-fkjrrq1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-fkjrrq1",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "ðŸ‘‰ "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://dataengineeringpatternsonthecloud.com/#form-section",
					"TextMarkTextContent": "I want my copy"
				}
			]
		},
		{
			"ID": "20230331094046-thy57b5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-thy57b5",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "At the begin, we'll discover 2 patterns belonging to the family of structural patterns: adapter and decorator. At the 3rd and the last part, we'll talk about creational design pattern which is singleton."
				}
			]
		},
		{
			"ID": "20230331094046-rgub5ps",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331094046-rgub5ps",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring design pattern - adapter"
				}
			]
		},
		{
			"ID": "20230331094046-ul9s2ue",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-ul9s2ue",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Adapter design pattern"
				},
				{
					"Type": "NodeText",
					"Data": " used when we need to adapt the interface to given situation without modifying its behavior. It means that we'll change used object without changing mechanism before invoking this object. To illustrate it in real world, imagine the situation when you want to make a hole with a drill. To make a small hole, you'll use small drill bit and to make a big one, big drill bit. You can see it in below code:"
				}
			]
		},
		{
			"ID": "20230331094046-usb6r5h",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094046-usb6r5h",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class AdapterTest {\n\n  public static void main(String[] args) {\n    HoleMaker maker = new HoleMakerImpl();\n    maker.makeHole(1);\n    maker.makeHole(2);\n    maker.makeHole(30);\n    maker.makeHole(40);\n  }\n}\n\ninterface HoleMaker {\n  public void makeHole(int diameter);\n}\n\ninterface DrillBit {\n  public void makeSmallHole();\n  public void makeBigHole();\n}\n\n// Two adaptee objects\nclass BigDrillBit implements DrillBit {\n    \n  @Override\n  public void makeSmallHole() {\n    // do nothing\n  }\n\n  @Override\n  public void makeBigHole() {\n    System.out.println(\"Big hole is made byt WallBigHoleMaker\");\n  }\n}\n\nclass SmallDrillBit implements DrillBit {\n    \n  @Override\n  public void makeSmallHole() {\n    System.out.println(\"Small hole is made byt WallSmallHoleMaker\");\n  }\n\n  @Override\n  public void makeBigHole() {\n    // do nothing\n  }\n}\n\n// Adapter class\nclass Drill implements HoleMaker {\n\n  private DrillBit drillBit;\n\n  public Drill(int diameter) {\n    drillBit = getMakerByDiameter(diameter);\n  }\n\n  @Override\n  public void makeHole(int diameter) {\n    if (isSmallDiameter(diameter)) {\n            drillBit.makeSmallHole();\n    } else {\n            drillBit.makeBigHole();\n    }\n  }\n\n  private DrillBit getMakerByDiameter(int diameter) {\n    if (isSmallDiameter(diameter)) {\n            return new SmallDrillBit();\n    }\n    return new BigDrillBit();\n  }\n\n  private boolean isSmallDiameter(int diameter) {\n    return diameter \u003c 10;\n  }\n}\n\n// Client class\nclass HoleMakerImpl implements HoleMaker {\n    \n  @Override\n  public void makeHole(int diameter) {\n    HoleMaker maker = new Drill(diameter);\n    maker.makeHole(diameter);\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094046-osl0zz7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-osl0zz7",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "This code will print:"
				}
			]
		},
		{
			"ID": "20230331094046-w1rvqdt",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094046-w1rvqdt",
				"updated": "20230331094059"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Small hole is made byt SmallDrillBit\nSmall hole is made byt SmallDrillBit\nBig hole is made byt BigDrillBit\nBig hole is made byt BigDrillBit\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094046-gny622g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-gny622g",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "As you can see, the hole is made with adapted DrillBit object. If the hole's diameter is smaller than 10, we use SmallDrillBit. If it's bigger, we use BigDrillBit."
				}
			]
		},
		{
			"ID": "20230331094046-xato90d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-xato90d",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring uses adapter design pattern to handle "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "load-time-weaving"
				},
				{
					"Type": "NodeText",
					"Data": " in different servlet containers. Load-time-weaving is used in Aspect-Oriented Programming (AOP) to inject AspectJ's aspects to byte code during class loading. Another ways to inject these aspects are compile-time injection or static injection on already compiled classes."
				}
			]
		},
		{
			"ID": "20230331094046-yy1y0mr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-yy1y0mr",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "A good illustration of this is the case of JBoss, included in package â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.instrument.classloading.jboss"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. We retrieve there JBossLoadTimeWeaver class responsible for weaving management for JBoss container. However, the class loader is different for JBoss 6 (uses JBossMCAdapter instance) and JBoss 7/8 (uses JBossModulesAdapter instance). Depending to JBoss version, we initialize corresponding adapter in JBossLoadTimeWeaver constructor (exactly as for Drill's constructor in our example):"
				}
			]
		},
		{
			"ID": "20230331094046-kcgd0y1",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094046-kcgd0y1",
				"updated": "20230331094102"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public JBossLoadTimeWeaver(ClassLoader classLoader) {\n  private final JBossClassLoaderAdapter adapter;\n\n  Assert.notNull(classLoader, \"ClassLoader must not be null\");\n  if (classLoader.getClass().getName().startsWith(\"org.jboss.modules\")) {\n    // JBoss AS 7 or WildFly 8\n    this.adapter = new JBossModulesAdapter(classLoader);\n  }\n  else {\n    // JBoss AS 6\n    this.adapter = new JBossMCAdapter(classLoader);\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094046-u38eejz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-u38eejz",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Further, this adapter instance is used to make weaving operations depending on running servlet container version:"
				}
			]
		},
		{
			"ID": "20230331094046-ml2to3i",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094046-ml2to3i",
				"updated": "20230331094105"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Override\npublic void addTransformer(ClassFileTransformer transformer) {\n  this.adapter.addTransformer(transformer);\n}\n\n@Override\npublic ClassLoader getInstrumentableClassLoader() {\n  return this.adapter.getInstrumentableClassLoader();\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094046-reruw7a",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331094046-reruw7a",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring design pattern - decorator"
				}
			]
		},
		{
			"ID": "20230331094046-a0w7hwa",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-a0w7hwa",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "The second design pattern described here looks similar to adapter. It's â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "decorator"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. The main role if this design pattern is to add supplementary role to given object. In the real world, the illustration of this pattern should be a coffee. Usually black and strong, you can add (\"decorate\" it with) sugar and milk to get coffee less stronger. Coffee is here decorated object and sugar with milk are the decorators. Below you can find an example showing this coffee decoration:"
				}
			]
		},
		{
			"ID": "20230331094046-1zovzn2",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094046-1zovzn2",
				"updated": "20230331094108"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class DecoratorSample {\n\n  @Test\n  public void test() {\n    Coffee sugarMilkCoffee=new MilkDecorator(new SugarDecorator(new BlackCoffee()));\n    assertEquals(sugarMilkCoffee.getPrice(), 6d, 0d);\n  }\n}\n\n// decorated\nabstract class Coffee{\n  protected int candied=0;\n  protected double price=2d;\n  public abstract int makeMoreCandied();\n  public double getPrice(){\n    return this.price;\n  }\n  public void setPrice(double price){\n    this.price+=price;\n  }\n}\nclass BlackCoffee extends Coffee{\n  @Override\n  public int makeMoreCandied(){\n    return 0;\n  }\n  @Override\n  public double getPrice(){\n    return this.price;\n  }\n}\n\n// abstract decorator\nabstract class CoffeeDecorator extends Coffee{\n  protected Coffee coffee;\n  public CoffeeDecorator(Coffee coffee){\n    this.coffee=coffee;\n  }\n  @Override\n  public double getPrice(){\n    return this.coffee.getPrice();\n  }\n  @Override\n  public int makeMoreCandied(){\n    return this.coffee.makeMoreCandied();\n  }\n}\n\n// concrete decorators\nclass MilkDecorator extends CoffeeDecorator{\n  public MilkDecorator(Coffee coffee){\n    super(coffee);\n  }\n  @Override\n  public double getPrice(){\n    return super.getPrice()+1d;\n  }\n  @Override\n  public int makeMoreCandied(){\n    return super.makeMoreCandied()+1;\n  }\n}\nclass SugarDecorator extends CoffeeDecorator{\n  public SugarDecorator(Coffee coffee){\n    super(coffee);\n  }\n  @Override\n  public double getPrice(){\n    return super.getPrice()+3d;\n  }\n  @Override\n  public int makeMoreCandied(){\n    return super.makeMoreCandied()+1;\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094046-3cga7ky",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-3cga7ky",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "This sample of decorator is based on invocations of parent methods which change the final property (price and candied level in our case). In Spring we retrieve decorator design pattern in a class handling cache synchronization with Spring-managed transactions. This class is â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.cache.transaction.TransactionAwareCacheDecorator"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹."
				}
			]
		},
		{
			"ID": "20230331094046-5fmqoli",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-5fmqoli",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Which characteristics of this class prove that it's a decorator for "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.cache.Cache"
				},
				{
					"Type": "NodeText",
					"Data": " object ? First of all, exactly as in our coffee example, the TransactionAwareCacheDecorator's constructor takes in parameter decorated object (Cache):"
				}
			]
		},
		{
			"ID": "20230331094046-3uyrglw",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094046-3uyrglw",
				"updated": "20230331094113"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "private final Cache targetCache;\n/**\n * Create a new TransactionAwareCache for the given target Cache.\n * @param targetCache the target Cache to decorate\n */\npublic TransactionAwareCacheDecorator(Cache targetCache) {\n  Assert.notNull(targetCache, \"Target Cache must not be null\");\n  this.targetCache = targetCache;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094046-nqbcnw7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-nqbcnw7",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Secondly, a new behavior is added to decorated Cache. As we can read in the comment of TransactionAwareCacheDecorator, the main purpose of it is to provide synchronization level between cache and Spring transactions. It's achieved thanks to "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.transaction.support.TransactionSynchronizationManager"
				},
				{
					"Type": "NodeText",
					"Data": " in two of Cache methods: put and evict:"
				}
			]
		},
		{
			"ID": "20230331094046-30m33tm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094046-30m33tm",
				"updated": "20230331094116"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Override\npublic void put(final Object key, final Object value) {\n  if (TransactionSynchronizationManager.isSynchronizationActive()) {\n    TransactionSynchronizationManager.registerSynchronization(\n      new TransactionSynchronizationAdapter() {\n        @Override\n        public void afterCommit() {\n          targetCache.put(key, value);\n        }\n    });\n  }\n  else {\n    this.targetCache.put(key, value);\n  }\n}\n\n@Override\npublic void evict(final Object key) {\n  if (TransactionSynchronizationManager.isSynchronizationActive()) {\n          TransactionSynchronizationManager.registerSynchronization(\n            new TransactionSynchronizationAdapter() {\n              @Override\n              public void afterCommit() {\n                targetCache.evict(key);\n              }\n          });\n  }\n  else {\n    this.targetCache.evict(key);\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094046-3m43lgt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-3m43lgt",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "This pattern looks similar to adapter, isn't it ? However, they're both different. As we can see, adapter adapts the object to runtime environment, ie. if we run in JBoss 6, we use different class loader than in JBoss 7. Decorator works every time with the same main object (Cache) and only adds new behaviour to it (as synchronization with Spring transactions in our example)."
				}
			]
		},
		{
			"ID": "20230331094046-er6twts",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331094046-er6twts",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring design pattern - singleton"
				}
			]
		},
		{
			"ID": "20230331094046-fazs67q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-fazs67q",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Now, it's the turn of the very popular design pattern, â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "singleton"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. As we've already explained in the article about "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://www.waitingforcode.com/spring-framework/singleton-and-prototype-beans-in-spring-framework/read",
					"TextMarkTextContent": "singleton and prototype beans in Spring Framework"
				},
				{
					"Type": "NodeText",
					"Data": ", singleton is considered as one from several bean scopes. This scope creates only one instance of given bean in each application context. Unlike signleton design pattern, Spring limits the number of instances to application context. Singleton's design pattern in Java applications limits the quantity of these instances to a whole space managed by given class loader. It means that you can use the same classloader for two Spring's context and retreive two singleton-scoped beans."
				}
			]
		},
		{
			"ID": "20230331094046-jxu3mvo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-jxu3mvo",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Before diving to Spring singletons, let's take a look on Java's singleton example:"
				}
			]
		},
		{
			"ID": "20230331094046-jbn5gmy",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094046-jbn5gmy",
				"updated": "20230331094123"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class SingletonTest {\n\n  @Test\n  public void test() {\n    President president1 = (President) SingletonsHolder.PRESIDENT.getHoldedObject();\n    President president2 = (President) SingletonsHolder.PRESIDENT.getHoldedObject();\n    assertTrue(\"Both references of President should point to the same object\", president1 == president2);\n    System.out.println(\"president1 = \"+president1+\" and president2 = \"+president2);\n    // sample output\n    // president1 = com.waitingforcode.test.President@17414c8 and president2 = com.waitingforcode.test.President@17414c8\n\n  }\n\n}\n\nenum SingletonsHolder {\n  \n  PRESIDENT(new President());\n  \n  private Object holdedObject;\n  \n  private SingletonsHolder(Object o) {\n          this.holdedObject = o;\n  }\n  \n  public Object getHoldedObject() {\n          return this.holdedObject;\n  }\n    \n}\n\nclass President {\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094046-kg7wewt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-kg7wewt",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "This test case proves that only one instance of President holded by SingletonsHolder exists. In Spring, we can find the concept of singletons in bean factory (for example in â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.beans.factory.config.AbstractFactoryBean"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹):"
				}
			]
		},
		{
			"ID": "20230331094046-xao5chf",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094046-xao5chf",
				"updated": "20230331094125"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/**\n * Expose the singleton instance or create a new prototype instance.\n * @see #createInstance()\n * @see #getEarlySingletonInterfaces()\n */\n@Override\npublic final T getObject() throws Exception {\n  if (isSingleton()) {\n    return (this.initialized ? this.singletonInstance : getEarlySingletonInstance());\n  }\n  else {\n    return createInstance();\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094046-nw8439u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-nw8439u",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "We see that when demanded object is treated like singleton, it's initialized only once and returned after every time with the same instance of bean's class. We can see it in given example, similar to our President case seen previously. Tested bean is defined as:"
				}
			]
		},
		{
			"ID": "20230331094046-mmzgyl8",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094046-mmzgyl8",
				"updated": "20230331094129"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "eG1s"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\u003cbean id=\"shoppingCart\" class=\"com.waitingforcode.data.ShoppingCart\" /\u003e\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094046-ktbc3bg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-ktbc3bg",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "And the test case looks like:"
				}
			]
		},
		{
			"ID": "20230331094046-7wogndh",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094046-7wogndh",
				"updated": "20230331094132"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class SingletonSpringTest {\n\n  @Test\n  public void test() {\n    // retreive two different contexts\n    ApplicationContext firstContext = new FileSystemXmlApplicationContext(\"applicationContext-test.xml\");\n    ApplicationContext secondContext = new FileSystemXmlApplicationContext(\"applicationContext-test.xml\");\n  \n    // prove that both contexts are loaded by the same class loader\n    assertTrue(\"Class loaders for both contexts should be the same\", \n      firstContext.getClassLoader() == secondContext.getClassLoader());\n    // compare the objects from different contexts\n    ShoppingCart firstShoppingCart = (ShoppingCart) firstContext.getBean(\"shoppingCart\");\n    ShoppingCart secondShoppingCart = (ShoppingCart) secondContext.getBean(\"shoppingCart\");\n    assertFalse(\"ShoppingCart instances got from different application context shouldn't be the same\", \n      firstShoppingCart == secondShoppingCart);\n  \n    // compare the objects from the same context\n    ShoppingCart firstShoppingCartBis = (ShoppingCart) firstContext.getBean(\"shoppingCart\");\n    assertTrue(\"ShoppingCart instances got from the same application context should be the same\", \n      firstShoppingCart == firstShoppingCartBis);\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094046-jn1y6gd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-jn1y6gd",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "This test case shows the main difference between singletons in Spring and purely design pattern singletons. Despite the same class loader used to load two application contexts, the instances of ShoppingCart aren't the same. But when we compare the instances retrieved twice and belonging to the same context, we perceive that they're equal."
				}
			]
		},
		{
			"ID": "20230331094046-6eq1588",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-6eq1588",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Design patterns described in this article are used by Spring to handle bean creation. Thanks to singleton, Spring can control that only one instance of so specified bean is available in each application context. Thanks to adapter, Spring decides which layer should be used to handle load-time weaving in JBoss servlet container. The third design pattern, decorator, is used to add synchronization features to Cache objects."
				}
			]
		},
		{
			"ID": "20230331094046-0fwq0fx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094046-0fwq0fx",
				"updated": "20230331094046"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "The comments are moderated. I publish them when I answer, so don't worry if you don't see yours immediately :)"
				}
			]
		}
	]
}