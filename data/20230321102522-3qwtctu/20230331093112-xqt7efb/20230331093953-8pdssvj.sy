{
	"ID": "20230331093953-8pdssvj",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230331093953-8pdssvj",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20230331093953-dh9rd7b\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230331093953-ir3uja5\u0026quot;,\u0026quot;scrollTop\u0026quot;:159.3333282470703,\u0026quot;focusId\u0026quot;:\u0026quot;20230331093953-dh9rd7b\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0}",
		"title": "Design patterns in Spring Framework - part 3",
		"updated": "20230331094032"
	},
	"Children": [
		{
			"ID": "20230331093953-dh9rd7b",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331093953-dh9rd7b",
				"updated": "20230331093953"
			}
		},
		{
			"ID": "20230331093953-knshhbb",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230331093953-knshhbb",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"ID": "20230331093953-liaakzk",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331093953-liaakzk",
						"updated": "20230331093953"
					},
					"Children": [
						{
							"ID": "20230331093953-qtrp738",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331093953-qtrp738",
								"updated": "20230331093953"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://www.waitingforcode.com/spring-framework/design-patterns-in-spring-Framework-part-3/read",
									"TextMarkTextContent": "https://www.waitingforcode.com/spring-framework/design-patterns-in-spring-Framework-part-3/read"
								}
							]
						}
					]
				},
				{
					"ID": "20230331093953-z1aksoz",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331093953-z1aksoz",
						"updated": "20230331093953"
					},
					"Children": [
						{
							"ID": "20230331093953-v1gwztc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331093953-v1gwztc",
								"updated": "20230331093953"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "In two previous articles we saw some of design patterns implemented in Spring framework. This time we'll discover 3 new patterns used by this popular framework."
								}
							]
						}
					]
				},
				{
					"ID": "20230331093953-hvhuj3d",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331093953-hvhuj3d",
						"updated": "20230331093953"
					},
					"Children": [
						{
							"ID": "20230331093953-6lvt72y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331093953-6lvt72y",
								"updated": "20230331093953"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2023-03-31 09:39:53"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230331093953-idqbm2f",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331093953-idqbm2f",
				"updated": "20230331093953"
			}
		},
		{
			"ID": "20230331093953-mr6zyap",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-mr6zyap",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "In two previous articles we saw some of design patterns implemented in Spring framework. This time we'll discover 3 new patterns used by this popular framework."
				}
			]
		},
		{
			"ID": "20230331093953-n217j1u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-n217j1u",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "â€‹"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/deponc_book-20230331093953-hj6n69z.jpg"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "â€‹"
				}
			]
		},
		{
			"ID": "20230331093953-f18fta0",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230331093953-f18fta0",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "New ebook ðŸ”¥"
				}
			]
		},
		{
			"ID": "20230331093953-y97yfww",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-y97yfww",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Data engineering patterns on the cloud"
				}
			]
		},
		{
			"ID": "20230331093953-8a1vb7l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-8a1vb7l",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Learn 84 ways to solve common data engineering problems with cloud services."
				}
			]
		},
		{
			"ID": "20230331093953-sd9acpt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-sd9acpt",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "ðŸ‘‰ "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://dataengineeringpatternsonthecloud.com/#form-section",
					"TextMarkTextContent": "I want my copy"
				}
			]
		},
		{
			"ID": "20230331093953-ej97e4j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-ej97e4j",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "This article will start by describing two creational design patterns: prototype and object pool. At the end we'll focus on behavioral pattern, observer."
				}
			]
		},
		{
			"ID": "20230331093953-uk45dcn",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331093953-uk45dcn",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring design pattern - prototype"
				}
			]
		},
		{
			"ID": "20230331093953-kttkyv1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-kttkyv1",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "The first design pattern from this article is â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "prototype"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. Similar name is described in the article about "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://www.waitingforcode.com/spring-framework/singleton-and-prototype-beans-in-spring-framework/read",
					"TextMarkTextContent": "bean scopes in Spring"
				},
				{
					"Type": "NodeText",
					"Data": ". Prototype design pattern looks similarly to the scope with the same name. This design pattern allows to create the instance of one object by copying already existing object. The copy should be â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "true copy"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. It means that all attributes of new object should be the same as the attributes of copied object. If it's not clear, anything better than a simple JUnit case to illustrate that:"
				}
			]
		},
		{
			"ID": "20230331093953-vxvavbw",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331093953-vxvavbw",
				"updated": "20230331094017"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class PrototypeTest {\n\n  @Test\n  public void test() {\n    Robot firstRobot = new Robot(\"Droid#1\");\n    Robot secondRobot = (Robot) firstRobot.clone();\n    assertTrue(\"Cloned robot's instance can't be the same as the\" \n      +\" source robot instance\", \n      firstRobot != secondRobot);\n    assertTrue(\"Cloned robot's name should be '\"+firstRobot.getName()+\"'\" \n      +\" but was '\"+secondRobot.getName()+\"'\", \n      secondRobot.getName().equals(firstRobot.getName()));\n  }\n\n}\n\n\nclass Robot implements Cloneable {\n  private String name;\n  \n  public Robot(String name) {\n    this.name = name;\n  }\n  \n  public String getName() {\n    return this.name;\n  }\n\n  protected Object clone() throws CloneNotSupportedException {\n    return super.clone();\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331093953-uviwrtu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-uviwrtu",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "In Spring, a kind of specific prototype design pattern is used in "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.beans.factory.support.AbstractBeanFactory"
				},
				{
					"Type": "NodeText",
					"Data": " which initializes the beans prototype-scoped. New object is based on bean definition from configuration file. We can see that in given example:"
				}
			]
		},
		{
			"ID": "20230331093953-2h8glhk",
			"Type": "NodeHTMLBlock",
			"Data": "\u003cpre class=\"xml hljs\"\u003e\u003cbean id=\"shoppingCart\" class=\"com.waitingforcode.data.ShoppingCart\" scope=\"prototype\"\u003e\n  \u003cproperty name=\"id\" value=\"9\"\u003e\n\u003c/property\u003e\u003c/bean\u003e\n\u003c/pre\u003e",
			"Properties": {
				"id": "20230331093953-2h8glhk",
				"updated": "20230331093953"
			}
		},
		{
			"ID": "20230331093953-pdv8p96",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331093953-pdv8p96",
				"updated": "20230331094025"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations={\"applicationContext-test.xml\"})\npublic class SpringPrototypeTest {\n\n  @Autowired\n  private BeanFactory beanFactory;\n  \n  @Test\n  public void test() {\n    ShoppingCart cart1 = (ShoppingCart) beanFactory.getBean(\"shoppingCart\");\n    assertTrue(\"Id of cart1 should be 9 but was \"+cart1.getId(), \n      cart1.getId() == 9);\n    cart1.setId(100);\n    ShoppingCart cart2 = (ShoppingCart) beanFactory.getBean(\"shoppingCart\");\n    assertTrue(\"Id of cart2 should be 9 but was \"+cart2.getId(), \n      cart2.getId() == 9);\n    assertTrue(\"Id of second cart (\"+cart2.getId()+\") shouldn't be the same as the first one: \"+cart1.getId(), \n      cart1.getId() != cart2.getId());\n    cart2.setId(cart1.getId());\n    assertTrue(\"Now (after cart2.setId(cart1.getId())), the id of second cart (\"+cart2.getId()+\") should be the same as the first one: \"\n      +cart1.getId(), cart1.getId() == cart2.getId());\n    assertTrue(\"Both instance shouldn't be the same\", cart1 != cart2);\n  }\n\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331093953-ptq723z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-ptq723z",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "As we can see in previous example, ShoppingCart instances are created directly from bean definition. Initially the value of id for both, cart1 and cart2 objects, is 9. It's modified at the end of the test to prove that both references belong to two different objects."
				}
			]
		},
		{
			"ID": "20230331093953-sqfyhtn",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331093953-sqfyhtn",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring design pattern - object pool"
				}
			]
		},
		{
			"ID": "20230331093953-7hl5sxi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-7hl5sxi",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Another model used in Spring is â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "object pool design pattern"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. The main purpose of it consists on holding a specific number of objects in one pool and reuse it on demand.  Thanks to it we can improve the response time when we want to use greedy objects. Greedy means here that the construction of these objects takes lot of time (for example: objects holding database connection) and it's better to reuse already existing and not acquired objects rather than create the new ones."
				}
			]
		},
		{
			"ID": "20230331093953-fmrk9dr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-fmrk9dr",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring also uses thread pools to manage its scheduling part. Some of examples are located in â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.scheduling.concurrent"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. We retrieve the idea of object pooling in database (Spring JDBC) project. The database connections pools aren't implemented directly by Spring but by projects which are adapted to Spring way of working, as C3P0 or Jakarta Commons DBCP connection pool."
				}
			]
		},
		{
			"ID": "20230331093953-1i12avn",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331093953-1i12avn",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring design pattern - observer"
				}
			]
		},
		{
			"ID": "20230331093953-jbxf5lk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-jbxf5lk",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "The last design pattern presented here is â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "observer"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. It's used when one or several classes are waiting for concrete event. Observer is composed by one subject and a list of observers. A good example of it are GUI interfaces where click on a button (button is a subject) provokes some actions started by listeners (observers), as for example: opening of new page. You can see it in action in following example:"
				}
			]
		},
		{
			"ID": "20230331093953-dgkqso3",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331093953-dgkqso3",
				"updated": "20230331094028"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class ObserverTest {\n\n  @Test\n  public void test() {\n    Observer pageOpener = new PageOpener();\n    Observer register = new Register();\n    Button btn = new Button();\n    btn.addListener(pageOpener);\n    btn.addListener(register);\n    btn.clickOn();\n    assertTrue(\"Button should be clicked but it wasn't\", \n      btn.wasClicked());\n    assertTrue(\"Page opener should be informed about click but it wasn't\", \n      pageOpener.wasInformed());\n    assertTrue(\"Register should be informed about click but it wasn't\", \n      register.wasInformed());\n  }\n\n}\n\nclass Button {\n    \n  private boolean clicked;\n  private List\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331093953-sz8f026",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-sz8f026",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "As you can see, the event about the click on our Button's instance is transmitted to all observer objects. From these objects, one starts to download page content and the second saves the information about the event in registry. In Spring, observer design pattern is used to transmit events associated with application context to the implementations of â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.context.ApplicationListener"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. To see how they're implemented, let's take a look on AbstractApplicationContext class:"
				}
			]
		},
		{
			"ID": "20230331093953-bhs1ebs",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331093953-bhs1ebs",
				"updated": "20230331094032"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public abstract class AbstractApplicationContext extends DefaultResourceLoader\n  implements ConfigurableApplicationContext, DisposableBean {\n  /** Statically specified listeners */\n  private Set\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331093953-5x723jv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-5x723jv",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "In presented code, the listeners are added internally into application context class and after, in the registerListeners() method, they are registered to appropriate event multicaster represented by interface â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.context.event.ApplicationEventMulticaster"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. Event multicasters are responsible for managing of different listeners and publishing events to them."
				}
			]
		},
		{
			"ID": "20230331093953-yrg5sf7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-yrg5sf7",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "This time we discovered 3 design patterns: prototype used to create beans under the same called scope, object pool which avoids to recreate greedy objects and observer which dispatches application's context events to appropriate listeners."
				}
			]
		},
		{
			"ID": "20230331093953-ir3uja5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331093953-ir3uja5",
				"updated": "20230331093953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "The comments are moderated. I publish them when I answer, so don't worry if you don't see yours immediately :)"
				}
			]
		}
	]
}