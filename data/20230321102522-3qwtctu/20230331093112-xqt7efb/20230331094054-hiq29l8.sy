{
	"ID": "20230331094054-hiq29l8",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230331094054-hiq29l8",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20230331094054-kk1ssd2\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230331094054-pjqgpub\u0026quot;,\u0026quot;scrollTop\u0026quot;:8506.6669921875,\u0026quot;focusId\u0026quot;:\u0026quot;20230331094054-5t3l4or\u0026quot;,\u0026quot;focusStart\u0026quot;:24,\u0026quot;focusEnd\u0026quot;:24}",
		"title": "Design patterns in Spring Framework - part 5",
		"updated": "20230331094203"
	},
	"Children": [
		{
			"ID": "20230331094054-kk1ssd2",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331094054-kk1ssd2",
				"updated": "20230331094054"
			}
		},
		{
			"ID": "20230331094054-uwhk77e",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230331094054-uwhk77e",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"ID": "20230331094054-s3fth51",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331094054-s3fth51",
						"updated": "20230331094054"
					},
					"Children": [
						{
							"ID": "20230331094054-5t3l4or",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331094054-5t3l4or",
								"updated": "20230331094054"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://www.waitingforcode.com/spring-framework/design-patterns-in-spring-Framework-part-5/read",
									"TextMarkTextContent": "https://www.waitingforcode.com/spring-framework/design-patterns-in-spring-Framework-part-5/read"
								}
							]
						}
					]
				},
				{
					"ID": "20230331094054-e41jq9m",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331094054-e41jq9m",
						"updated": "20230331094054"
					},
					"Children": [
						{
							"ID": "20230331094054-afczk08",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331094054-afczk08",
								"updated": "20230331094054"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Through 4 previous articles, we saw that Spring adopts a big number of creational and structural design patterns. They're not so much behavioral ones and it's why we discover two of them in this article, the last one about design patterns used in Spring."
								}
							]
						}
					]
				},
				{
					"ID": "20230331094054-gog1yea",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230331094054-gog1yea",
						"updated": "20230331094054"
					},
					"Children": [
						{
							"ID": "20230331094054-jsb6644",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230331094054-jsb6644",
								"updated": "20230331094054"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2023-03-31 09:40:54"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230331094054-t6q0ai8",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230331094054-t6q0ai8",
				"updated": "20230331094054"
			}
		},
		{
			"ID": "20230331094054-z66x1sg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-z66x1sg",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Through 4 previous articles, we saw that Spring adopts a big number of creational and structural design patterns. They're not so much behavioral ones and it's why we discover two of them in this article, the last one about design patterns used in Spring."
				}
			]
		},
		{
			"ID": "20230331094054-79whlv6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-79whlv6",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "â€‹"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/deponc_book-20230331094054-f3chkyr.jpg"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "â€‹"
				}
			]
		},
		{
			"ID": "20230331094054-qyg3hf1",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230331094054-qyg3hf1",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "New ebook ðŸ”¥"
				}
			]
		},
		{
			"ID": "20230331094054-xxpx9ke",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-xxpx9ke",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Data engineering patterns on the cloud"
				}
			]
		},
		{
			"ID": "20230331094054-tk1qv60",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-tk1qv60",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Learn 84 ways to solve common data engineering problems with cloud services."
				}
			]
		},
		{
			"ID": "20230331094054-pzp9u3p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-pzp9u3p",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "ðŸ‘‰ "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://dataengineeringpatternsonthecloud.com/#form-section",
					"TextMarkTextContent": "I want my copy"
				}
			]
		},
		{
			"ID": "20230331094054-pp21qf4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-pp21qf4",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "This article will describe two design patterns belonging to behavioral family: command and visitor."
				}
			]
		},
		{
			"ID": "20230331094054-thxws1h",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331094054-thxws1h",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring design pattern - command"
				}
			]
		},
		{
			"ID": "20230331094054-g70kmjb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-g70kmjb",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "The first one behavioral design pattern described here is â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "command"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. It allows to encapsulate the request within an object and attach to it a callback action. The request is encapsulated under command object while the result of the request is transmitted to the receiver. The command isn't executed by itself but by an invoker. To better understand the main idea, imagine the situation of administrating a server. The administrator (invoker) launches some operations in command line (commands) which result is transmitted to the server (receiver). All is done thanks to terminal which can be considered here as a client. Let's write it into JUnit case:"
				}
			]
		},
		{
			"ID": "20230331094054-2dpeq03",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094054-2dpeq03",
				"updated": "20230331094149"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class CommandTest {\n\n  // This test method is a client\n  @Test\n  public void test() {\n    Administrator admin = new Administrator();\n    Server server = new Server();\n  \n    // start Apache\n    admin.setCommand(new StartApache(server));\n    admin.typeEnter();\n  \n    // start Tomcat\n    admin.setCommand(new StartTomcat(server));\n    admin.typeEnter();\n  \n    // check executed commands\n    int executed = server.getExecutedCommands().size();\n    assertTrue(\"Two commands should be executed but only \"+\n      executed+ \" were\", executed == 2);\n  }\n\n}\n\n// commands\nabstract class ServerCommand {\n    \n  protected Server server;\n  \n  public ServerCommand(Server server) {\n    this.server = server;\n  }\n\n  public abstract void execute();\n}\n\nclass StartTomcat extends ServerCommand {\n    \n  public StartTomcat(Server server) {\n    super(server);\n  }\n  \n  @Override\n  public void execute() {\n    server.launchCommand(\"sudo service tomcat7 start\");\n  }\n}\n\nclass StartApache extends ServerCommand {\n    \n  public StartApache(Server server) {\n    super(server);\n  }\n\n  @Override\n  public void execute() {\n    server.launchCommand(\"sudo service apache2 start\");\n  }\n}\n\n// invoker\nclass Administrator {\n    \n  private ServerCommand command;\n  \n  public void setCommand(ServerCommand command) {\n    this.command = command;\n  }\n  \n  public void typeEnter() {\n    this.command.execute();\n  }\n    \n}\n\n// receiver\nclass Server {\n    \n  // as in common terminals, we store executed commands in history\n  private List\u003cString\u003e executedCommands = new ArrayList\u003cString\u003e();\n  \n  public void launchCommand(String command) {\n    System.out.println(\"Executing: \"+command+\" on server\");\n    this.executedCommands.add(command);\n  }\n  \n  public List\u003cString\u003e getExecutedCommands() {\n    return this.executedCommands;\n  }\n    \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094054-gnsuh5u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-gnsuh5u",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "The test should pass and print two commands:"
				}
			]
		},
		{
			"ID": "20230331094054-ri25eqz",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094054-ri25eqz",
				"updated": "20230331094155"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Executing: sudo service apache2 start on server\nExecuting: sudo service tomcat7 start on server\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094054-y31cb0s",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-y31cb0s",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Command pattern allows not only encapsulate request (ServerCommand) and transmit it into receiver (Server), but also handle given request better. In our case, this better handling is translated by the possibility to store history of typed commands. In Spring we retreive the principle of command design pattern in the feature of beans factory post processors. To define them quickly, post processors are launched by application context to make some of manipulations on created beans (if you want to discover this subject, please read the article about "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://www.waitingforcode.com/spring-framework/design-patterns-in-spring-Framework-part-5/read#",
					"TextMarkTextContent": "beans factory post processors"
				},
				{
					"Type": "NodeText",
					"Data": ")."
				}
			]
		},
		{
			"ID": "20230331094054-01kc1zc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-01kc1zc",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "When we switch previously presented command logic to Spring bean factory post processors, we can distinguish following actors: post processors beans (implementing BeanFactoryPostProcessor) are the commands, "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.context.support.PostProcessorRegistrationDelegate"
				},
				{
					"Type": "NodeText",
					"Data": " is the invoker (it executes the postProcessBeanFactory method of all registered post processor beans) and the receiver "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.beans.factory.config.ConfigurableListableBeanFactory"
				},
				{
					"Type": "NodeText",
					"Data": " which elements (beans) can be modified before theirs construction (for example: property can be changed before initialization of the bean)."
				}
			]
		},
		{
			"ID": "20230331094054-merub0l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-merub0l",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "In additionaly, we retreive also the aspect of \"better handling\", exposed as history management in our JUnit case. PostProcessorRegistrationDelegate contains a inner class, "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "BeanPostProcessorChecker"
				},
				{
					"Type": "NodeText",
					"Data": " which can log the situation when one bean isn't eligible for getting processed."
				}
			]
		},
		{
			"ID": "20230331094054-hkivv2k",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230331094054-hkivv2k",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Spring design pattern - visitor"
				}
			]
		},
		{
			"ID": "20230331094054-m028g0h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-m028g0h",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "The second behavioral design pattern used in Spring is â€‹"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Visitor"
				},
				{
					"Type": "NodeText",
					"Data": "â€‹. The idea hidden behind it consists on making one objects visitables by another type of objects. As you can deduct after this short definition, objects using this design pattern will be considered as visitors or as objects visitables. The first ones visit the seconds. A real world example of this pattern can be a mechanic who inspects some car parts as wheels, brake and engine to judge if the car can be used. Let's take a look on this situation programmed as JUnit test case:"
				}
			]
		},
		{
			"ID": "20230331094054-6svsy6z",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094054-6svsy6z",
				"updated": "20230331094158"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class VisitorTest {\n\n  @Test\n  public void test() {\n    CarComponent car = new Car();\n    Mechanic mechanic = new QualifiedMechanic();\n    car.accept(mechanic);\n    assertTrue(\"After qualified mechanics visit, the car should be broken\",\n      car.isBroken());\n    Mechanic nonqualifiedMechanic = new NonQualifiedMechanic();\n    car.accept(nonqualifiedMechanic);\n    assertFalse(\"Car shouldn't be broken becase non qualified mechanic \" +\n      \" can't see breakdowns\", car.isBroken());\n  }\n\n}\n\n// visitor\ninterface Mechanic {\n  public void visit(CarComponent element);\n  public String getName();\n}\n\nclass QualifiedMechanic implements Mechanic {\n\n  @Override\n  public void visit(CarComponent element) {\n    element.setBroken(true);\n  }\n\n  @Override\n  public String getName() {\n    return \"qualified\";\n  }\n}\n\nclass NonQualifiedMechanic implements Mechanic {\n    \n  @Override\n  public void visit(CarComponent element) {\n    element.setBroken(true);\n  }\n  \n  @Override\n  public String getName() {\n    return \"unqualified\";\n  }\n}\n\n// visitable\nabstract class CarComponent {\n  protected boolean broken;\n\n  public abstract void accept(Mechanic mechanic);\n  \n  public void setBroken(boolean broken) {\n    this.broken = broken;\n  }\n  \n  public boolean isBroken() {\n    return this.broken;\n  }\n}\n\nclass Car extends CarComponent {\n\n  private boolean broken = false;\n  private CarComponent[] components;\n  \n  public Car() {\n    components = new CarComponent[] {\n      new Wheels(), new Engine(), new Brake()\n    };\n  }\n  \n  @Override\n  public void accept(Mechanic mechanic) {\n    this.broken = false;\n    if (mechanic.getName().equals(\"qualified\")) {\n      int i = 0;\n      while (i \u003c components.length \u0026\u0026 this.broken == false) {\n        CarComponent component = components[i];\n        mechanic.visit(component);\n        this.broken = component.isBroken();\n        i++;\n      }\n    }\n    // if mechanic isn't qualified, we suppose that \n    // he isn't able to see breakdowns and so \n    // he considers the car as no broken \n    // (even if the car is broken)\n  }\n\n  @Override\n  public boolean isBroken() {\n          return this.broken;\n  }\n}\n\nclass Wheels extends CarComponent {\n\n  @Override\n  public void accept(Mechanic mechanic) {\n    mechanic.visit(this);\n  }\n}\n\nclass Engine extends CarComponent {\n\n  @Override\n  public void accept(Mechanic mechanic) {\n    mechanic.visit(this);\n  }\n}\n\nclass Brake extends CarComponent {\n\n  @Override\n  public void accept(Mechanic mechanic) {\n    mechanic.visit(this);\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094054-h6n7g6h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-h6n7g6h",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "In this example we can see that they're two mechanics (visitors): qualified and non-qualified. Visitable object exposed to them is Car. Through its accept method it decides which politic should be applied to the visitor. When the visitor is qualified, Car let's him to analyze all components. If the visitor isn't qualified, Car considers that its intervention is useless and returns directly false in method isBroken(). Spring implements visitor design pattern in beans configuration. To observe that, we can take a look on "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "org.springframework.beans.factory.config.BeanDefinitionVisitor"
				},
				{
					"Type": "NodeText",
					"Data": " object which is used to parse bean metadata and resolve them into String (for example: XML attributes with scope or factory method name) or Object (for example: parameters in constructor definition). Resolved values are after set into BeanDefinition instance associated with analyzed bean. To see it in action, they're a code fragment from BeanDefinitionVisitor:"
				}
			]
		},
		{
			"ID": "20230331094054-kqy2uw4",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230331094054-kqy2uw4",
				"updated": "20230331094203"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/**\n * Traverse the given BeanDefinition object and the MutablePropertyValues\n * and ConstructorArgumentValues contained in them.\n * @param beanDefinition the BeanDefinition object to traverse\n * @see #resolveStringValue(String)\n */\npublic void visitBeanDefinition(BeanDefinition beanDefinition) {\n  visitParentName(beanDefinition);\n  visitBeanClassName(beanDefinition);\n  visitFactoryBeanName(beanDefinition);\n  visitFactoryMethodName(beanDefinition);\n  visitScope(beanDefinition);\n  visitPropertyValues(beanDefinition.getPropertyValues());\n  ConstructorArgumentValues cas = beanDefinition.\n    getConstructorArgumentValues();\n  visitIndexedArgumentValues(cas.\n    getIndexedArgumentValues());\n  visitGenericArgumentValues(cas.\n    getGenericArgumentValues());\n}\n\nprotected void visitParentName(BeanDefinition beanDefinition) {\n  String parentName = beanDefinition.getParentName();\n  if (parentName != null) {\n    String resolvedName = resolveStringValue(parentName);\n    if (!parentName.equals(resolvedName)) {\n      beanDefinition.setParentName(resolvedName);\n    }\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230331094054-yyk01m5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-yyk01m5",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "In this case, they're only visit approach, without any supplementary control on visitor as in our case of qualified and non-qualified mechanic. The visit consists on analyze a parameter of given BeanDefinition and replace it by resolved object."
				}
			]
		},
		{
			"ID": "20230331094054-4lr44kh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-4lr44kh",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "In this last article about design patterns in Spring we discovered 2 behavioral patterns: command used to handle post process for bean factory and visitor used to convert defined bean parameters into object-oriented (instances of String or Object) parameters."
				}
			]
		},
		{
			"ID": "20230331094054-pjqgpub",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230331094054-pjqgpub",
				"updated": "20230331094054"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "The comments are moderated. I publish them when I answer, so don't worry if you don't see yours immediately :)"
				}
			]
		}
	]
}