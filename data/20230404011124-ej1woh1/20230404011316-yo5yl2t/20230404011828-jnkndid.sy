{
	"ID": "20230404011828-jnkndid",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230404011828-jnkndid",
		"title": "吃透Redis（四）：网络框架篇-多路复用器_redis 多路复用器_吃透Java的博客-CSDN博客",
		"updated": "20230404011828"
	},
	"Children": [
		{
			"ID": "20230404011828-fd0yvzo",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230404011828-fd0yvzo",
				"updated": "20230404011828"
			}
		},
		{
			"ID": "20230404011828-wpahju7",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011828-wpahju7",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"ID": "20230404011828-go27nhp",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-go27nhp",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-33syt0z",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-33syt0z",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126105731",
									"TextMarkTextContent": "https://blog.csdn.net/u013277209/article/details/126105731"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-58u9zop",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-58u9zop",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-x3fqw6b",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-x3fqw6b",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "主要介绍了Redis网络通信依赖的操作系统底层机制，也就是IO多路复用机制。由于Redis是单线程程序，如果使用基本的Socket编程模型的话，只能对一个监听套接字或一个已连接套接字进行监听。而当Redis实例面临很多并发的客户端时，这种处理方式的效率就会很低。所以，和基本的Socket通信相比，使用IO多路复用机制，就可以一次性获得就绪的多个套接字，从而避免了逐个检测套接字的开销。单线程服务器模型，面临的最大的问题就是，一个线程如何处理多个客户端请求？https。..."
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-tf90fdn",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-tf90fdn",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-3xh7fgh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-3xh7fgh",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2023-04-04 01:18:28"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011828-e0ua5qw",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230404011828-e0ua5qw",
				"updated": "20230404011828"
			}
		},
		{
			"ID": "20230404011828-jbhyjh0",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404011828-jbhyjh0",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "文章目录"
				}
			]
		},
		{
			"ID": "20230404011828-qhdpepk",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011828-qhdpepk",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"ID": "20230404011828-sjb3pkj",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-sjb3pkj",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-pf6a8x8",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20230404011828-pf6a8x8",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"ID": "20230404011828-zkfg2lu",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230404011828-zkfg2lu",
										"updated": "20230404011828"
									},
									"Children": [
										{
											"ID": "20230404011828-tn992m8",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230404011828-tn992m8",
												"updated": "20230404011828"
											},
											"Children": [
												{
													"Type": "NodeTextMark",
													"TextMarkType": "a",
													"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126105731#socket_13",
													"TextMarkTextContent": "一、普通的socket编程"
												}
											]
										}
									]
								},
								{
									"ID": "20230404011828-p2c8oap",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230404011828-p2c8oap",
										"updated": "20230404011828"
									},
									"Children": [
										{
											"ID": "20230404011828-m7bgjrp",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230404011828-m7bgjrp",
												"updated": "20230404011828"
											},
											"Children": [
												{
													"Type": "NodeTextMark",
													"TextMarkType": "a",
													"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126105731#socket_40",
													"TextMarkTextContent": "二、多线程socket"
												}
											]
										}
									]
								},
								{
									"ID": "20230404011828-fshos3e",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230404011828-fshos3e",
										"updated": "20230404011828"
									},
									"Children": [
										{
											"ID": "20230404011828-gb0znjj",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230404011828-gb0znjj",
												"updated": "20230404011828"
											},
											"Children": [
												{
													"Type": "NodeTextMark",
													"TextMarkType": "a",
													"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126105731#IO_67",
													"TextMarkTextContent": "三、IO多路复用"
												}
											]
										}
									]
								},
								{
									"ID": "20230404011828-h6ez6b1",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230404011828-h6ez6b1",
										"updated": "20230404011828"
									},
									"Children": [
										{
											"ID": "20230404011828-oae5ivm",
											"Type": "NodeList",
											"ListData": {},
											"Properties": {
												"id": "20230404011828-oae5ivm",
												"updated": "20230404011828"
											},
											"Children": [
												{
													"ID": "20230404011828-rrl35tp",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20230404011828-rrl35tp",
														"updated": "20230404011828"
													},
													"Children": [
														{
															"ID": "20230404011828-3x0e56o",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20230404011828-3x0e56o",
																"updated": "20230404011828"
															},
															"Children": [
																{
																	"Type": "NodeTextMark",
																	"TextMarkType": "a",
																	"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126105731#1select__80",
																	"TextMarkTextContent": "1、select 机制与使用"
																}
															]
														}
													]
												},
												{
													"ID": "20230404011828-ecz2xv2",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20230404011828-ecz2xv2",
														"updated": "20230404011828"
													},
													"Children": [
														{
															"ID": "20230404011828-2cclkax",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20230404011828-2cclkax",
																"updated": "20230404011828"
															},
															"Children": [
																{
																	"Type": "NodeTextMark",
																	"TextMarkType": "a",
																	"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126105731#2poll__174",
																	"TextMarkTextContent": "2、poll 机制与使用"
																}
															]
														}
													]
												},
												{
													"ID": "20230404011828-rx5y7eg",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20230404011828-rx5y7eg",
														"updated": "20230404011828"
													},
													"Children": [
														{
															"ID": "20230404011828-5t86jz5",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20230404011828-5t86jz5",
																"updated": "20230404011828"
															},
															"Children": [
																{
																	"Type": "NodeTextMark",
																	"TextMarkType": "a",
																	"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126105731#3epoll__IO__270",
																	"TextMarkTextContent": "3、epoll 机制实现 IO 多路复用"
																}
															]
														}
													]
												}
											]
										}
									]
								},
								{
									"ID": "20230404011828-uz1wx2l",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230404011828-uz1wx2l",
										"updated": "20230404011828"
									},
									"Children": [
										{
											"ID": "20230404011828-4ihwc10",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230404011828-4ihwc10",
												"updated": "20230404011828"
											},
											"Children": [
												{
													"Type": "NodeTextMark",
													"TextMarkType": "a",
													"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126105731#_347",
													"TextMarkTextContent": "四、总结"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011828-rrub3cb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-rrub3cb",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 作为一个 Client-Server 架构的数据库，其源码中少不了用来实现网络通信的部分。而你应该也清楚，通常系统实现网络通信的基本方法是使用 Socket 编程模型，包括创建 Socket、监听端口、处理连接请求和读写请求。"
				}
			]
		},
		{
			"ID": "20230404011828-ko0uuqx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-ko0uuqx",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但是，由于基本的 Socket 编程模型一次只能处理一个客户端连接上的请求，所以当要处理高并发请求时，一种方案就是使用多线程，让每个线程负责处理一个客户端的请求。而 Redis 负责客户端请求解析和处理的线程只有一个，那么如果直接采用基本 Socket 模型，就会影响 Redis 支持高并发的客户端访问。"
				}
			]
		},
		{
			"ID": "20230404011828-jtscnj5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-jtscnj5",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此，为了实现高并发的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://so.csdn.net/so/search?q=%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1\u0026spm=1001.2101.3001.7020",
					"TextMarkTextContent": "网络通信"
				},
				{
					"Type": "NodeText",
					"Data": "，我们常用的 Linux 操作系统，就提供了 select、poll 和 epoll 三种编程模型，而在 Linux 上运行的 Redis，通常就会采用其中的 epoll 模型来进行网络通信。这里你可能就要问了：为啥 Redis 通常会选择 epoll 模型呢？这三种编程模型之间有什么区别？如果我们自己要开发高并发的服务器处理程序时，应该如何选择使用呢？"
				}
			]
		},
		{
			"ID": "20230404011828-gehmxhr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-gehmxhr",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们接下来聊聊Redis 在高并发网络通信编程模型上的选择和设计思想。通过本篇的学习，你可以掌握 select、poll 和 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://so.csdn.net/so/search?q=epoll\u0026spm=1001.2101.3001.7020",
					"TextMarkTextContent": "epoll"
				},
				{
					"Type": "NodeText",
					"Data": " 三种模型的工作机制和使用方法。"
				}
			]
		},
		{
			"ID": "20230404011828-9tdzx7n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-9tdzx7n",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "了解这些内容，一方面可以帮助你理解 Redis 整体网络通信框架的工作基础，另一方面，也可以让你学会如何进行高并发网络通信的开发。那么，要想理解 select、poll 和 epoll 的优势，我们需要有个对比基础，也就是基本的 Socket 编程模型。所以接下来，我们就先来了解下基本的 Socket 编程模型，以及它的不足之处。"
				}
			]
		},
		{
			"ID": "20230404011828-8f0smwx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-8f0smwx",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "为什么 Redis 不使用基本的 Socket 编程模型？"
				}
			]
		},
		{
			"ID": "20230404011828-388jppq",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230404011828-388jppq",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一、普通的socket编程"
				}
			]
		},
		{
			"ID": "20230404011828-q4n4awk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-q4n4awk",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "刚刚我们说过，使用 Socket 模型实现网络通信时，需要经过创建 Socket、监听端口、处理连接和读写请求等多个步骤，现在我们就来具体了解下这些步骤中的关键操作，以此帮助我们分析 Socket 模型中的不足。"
				}
			]
		},
		{
			"ID": "20230404011828-t915yj5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-t915yj5",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "首先，当我们需要让服务器端和客户端进行通信时，可以在服务器端通过以下三步，来创建监听客户端连接的监听"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://so.csdn.net/so/search?q=%E5%A5%97%E6%8E%A5%E5%AD%97\u0026spm=1001.2101.3001.7020",
					"TextMarkTextContent": "套接字"
				},
				{
					"Type": "NodeText",
					"Data": "（Listening Socket）："
				}
			]
		},
		{
			"ID": "20230404011828-xi1t8gb",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230404011828-xi1t8gb",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"ID": "20230404011828-su57o9g",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230404011828-su57o9g",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-2zwez5v",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-2zwez5v",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "调用 socket 函数，创建一个套接字。我们通常把这个套接字称为主动套接字（Active Socket）；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-s4tv39g",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230404011828-s4tv39g",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-4hnrb9r",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-4hnrb9r",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "调用 bind 函数，将主动套接字和当前服务器的 IP 和监听端口进行绑定；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-t8f31pg",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230404011828-t8f31pg",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-vpyjrmn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-vpyjrmn",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "调用 listen 函数，将主动套接字转换为监听套接字，开始监听客户端的连接。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011828-oe5oazw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-oe5oazw",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在完成上述三步之后，服务器端就可以接收客户端的连接请求了。为了能及时地收到客户端的连接请求，我们可以运行一个循环流程，在该流程中调用 accept 函数，用于接收客户端连接请求。"
				}
			]
		},
		{
			"ID": "20230404011828-msk9t63",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-msk9t63",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里你需要注意的是，accept 函数是阻塞函数，也就是说，如果此时一直没有客户端连接请求，那么，服务器端的执行流程会一直阻塞在 accept 函数。一旦有客户端连接请求到达，accept 将不再阻塞，而是处理连接请求，和客户端建立连接，并返回已连接套接字（Connected Socket）。"
				}
			]
		},
		{
			"ID": "20230404011828-m23db6k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-m23db6k",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "最后，服务器端可以通过调用 recv 或 send 函数，在刚才返回的已连接套接字上，接收并处理读写请求，或是将数据发送给客户端。"
				}
			]
		},
		{
			"ID": "20230404011828-mix6ehg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-mix6ehg",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下面的代码展示了这一过程，你可以看下。"
				}
			]
		},
		{
			"ID": "20230404011828-k6rqq7v",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404011828-k6rqq7v",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "listenSocket = socket(); //调用socket系统调用创建一个主动套接字\nbind(listenSocket);  //绑定地址和端口\nlisten(listenSocket); //将默认的主动套接字转换为服务器使用的被动套接字，也就是监听套接字\nwhile (1) {  //循环监听是否有客户端连接请求到来\n   connSocket = accept(listenSocket); //接受客户端连接\n   recv(connsocket); //从客户端读取数据，只能同时处理一个客户端\n   send(connsocket); //给客户端返回数据，只能同时处理一个客户端\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404011828-kk4tbn4",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230404011828-kk4tbn4",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "二、多线程socket"
				}
			]
		},
		{
			"ID": "20230404011828-arbk4zw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-arbk4zw",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不过，从上述代码中，你可能会发现，虽然它能够实现服务器端和客户端之间的通信，但是程序每调用一次 accept 函数，只能处理一个客户端连接。因此，如果想要处理多个并发客户端的请求，我们就需要使用多线程的方法，来处理通过 accept 函数建立的多个客户端连接上的请求。"
				}
			]
		},
		{
			"ID": "20230404011828-88y5f9k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-88y5f9k",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用这种方法后，我们需要在 accept 函数返回已连接套接字后，创建一个线程，并将已连接套接字传递给创建的线程，由该线程负责这个连接套接字上后续的数据读写。同时，服务器端的执行流程会再次调用 accept 函数，等待下一个客户端连接。"
				}
			]
		},
		{
			"ID": "20230404011828-fl1zf4j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-fl1zf4j",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "以下给出的示例代码，就展示了使用多线程来提升服务器端的并发客户端处理能力："
				}
			]
		},
		{
			"ID": "20230404011828-6vn5uux",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404011828-6vn5uux",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "listenSocket = socket(); //调用socket系统调用创建一个主动套接字\nbind(listenSocket);  //绑定地址和端口\nlisten(listenSocket); //将默认的主动套接字转换为服务器使用的被动套接字，即监听套接字\nwhile (1) {  //循环监听是否有客户端连接到来\n   connSocket = accept(listenSocket); //接受客户端连接，返回已连接套接字\n   pthread_create(processData, connSocket); //创建新线程对已连接套接字进行处理\n   \n}\n\n//处理已连接套接字上的读写请求\nprocessData(connSocket){ \n   recv(connsocket); //从客户端读取数据，只能同时处理一个客户端\n   send(connsocket); //给客户端返回数据，只能同时处理一个客户端\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404011828-zu35avr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-zu35avr",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不过，虽然这种方法能提升服务器端的并发处理能力，遗憾的是，Redis 的主执行流程是由一个线程在执行，无法使用多线程的方式来提升并发处理能力。所以，该方法对 Redis 并不起作用。"
				}
			]
		},
		{
			"ID": "20230404011828-57b26nt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-57b26nt",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "那么，还有没有什么其他方法，能帮助 Redis 提升并发客户端的处理能力呢？"
				}
			]
		},
		{
			"ID": "20230404011828-5hsxb1p",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230404011828-5hsxb1p",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "三、IO多路复用"
				}
			]
		},
		{
			"ID": "20230404011828-nwmmv0n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-nwmmv0n",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这就要用到操作系统提供的 IO 多路复用功能了。在基本的 Socket 编程模型中，accept 函数只能在一个监听套接字上监听客户端的连接，recv 函数也只能在一个已连接套接字上，等待客户端发送的请求。"
				}
			]
		},
		{
			"ID": "20230404011828-urguy8d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-urguy8d",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "而 IO 多路复用机制，可以让程序通过调用多路复用函数，同时监听多个套接字上的请求。这里既可以包括监听套接字上的连接请求，也可以包括已连接套接字上的读写请求。这样当有一个或多个套接字上有请求时，多路复用函数就会返回。此时，程序就可以处理这些就绪套接字上的请求，比如读取就绪的已连接套接字上的请求内容。"
				}
			]
		},
		{
			"ID": "20230404011828-vktifm3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-vktifm3",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为 Linux 操作系统在实际应用中比较广泛，所以这节课，我们主要来学习 Linux 上的 IO 多路复用机制。Linux 提供的 IO 多路复用机制主要有三种，分别是 select、poll 和 epoll。下面，我们就分别来学习下这三种机制的实现思路和使用方法。然后，我们再来看看，为什么 Redis 通常是选择使用 epoll 这种机制来实现网络通信。"
				}
			]
		},
		{
			"ID": "20230404011828-v91a6no",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-v91a6no",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不过在具体学习之前，我们需要知道，对于一种 IO 多路复用机制来说，我们需要掌握哪些要点，这样可以帮助我们快速抓住不同机制的联系与区别。其实，当我们学习 IO 多路复用机制时，我们需要能回答以下问题："
				}
			]
		},
		{
			"ID": "20230404011828-0k4funy",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230404011828-0k4funy",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"ID": "20230404011828-uz7i70t",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230404011828-uz7i70t",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-ft1l3h0",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-ft1l3h0",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第一，多路复用机制会监听套接字上的哪些事件？"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-0ch4r0d",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230404011828-0ch4r0d",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-p65xfwn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-p65xfwn",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第二，多路复用机制可以监听多少个套接字？"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-5myqd1w",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230404011828-5myqd1w",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-45zsrqw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-45zsrqw",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第三，当有套接字就绪时，多路复用机制要如何找到就绪的套接字？"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011828-szqnagc",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404011828-szqnagc",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1、select 机制与使用"
				}
			]
		},
		{
			"ID": "20230404011828-azo7w4x",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-azo7w4x",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "select 机制中的一个重要函数就是 select 函数："
				}
			]
		},
		{
			"ID": "20230404011828-k6swtsx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404011828-k6swtsx",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "int select (int __nfds, fd_set *__readfds, fd_set *__writefds, fd_set *__exceptfds, struct timeval *__timeout)\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404011828-h7355yg",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011828-h7355yg",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"ID": "20230404011828-rd1gc51",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-rd1gc51",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-43bvy0y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-43bvy0y",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "__nfds：监听的文件描述符数量。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-qh6ufde",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-qh6ufde",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-c0lrax0",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-c0lrax0",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "*__readfds：监听读数据事件的文件描述符集合"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-855rqit",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-855rqit",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-xxekehz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-xxekehz",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "*__writefds：监听写数据事件的文件描述符集合"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-acdumi6",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-acdumi6",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-qoq27eh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-qoq27eh",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "*__exceptfds：监听异常事件的文件描述符集合"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-dk8eq5r",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-dk8eq5r",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-5b1tjfu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-5b1tjfu",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "*__timeout：监听时阻塞等待的超时时长"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011828-0zgboou",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-0zgboou",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里你需要注意的是，Linux 针对每一个套接字都会有一个文件描述符，也就是一个非负整数，用来唯一标识该套接字。所以，在多路复用机制的函数中，Linux 通常会用文件描述符作为参数。有了文件描述符，函数也就能找到对应的套接字，进而进行监听、读写等操作。"
				}
			]
		},
		{
			"ID": "20230404011828-4zlwqat",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-4zlwqat",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以，select 函数的参数__readfds、__writefds和__exceptfds表示的是，被监听描述符的集合，其实就是被监听套接字的集合。那么，为什么会有三个集合呢？"
				}
			]
		},
		{
			"ID": "20230404011828-fqo89pt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-fqo89pt",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这就和我刚才提出的第一个问题相关，也就是多路复用机制会监听哪些事件。select 函数使用三个集合，表示监听的三类事件，分别是读数据事件（对应__readfds集合）、写数据事件（对应__writefds集合）和异常事件（对应__exceptfds集合）。"
				}
			]
		},
		{
			"ID": "20230404011828-9pgc6gv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-9pgc6gv",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们进一步可以看到，参数 __readfds、__writefds 和 __exceptfds 的类型是 fd_set 结构体，它主要定义部分如下所示。其中，__fd_mask类型是 long int 类型的别名，__FD_SETSIZE 和 __NFDBITS 这两个宏定义的大小默认为 1024 和 32。"
				}
			]
		},
		{
			"ID": "20230404011828-suy0wq3",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404011828-suy0wq3",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "typedef struct { \n   …\n   __fd_mask  __fds_bits[__FD_SETSIZE / __NFDBITS];\n   …\n} fd_set\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404011828-ktrabt5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-ktrabt5",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以，fd_set 结构体的定义，其实就是一个 long int 类型的数组，该数组中一共有 32 个元素（1024/32=32），每个元素是 32 位（long int 类型的大小），而每一位可以用来表示一个文件描述符的状态。"
				}
			]
		},
		{
			"ID": "20230404011828-je3bcyk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-je3bcyk",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "好了，了解了 fd_set 结构体的定义，我们就可以回答刚才提出的第二个问题了。select 函数对每一个描述符集合，都可以监听 1024 个描述符。"
				}
			]
		},
		{
			"ID": "20230404011828-x1ecuq3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-x1ecuq3",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如何使用 select 机制来实现网络通信？"
				}
			]
		},
		{
			"ID": "20230404011828-y54cjic",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-y54cjic",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "首先，我们在调用 select 函数前，可以先创建好传递给 select 函数的描述符集合，然后再创建监听套接字。而为了让创建的监听套接字能被 select 函数监控，我们需要把这个套接字的描述符加入到创建好的描述符集合中。"
				}
			]
		},
		{
			"ID": "20230404011828-1bpebj7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-1bpebj7",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后，我们就可以调用 select 函数，并把创建好的描述符集合作为参数传递给 select 函数。程序在调用 select 函数后，会发生阻塞。而当 select 函数检测到有描述符就绪后，就会结束阻塞，并返回就绪的文件描述符个数。"
				}
			]
		},
		{
			"ID": "20230404011828-1z4b39z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-1z4b39z",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那么此时，我们就可以在描述符集合中查找哪些描述符就绪了。然后，我们对已就绪描述符对应的套接字进行处理。比如，如果是 __readfds 集合中有描述符就绪，这就表明这些就绪描述符对应的套接字上，有读事件发生，此时，我们就在该套接字上读取数据。"
				}
			]
		},
		{
			"ID": "20230404011828-6vkdrag",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-6vkdrag",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "而因为 select 函数一次可以监听 1024 个文件描述符的状态，所以 select 函数在返回时，也可能会一次返回多个就绪的文件描述符。这样一来，我们就可以使用一个循环流程，依次对就绪描述符对应的套接字进行读写或异常处理操作。"
				}
			]
		},
		{
			"ID": "20230404011828-a80adsf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-a80adsf",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下面的代码展示的是使用 select 函数，进行并发客户端处理的关键步骤和主要函数调用："
				}
			]
		},
		{
			"ID": "20230404011828-q481wjj",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404011828-q481wjj",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\nint sock_fd,conn_fd; //监听套接字和已连接套接字的变量\nsock_fd = socket() //创建套接字\nbind(sock_fd)   //绑定套接字\nlisten(sock_fd) //在套接字上进行监听，将套接字转为监听套接字\n\nfd_set rset;  //被监听的描述符集合，关注描述符上的读事件\n \nint max_fd = sock_fd\n\n//初始化rset数组，使用FD_ZERO宏设置每个元素为0 \nFD_ZERO(\u0026rset);\n//使用FD_SET宏设置rset数组中位置为sock_fd的文件描述符为1，表示需要监听该文件描述符\nFD_SET(sock_fd,\u0026rset);\n\n//设置超时时间 \nstruct timeval timeout;\ntimeout.tv_sec = 3;\ntimeout.tv_usec = 0;\n \nwhile(1) { \n   //调用select函数，检测rset数组保存的文件描述符是否已有读事件就绪，返回就绪的文件描述符个数\n   n = select(max_fd+1, \u0026rset, NULL, NULL, \u0026timeout);\n \n   //调用FD_ISSET宏，在rset数组中检测sock_fd对应的文件描述符是否就绪\n   if (FD_ISSET(sock_fd, \u0026rset)) { \n       //如果sock_fd已经就绪，表明已有客户端连接；调用accept函数建立连接\n       conn_fd = accept();\n       //设置rset数组中位置为conn_fd的文件描述符为1，表示需要监听该文件描述符\n       FD_SET(conn_fd, \u0026rset);\n   }\n\n   //依次检查已连接套接字的文件描述符\n   for (i = 0; i \u003c maxfd; i++) { \n        //调用FD_ISSET宏，在rset数组中检测文件描述符是否就绪\n       if (FD_ISSET(i, \u0026rset)) { \n         //有数据可读，进行读数据处理\n       }\n   }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404011828-77s77eh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-77s77eh",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不过从刚才的介绍中，你或许会发现 select 函数存在两个设计上的不足："
				}
			]
		},
		{
			"ID": "20230404011828-uom1buf",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011828-uom1buf",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"ID": "20230404011828-0swk0qd",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-0swk0qd",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-d9eyjly",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-d9eyjly",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "首先，select 函数对单个进程能监听的文件描述符数量是有限制的，它能监听的文件描述符个数由 __FD_SETSIZE 决定，默认值是 1024。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-73bph66",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-73bph66",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-9rqbm4r",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-9rqbm4r",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "其次，当 select 函数返回后，我们需要遍历描述符集合，才能找到具体是哪些描述符就绪了。这个遍历过程会产生一定开销，从而降低程序的性能。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011828-3zp3znp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-3zp3znp",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以，为了解决 select 函数受限于 1024 个文件描述符的不足，poll 函数对此做了改进。"
				}
			]
		},
		{
			"ID": "20230404011828-qiz95kl",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404011828-qiz95kl",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2、poll 机制与使用"
				}
			]
		},
		{
			"ID": "20230404011828-zdob8qa",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-zdob8qa",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "poll 机制的主要函数是 poll 函数，我们先来看下它的原型定义，如下所示："
				}
			]
		},
		{
			"ID": "20230404011828-a8sqzlk",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404011828-a8sqzlk",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "int poll (struct pollfd *__fds, nfds_t __nfds, int __timeout);\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404011828-trtmzbf",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011828-trtmzbf",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"ID": "20230404011828-my3dlvt",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-my3dlvt",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-6hjo150",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-6hjo150",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "*__fds：pollfd 结构体数组"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-alc90m1",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-alc90m1",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-wo7q0jr",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-wo7q0jr",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "__nfds：*__fds 数组的元素个数"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-pzm7dzb",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-pzm7dzb",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-xmhb6sh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-xmhb6sh",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "__timeout：poll 函数阻塞的超时时间"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011828-xvklv81",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-xvklv81",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "pollfd 结构体里包含了要监听的描述符，以及该描述符上要监听的事件类型。这个我们可以从 pollfd 结构体的定义中看出来，如下所示。"
				}
			]
		},
		{
			"ID": "20230404011828-lxnqx4w",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404011828-lxnqx4w",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "struct pollfd { \n    int fd;         //进行监听的文件描述符\n    short int events;       //要监听的事件类型\n    short int revents;      //实际发生的事件类型\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404011828-pdfhc6x",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011828-pdfhc6x",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"ID": "20230404011828-d491ubk",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-d491ubk",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-2aizxtq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-2aizxtq",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "fd：要监听的文件描述符"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-cqu3bta",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-cqu3bta",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-ygdjrqz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-ygdjrqz",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "events：要监听的事件类型"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-e6xjcet",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-e6xjcet",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-xwuu4p4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-xwuu4p4",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "revents：实际发生的事件类型"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011828-574cf2z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-574cf2z",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "pollfd 结构体中要监听和实际发生的事件类型，是通过以下三个宏定义来表示的，分别是 POLLRDNORM、POLLWRNORM 和 POLLERR，它们分别表示可读、可写和错误事件。"
				}
			]
		},
		{
			"ID": "20230404011828-obddwen",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404011828-obddwen",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#define POLLRDNORM  0x040       //可读事件\n#define POLLWRNORM  0x100       //可写事件\n#define POLLERR     0x008       //错误事件\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404011828-nzwa9gk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-nzwa9gk",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "好了，了解了 poll 函数的参数后，我们来看下如何使用 poll 函数完成网络通信。这个流程主要可以分成三步："
				}
			]
		},
		{
			"ID": "20230404011828-910uowe",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230404011828-910uowe",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"ID": "20230404011828-4sz7q5g",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230404011828-4sz7q5g",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-xw6dcax",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-xw6dcax",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第一步，创建 pollfd 数组和监听套接字，并进行绑定；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-myxxxoq",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230404011828-myxxxoq",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-saz021y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-saz021y",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第二步，将监听套接字加入 pollfd 数组，并设置其监听读事件，也就是客户端的连接请求；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-k6t75q1",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230404011828-k6t75q1",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-c0u2ttv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-c0u2ttv",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第三步，循环调用 poll 函数，检测 pollfd 数组中是否有就绪的文件描述符。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011828-lv4w1xx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-lv4w1xx",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "而在第三步的循环过程中，其处理逻辑又分成了两种情况："
				}
			]
		},
		{
			"ID": "20230404011828-b4x8kjc",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011828-b4x8kjc",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"ID": "20230404011828-odfva2x",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-odfva2x",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-i1z8c1s",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-i1z8c1s",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果是连接套接字就绪，这表明是有客户端连接，我们可以调用 accept 接受连接，并创建已连接套接字，并将其加入 pollfd 数组，并监听读事件；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-6o4fz61",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-6o4fz61",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-8lp22aj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-8lp22aj",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果是已连接套接字就绪，这表明客户端有读写请求，我们可以调用 recv/send 函数处理读写请求。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011828-gggr2n1",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404011828-gggr2n1",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "int sock_fd,conn_fd; //监听套接字和已连接套接字的变量\nsock_fd = socket() //创建套接字\nbind(sock_fd)   //绑定套接字\nlisten(sock_fd) //在套接字上进行监听，将套接字转为监听套接字\n\n//poll函数可以监听的文件描述符数量，可以大于1024\n#define MAX_OPEN = 2048\n\n//pollfd结构体数组，对应文件描述符\nstruct pollfd client[MAX_OPEN];\n\n//将创建的监听套接字加入pollfd数组，并监听其可读事件\nclient[0].fd = sock_fd;\nclient[0].events = POLLRDNORM; \nmaxfd = 0;\n\n//初始化client数组其他元素为-1\nfor (i = 1; i \u003c MAX_OPEN; i++)\n    client[i].fd = -1; \n\nwhile(1) { \n   //调用poll函数，检测client数组里的文件描述符是否有就绪的，返回就绪的文件描述符个数\n   n = poll(client, maxfd+1, \u0026timeout);\n   //如果监听套件字的文件描述符有可读事件，则进行处理\n   if (client[0].revents \u0026 POLLRDNORM) { \n       //有客户端连接；调用accept函数建立连接\n       conn_fd = accept();\n\n       //保存已建立连接套接字\n       for (i = 1; i \u003c MAX_OPEN; i++){ \n         if (client[i].fd \u003c 0) { \n           client[i].fd = conn_fd; //将已建立连接的文件描述符保存到client数组\n           client[i].events = POLLRDNORM; //设置该文件描述符监听可读事件\n           break;\n          }\n       }\n       maxfd = i; \n   }\n   \n   //依次检查已连接套接字的文件描述符\n   for (i = 1; i \u003c MAX_OPEN; i++) { \n       if (client[i].revents \u0026 (POLLRDNORM | POLLERR)) { \n         //有数据可读或发生错误，进行读数据处理或错误处理\n       }\n   }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404011828-4u0sd3j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-4u0sd3j",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "其实，和 select 函数相比，poll 函数的改进之处主要就在于，它允许一次监听超过 1024 个文件描述符。但是当调用了 poll 函数后，我们仍然需要遍历每个文件描述符，检测该描述符是否就绪，然后再进行处理。"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230404011828-az47z8j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-az47z8j",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那么，有没有办法可以避免遍历每个描述符呢？这就是我接下来向你介绍的 epoll 机制。"
				}
			]
		},
		{
			"ID": "20230404011828-w372qxo",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404011828-w372qxo",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3、epoll 机制实现 IO 多路复用"
				}
			]
		},
		{
			"ID": "20230404011828-myrzhhc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-myrzhhc",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "首先，epoll 机制是使用 epoll_event 结构体，来记录待监听的文件描述符及其监听的事件类型的，这和 poll 机制中使用 pollfd 结构体比较类似。"
				}
			]
		},
		{
			"ID": "20230404011828-lhsr4hc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-lhsr4hc",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那么，对于 epoll_event 结构体来说，其中包含了 epoll_data_t 联合体变量，以及整数类型的 events 变量。epoll_data_t 联合体中有记录文件描述符的成员变量 fd，而 events 变量会取值使用不同的宏定义值，来表示 epoll_data_t 变量中的文件描述符所关注的事件类型，比如一些常见的事件类型包括以下这几种。"
				}
			]
		},
		{
			"ID": "20230404011828-7ihd7iy",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011828-7ihd7iy",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"ID": "20230404011828-9hrec8z",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-9hrec8z",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-4lgsn6b",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-4lgsn6b",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "EPOLLIN：读事件，表示文件描述符对应套接字有数据可读。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-m2ki6yo",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-m2ki6yo",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-330dosv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-330dosv",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "EPOLLOUT：写事件，表示文件描述符对应套接字有数据要写。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-z3n072w",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-z3n072w",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-ifdb8n7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-ifdb8n7",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "EPOLLERR：错误事件，表示文件描述符对于套接字出错。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011828-yr6u9n6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-yr6u9n6",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下面的代码展示了 epoll_event 结构体以及 epoll_data 联合体的定义，你可以看下。"
				}
			]
		},
		{
			"ID": "20230404011828-wtsdwon",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404011828-wtsdwon",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\ntypedef union epoll_data\n{ \n  ...\n  int fd;  //记录文件描述符\n  ...\n} epoll_data_t;\n\n\nstruct epoll_event\n{ \n  uint32_t events;  //epoll监听的事件类型\n  epoll_data_t data; //应用程序数据\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404011828-rqfd1nu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-rqfd1nu",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "好了，现在我们知道，在使用 select 或 poll 函数的时候，创建好文件描述符集合或 pollfd 数组后，就可以往数组中添加我们需要监听的文件描述符。"
				}
			]
		},
		{
			"ID": "20230404011828-eh840ib",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-eh840ib",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但是对于 epoll 机制来说，我们则需要先调用 epoll_create 函数，创建一个 epoll 实例。这个 epoll 实例内部维护了两个结构，分别是记录要监听的文件描述符和已经就绪的文件描述符，而对于已经就绪的文件描述符来说，它们会被返回给用户程序进行处理。"
				}
			]
		},
		{
			"ID": "20230404011828-fd692zo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-fd692zo",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以，我们在使用 epoll 机制时，就不用像使用 select 和 poll 一样，遍历查询哪些文件描述符已经就绪了。这样一来， epoll 的效率就比 select 和 poll 有了更高的提升。"
				}
			]
		},
		{
			"ID": "20230404011828-1xz6fwt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-1xz6fwt",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在创建了 epoll 实例后，我们需要再使用 epoll_ctl 函数，给被监听的文件描述符添加监听事件类型，以及使用 epoll_wait 函数获取就绪的文件描述符。"
				}
			]
		},
		{
			"ID": "20230404011828-8h57j3z",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404011828-8h57j3z",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\nint sock_fd,conn_fd; //监听套接字和已连接套接字的变量\nsock_fd = socket() //创建套接字\nbind(sock_fd)   //绑定套接字\nlisten(sock_fd) //在套接字上进行监听，将套接字转为监听套接字\n  \nepfd = epoll_create(EPOLL_SIZE); //创建epoll实例，\n//创建epoll_event结构体数组，保存套接字对应文件描述符和监听事件类型  \nep_events = (epoll_event*)malloc(sizeof(epoll_event) * EPOLL_SIZE);\n\n//创建epoll_event变量\nstruct epoll_event ee\n//监听读事件\nee.events = EPOLLIN;\n//监听的文件描述符是刚创建的监听套接字\nee.data.fd = sock_fd;\n\n//将监听套接字加入到监听列表中  \nepoll_ctl(epfd, EPOLL_CTL_ADD, sock_fd, \u0026ee); \n  \nwhile (1) { \n   //等待返回已经就绪的描述符 \n   n = epoll_wait(epfd, ep_events, EPOLL_SIZE, -1); \n   //遍历所有就绪的描述符   \n   for (int i = 0; i \u003c n; i++) { \n       //如果是监听套接字描述符就绪，表明有一个新客户端连接到来 \n       if (ep_events[i].data.fd == sock_fd) {  \n          conn_fd = accept(sock_fd); //调用accept()建立连接\n          ee.events = EPOLLIN;  \n          ee.data.fd = conn_fd;\n          //添加对新创建的已连接套接字描述符的监听，监听后续在已连接套接字上的读事件    \n          epoll_ctl(epfd, EPOLL_CTL_ADD, conn_fd, \u0026ee); \n              \n       } else {  //如果是已连接套接字描述符就绪，则可以读数据\n           ...//读取数据并处理\n       }\n   }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404011828-x4celcg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-x4celcg",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "好了，到这里，你就了解了 epoll 函数的使用方法了。实际上，也正是因为 epoll 能自定义监听的描述符数量，以及可以直接返回就绪的描述符，Redis 在设计和实现网络通信框架时，就基于 epoll 机制中的 epoll_create、epoll_ctl 和 epoll_wait 等函数和读写事件，进行了封装开发，实现了用于网络通信的事件驱动框架，从而使得 Redis 虽然是单线程运行，但是仍然能高效应对高并发的客户端访问。"
				}
			]
		},
		{
			"ID": "20230404011828-b7pjllq",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230404011828-b7pjllq",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "四、总结"
				}
			]
		},
		{
			"ID": "20230404011828-gh0ib6i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-gh0ib6i",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "主要介绍了 Redis 网络通信依赖的操作系统底层机制，也就是 IO 多路复用机制。"
				}
			]
		},
		{
			"ID": "20230404011828-dz1w2i6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-dz1w2i6",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "由于 Redis 是单线程程序，如果使用基本的 Socket 编程模型的话，只能对一个监听套接字或一个已连接套接字进行监听。而当 Redis 实例面临很多并发的客户端时，这种处理方式的效率就会很低。"
				}
			]
		},
		{
			"ID": "20230404011828-1ynqhxt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-1ynqhxt",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以，和基本的 Socket 通信相比，使用 IO 多路复用机制，就可以一次性获得就绪的多个套接字，从而避免了逐个检测套接字的开销。"
				}
			]
		},
		{
			"ID": "20230404011828-40pg4l3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-40pg4l3",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "以最常用的 Linux 操作系统为例，具体介绍了 Linux 系统提供的三种 IO 多路复用机制，分别是 select、poll 和 epoll。这三种机制在能监听的描述符数量和查找就绪描述符的方法上是不一样的，你可以重点参考下图，来掌握它们的不同之处。这些差异，其实也决定了 epoll 相比于 select 和 poll 来说，效率更高，也应用更广泛。"
				}
			]
		},
		{
			"ID": "20230404011828-yt8rlaw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011828-yt8rlaw",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/bfd7c5b4d44c49598cfcca9f5b936bf3-20230404011828-sl7qdru.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230404011828-jpfi91u",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011828-jpfi91u",
				"updated": "20230404011828"
			},
			"Children": [
				{
					"ID": "20230404011828-xbe0t2x",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-xbe0t2x",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-j2fswpx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-j2fswpx",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "单线程服务器模型，面临的最大的问题就是，一个线程如何处理多个客户端请求？解决这种问题的办法就是「IO 多路复用」。它本质上是应用层不用维护多个客户端的连接状态，而是把它们「托管」给了操作系统，操作系统维护这些连接的状态变化，之后应用层只管问操作系统，哪些 socket 有数据可读/可写就好了，大大简化了应用层的复杂度"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-d5zohty",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-d5zohty",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-xjurmk1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-xjurmk1",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "IO 多路复用机制要想高效使用，一般还需要把 socket 设置成「非阻塞」模式，即 socket 没有数据可读/可写时，应用层去 read/write socket 也不会阻塞住（内核会返回指定错误，应用层可继续重试），这样应用层就可以去处理其它业务逻辑，不会阻塞影响性能"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-42l0w4c",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-42l0w4c",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-apvkhal",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-apvkhal",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "为什么 Redis 要使用「单线程」处理客户端请求？本质上是因为，Redis 操作的是内存，操作内存数据是极快的，所以 Redis 的瓶颈不在 CPU，优化的重点就在网络 IO 上，高效的 IO 多路复用机制，正好可以满足这种需求，模型简单，性能也极高"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-qgvyoif",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-qgvyoif",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-rrsrz3p",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-rrsrz3p",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "但成也萧何败也萧何，因为 Redis 处理请求是「单线程」，所以如果有任意请求在 Server 端发生耗时（例如操作 bigkey，或一次请求数据过多），就会导致后面的请求发生「排队」，业务端就会感知到延迟增大，性能下降"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011828-7yb7aut",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011828-7yb7aut",
						"updated": "20230404011828"
					},
					"Children": [
						{
							"ID": "20230404011828-7kypqg2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011828-7kypqg2",
								"updated": "20230404011828"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "基于此，Redis 又做了很多优化：一些耗时的操作，不再放在主线程处理，而是丢到后台线程慢慢执行。例如，异步关闭 fd，异步释放内存、后台 AOF 刷盘这些操作。所以 Redis Server 其实是「多线程」的，只不过最核心的处理请求逻辑是单线程的，这点一定要区分开"
								}
							]
						}
					]
				}
			]
		}
	]
}