{
	"ID": "20230404011830-gsi5pel",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230404011830-gsi5pel",
		"title": "吃透Redis（五）：网络框架篇-reactor模型_redis的reactor模式_吃透Java的博客-CSDN博客",
		"updated": "20230404011830"
	},
	"Children": [
		{
			"ID": "20230404011830-4469mly",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230404011830-4469mly",
				"updated": "20230404011830"
			}
		},
		{
			"ID": "20230404011830-rcax3od",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-rcax3od",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-2ymqo82",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-2ymqo82",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-gymine6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-gymine6",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126200112",
									"TextMarkTextContent": "https://blog.csdn.net/u013277209/article/details/126200112"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-e29dupi",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-e29dupi",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-574rjp2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-574rjp2",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Redis 是由 C 语言实现的，它采用的正是「单 Reactor 单进程」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。......"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-cwq8b65",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-cwq8b65",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-67ov30y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-67ov30y",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2023-04-04 01:18:30"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-0arvw2m",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230404011830-0arvw2m",
				"updated": "20230404011830"
			}
		},
		{
			"ID": "20230404011830-u00u3bj",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404011830-u00u3bj",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "文章目录"
				}
			]
		},
		{
			"ID": "20230404011830-0oofd5s",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-0oofd5s",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-e4p13jb",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-e4p13jb",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-m35if84",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20230404011830-m35if84",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"ID": "20230404011830-2w536is",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230404011830-2w536is",
										"updated": "20230404011830"
									},
									"Children": [
										{
											"ID": "20230404011830-hzeb8ft",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230404011830-hzeb8ft",
												"updated": "20230404011830"
											},
											"Children": [
												{
													"Type": "NodeTextMark",
													"TextMarkType": "a",
													"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126200112#_1",
													"TextMarkTextContent": "演进"
												}
											]
										}
									]
								},
								{
									"ID": "20230404011830-uhxctwf",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230404011830-uhxctwf",
										"updated": "20230404011830"
									},
									"Children": [
										{
											"ID": "20230404011830-us9u6gb",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230404011830-us9u6gb",
												"updated": "20230404011830"
											},
											"Children": [
												{
													"Type": "NodeTextMark",
													"TextMarkType": "a",
													"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126200112#Reactor_81",
													"TextMarkTextContent": "Reactor模型"
												}
											]
										}
									]
								},
								{
									"ID": "20230404011830-5gyeeip",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230404011830-5gyeeip",
										"updated": "20230404011830"
									},
									"Children": [
										{
											"ID": "20230404011830-hkvx7ep",
											"Type": "NodeList",
											"ListData": {},
											"Properties": {
												"id": "20230404011830-hkvx7ep",
												"updated": "20230404011830"
											},
											"Children": [
												{
													"ID": "20230404011830-mgxn7ik",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20230404011830-mgxn7ik",
														"updated": "20230404011830"
													},
													"Children": [
														{
															"ID": "20230404011830-cpjawd3",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20230404011830-cpjawd3",
																"updated": "20230404011830"
															},
															"Children": [
																{
																	"Type": "NodeTextMark",
																	"TextMarkType": "a",
																	"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126200112#_Reactor__82",
																	"TextMarkTextContent": "单 Reactor 单线程"
																}
															]
														}
													]
												},
												{
													"ID": "20230404011830-b8eyygd",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20230404011830-b8eyygd",
														"updated": "20230404011830"
													},
													"Children": [
														{
															"ID": "20230404011830-49bkb9g",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20230404011830-49bkb9g",
																"updated": "20230404011830"
															},
															"Children": [
																{
																	"Type": "NodeTextMark",
																	"TextMarkType": "a",
																	"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126200112#_Reactor__114",
																	"TextMarkTextContent": "单 Reactor 多线程"
																}
															]
														}
													]
												},
												{
													"ID": "20230404011830-nbxh9xk",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20230404011830-nbxh9xk",
														"updated": "20230404011830"
													},
													"Children": [
														{
															"ID": "20230404011830-he5p7pg",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20230404011830-he5p7pg",
																"updated": "20230404011830"
															},
															"Children": [
																{
																	"Type": "NodeTextMark",
																	"TextMarkType": "a",
																	"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126200112#_Reactor__137",
																	"TextMarkTextContent": "多 Reactor 多进程"
																}
															]
														}
													]
												}
											]
										}
									]
								},
								{
									"ID": "20230404011830-b6098ll",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20230404011830-b6098ll",
										"updated": "20230404011830"
									},
									"Children": [
										{
											"ID": "20230404011830-mk1thj8",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20230404011830-mk1thj8",
												"updated": "20230404011830"
											},
											"Children": [
												{
													"Type": "NodeTextMark",
													"TextMarkType": "a",
													"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126200112#Proactor_160",
													"TextMarkTextContent": "Proactor模型"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-b1vcdx1",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230404011830-b1vcdx1",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "演进"
				}
			]
		},
		{
			"ID": "20230404011830-h4dn0fs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-h4dn0fs",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果要让服务器服务多个客户端，那么最直接的方式就是为每一条连接"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://so.csdn.net/so/search?q=%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B\u0026spm=1001.2101.3001.7020",
					"TextMarkTextContent": "创建线程"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20230404011830-v361u1q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-v361u1q",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其实创建进程也是可以的，原理是一样的，进程和线程的区别在于线程比较轻量级些，线程的创建和线程间切换的成本要小些，为了描述简述，后面都以线程为例。"
				}
			]
		},
		{
			"ID": "20230404011830-bz0bfpl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-bz0bfpl",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "处理完业务逻辑后，随着连接关闭后线程也同样要销毁了，但是这样不停地创建和销毁线程，不仅会带来性能开销，也会造成浪费资源，而且如果要连接几万条连接，创建几万个线程去应对也是不现实的。"
				}
			]
		},
		{
			"ID": "20230404011830-crdnmyb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-crdnmyb",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "要这么解决这个问题呢？我们可以使用「资源复用」的方式。"
				}
			]
		},
		{
			"ID": "20230404011830-iy7azks",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-iy7azks",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "也就是不用再为每个连接创建线程，而是创建一个「线程池」，将连接分配给线程，然后一个线程可以处理多个连接的业务。"
				}
			]
		},
		{
			"ID": "20230404011830-2heoh03",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-2heoh03",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不过，这样又引来一个新的问题，线程怎样才能高效地处理多个连接的业务？"
				}
			]
		},
		{
			"ID": "20230404011830-y08s4w6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-y08s4w6",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当一个连接对应一个线程时，线程一般采用「read -\u003e 业务处理 -\u003e send」的处理流程，如果当前连接没有数据可读，那么线程会阻塞在 read 操作上（ socket 默认情况是阻塞 I/O），不过这种阻塞方式并不影响其他线程。"
				}
			]
		},
		{
			"ID": "20230404011830-aemr06l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-aemr06l",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但是引入了线程池，那么一个线程要处理多个连接的业务，线程在处理某个连接的 read 操作时，如果遇到没有数据可读，就会发生阻塞，那么线程就没办法继续处理其他连接的业务。"
				}
			]
		},
		{
			"ID": "20230404011830-r4lejgr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-r4lejgr",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "要解决这一个问题，最简单的方式就是将 socket 改成非阻塞，然后线程不断地轮询调用 read 操作来判断是否有数据，这种方式虽然该能够解决阻塞的问题，但是解决的方式比较粗暴，因为轮询是要消耗 CPU 的，而且随着一个 线程处理的连接越多，轮询的效率就会越低。"
				}
			]
		},
		{
			"ID": "20230404011830-8nczde8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-8nczde8",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上面的问题在于，线程并不知道当前连接是否有数据可读，从而需要每次通过 read 去试探。"
				}
			]
		},
		{
			"ID": "20230404011830-2gqn52k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-2gqn52k",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那有没有办法在只有当连接上有数据的时候，线程才去发起读请求呢？答案是有的，实现这一技术的就是 I/O 多路复用。"
				}
			]
		},
		{
			"ID": "20230404011830-wpwwe5l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-wpwwe5l",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "I/O 多路复用技术会用一个系统调用函数来监听我们所有关心的连接，也就说可以在一个监控线程里面监控很多的连接。"
				}
			]
		},
		{
			"ID": "20230404011830-3krlhn8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-3krlhn8",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们熟悉的 select/poll/epoll 就是内核提供给用户态的多路复用系统调用，线程可以通过一个系统调用函数从内核中获取多个事件。"
				}
			]
		},
		{
			"ID": "20230404011830-uua2033",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-uua2033",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "select/poll/epoll 是如何获取网络事件的呢？"
				}
			]
		},
		{
			"ID": "20230404011830-sd82y7u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-sd82y7u",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在获取事件时，先把我们要关心的连接传给内核，再由内核检测："
				}
			]
		},
		{
			"ID": "20230404011830-7nl4d7q",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-7nl4d7q",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-xubf9hl",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-xubf9hl",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-c97alor",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-c97alor",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果没有事件发生，线程只需阻塞在这个系统调用，而无需像前面的线程池方案那样轮训调用 read 操作来判断是否有数据。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-yppg49u",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-yppg49u",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-227v2mw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-227v2mw",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果有事件发生，内核会返回产生了事件的连接，线程就会从阻塞状态返回，然后在用户态中再处理这些连接对应的业务即可。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-q27zs3j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-q27zs3j",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当下开源软件能做到网络高性能的原因就是 I/O 多路复用吗？"
				}
			]
		},
		{
			"ID": "20230404011830-v5606gw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-v5606gw",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "是的，基本是基于 I/O 多路复用，用过 I/O 多路复用接口写网络程序的同学，肯定知道是面向过程的方式写代码的，这样的开发的效率不高。"
				}
			]
		},
		{
			"ID": "20230404011830-2g1x6wy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-2g1x6wy",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "于是，大佬们基于面向对象的思想，对 I/O 多路复用作了一层封装，让使用者不用考虑底层网络 API 的细节，只需要关注应用代码的编写。"
				}
			]
		},
		{
			"ID": "20230404011830-ym20uyz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-ym20uyz",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "大佬们还为这种模式取了个让人第一时间难以理解的名字："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://so.csdn.net/so/search?q=Reactor\u0026spm=1001.2101.3001.7020",
					"TextMarkTextContent": "Reactor"
				},
				{
					"Type": "NodeText",
					"Data": " 模式。\nReactor 翻译过来的意思是「反应堆」，可能大家会联想到物理学里的核反应堆，实际上并不是的这个意思。"
				}
			]
		},
		{
			"ID": "20230404011830-s76v7x4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-s76v7x4",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里的反应指的是「对事件反应」，也就是来了一个事件，Reactor 就有相对应的反应/响应。"
				}
			]
		},
		{
			"ID": "20230404011830-ggemy59",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-ggemy59",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "事实上，Reactor 模式也叫 Dispatcher 模式，我觉得这个名字更贴合该模式的含义，即 I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程。"
				}
			]
		},
		{
			"ID": "20230404011830-me1tyj1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-me1tyj1",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下："
				}
			]
		},
		{
			"ID": "20230404011830-1yx11sm",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-1yx11sm",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-khof9ea",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-khof9ea",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-nd42u5e",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-nd42u5e",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-lebh2vh",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-lebh2vh",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-wh2uwca",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-wh2uwca",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "处理资源池负责处理事件，如 read -\u003e 业务逻辑 -\u003e send；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-8mgej2n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-8mgej2n",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于："
				}
			]
		},
		{
			"ID": "20230404011830-2whg1c6",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-2whg1c6",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-h8xv6r8",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-h8xv6r8",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-9o2fdgw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-9o2fdgw",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Reactor 的数量可以只有一个，也可以有多个；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-hlaxkos",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-hlaxkos",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-im556bd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-im556bd",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "处理资源池可以是单个进程 / 线程，也可以是多个进程 /线程；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-a9nyfch",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-a9nyfch",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "将上面的两个因素排列组设一下，理论上就可以有 4 种方案选择："
				}
			]
		},
		{
			"ID": "20230404011830-y2iiuha",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-y2iiuha",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-ptqanyj",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-ptqanyj",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-q2tm0s9",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-q2tm0s9",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "单 Reactor 单进程 / 线程；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-5zqsxuw",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-5zqsxuw",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-b61i769",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-b61i769",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "单 Reactor 多进程 / 线程；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-xeo74my",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-xeo74my",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-eon2b98",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-eon2b98",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "多 Reactor 单进程 / 线程；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-oghrjrq",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-oghrjrq",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-ym3askc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-ym3askc",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "多 Reactor 多进程 / 线程；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-v07sany",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-v07sany",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其中，「多 Reactor 单进程 / 线程」实现方案相比「单 Reactor 单进程 / 线程」方案，不仅复杂而且也没有性能优势，因此实际中并没有应用。"
				}
			]
		},
		{
			"ID": "20230404011830-ng6dlwx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-ng6dlwx",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "剩下的 3 个方案都是比较经典的，且都有应用在实际的项目中："
				}
			]
		},
		{
			"ID": "20230404011830-ogu2zk0",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-ogu2zk0",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-6mq4r7d",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-6mq4r7d",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-fqtnm03",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-fqtnm03",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "单 Reactor 单进程 / 线程；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-e1mwvb5",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-e1mwvb5",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-lq8ecfj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-lq8ecfj",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "单 Reactor 多线程 / 进程；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-byt969q",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-byt969q",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-3dfl035",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-3dfl035",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "多 Reactor 多进程 / 线程；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-mwb8rdm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-mwb8rdm",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "方案具体使用进程还是线程，要看使用的编程语言以及平台有关："
				}
			]
		},
		{
			"ID": "20230404011830-z4sldeo",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-z4sldeo",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-kq0lnzu",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-kq0lnzu",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-is9u7fn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-is9u7fn",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Java 语言一般使用线程，比如 Netty;"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-re3myvy",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-re3myvy",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-q2dcwjw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-q2dcwjw",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C 语言使用进程和线程都可以，例如 Nginx 使用的是进程，Memcache 使用的是线程。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-ilpp0mi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-ilpp0mi",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接下来，分别介绍这三个经典的 Reactor 方案。"
				}
			]
		},
		{
			"ID": "20230404011830-ys3ywea",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230404011830-ys3ywea",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Reactor模型"
				}
			]
		},
		{
			"ID": "20230404011830-x7auqiq",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404011830-x7auqiq",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "单 Reactor 单线程"
				}
			]
		},
		{
			"ID": "20230404011830-mf93xxh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-mf93xxh",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一般来说，C 语言实现的是「单 Reactor单进程」的方案，因为 C 语编写完的程序，运行后就是一个独立的进程，不需要在进程中再创建线程。"
				}
			]
		},
		{
			"ID": "20230404011830-ow4fxsq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-ow4fxsq",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "而 Java 语言实现的是「单 Reactor单线程」的方案，因为 Java 程序是跑在 Java 虚拟机这个进程上面的，虚拟机中有很多线程，我们写的 Java 程序只是其中的一个线程而已。"
				}
			]
		},
		{
			"ID": "20230404011830-vso8eyh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-vso8eyh",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们来看看「单 Reactor 单进程」的方案示意图：\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/d0eaced87c5847f8be8c7a362024f01f-20230404011829-q338wn6.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n可以看到进程里有 Reactor、Acceptor、Handler 这三个对象："
				}
			]
		},
		{
			"ID": "20230404011830-iyhh5wp",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-iyhh5wp",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-skx135h",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-skx135h",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-v7qahgw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-v7qahgw",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Reactor 对象的作用是监听和分发事件；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-4citp0j",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-4citp0j",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-4iwouwo",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-4iwouwo",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Acceptor 对象的作用是获取连接；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-a1f91la",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-a1f91la",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-dmflbcx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-dmflbcx",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Handler 对象的作用是处理业务；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-vl21r42",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-vl21r42",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对象里的 select、accept、read、send 是系统调用函数，dispatch 和 「业务处理」是需要完成的操作，其中 dispatch 是分发事件操作。"
				}
			]
		},
		{
			"ID": "20230404011830-m8znskn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-m8znskn",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接下来，介绍下「单 Reactor 单进程」这个方案："
				}
			]
		},
		{
			"ID": "20230404011830-nmt5nya",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-nmt5nya",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-dnt8ru3",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-dnt8ru3",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-1z3seu9",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-1z3seu9",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-ndaeu32",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-ndaeu32",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-5dzrurl",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-5dzrurl",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-crinhd1",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-crinhd1",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-zabmmlx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-zabmmlx",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-jwsr277",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-jwsr277",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-yk0dc4w",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-yk0dc4w",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Handler 对象通过 read -\u003e 业务处理 -\u003e send 的流程来完成完整的业务流程。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-j2k1az9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-j2k1az9",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "单 Reactor 单进程的方案因为全部工作都在同一个进程内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://so.csdn.net/so/search?q=%E5%A4%9A%E8%BF%9B%E7%A8%8B\u0026spm=1001.2101.3001.7020",
					"TextMarkTextContent": "多进程"
				},
				{
					"Type": "NodeText",
					"Data": "竞争。"
				}
			]
		},
		{
			"ID": "20230404011830-vxamrug",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-vxamrug",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但是，这种方案存在 2 个缺点："
				}
			]
		},
		{
			"ID": "20230404011830-h697k72",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-h697k72",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-wfkr6zw",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-wfkr6zw",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-eg3a35a",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-eg3a35a",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第一个缺点，因为只有一个进程，无法充分利用 多核 CPU 的性能；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-1jpl751",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-1jpl751",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-554jbqr",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-554jbqr",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，如果业务处理耗时比较长，那么就造成响应的延迟；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-v1xxa8v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-v1xxa8v",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以，单 Reactor 单进程的方案不适用计算机密集型的场景，只适用于业务处理非常快速的场景。"
				}
			]
		},
		{
			"ID": "20230404011830-acgciym",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-acgciym",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 是由 C 语言实现的，它采用的正是「单 Reactor 单进程」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。"
				}
			]
		},
		{
			"ID": "20230404011830-qbc26d7",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404011830-qbc26d7",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "单 Reactor 多线程"
				}
			]
		},
		{
			"ID": "20230404011830-0jji8on",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-0jji8on",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果要克服「单 Reactor 单线程 / 进程」方案的缺点，那么就需要引入多线程 / 多进程，这样就产生了单 Reactor 多线程 / 多进程的方案。"
				}
			]
		},
		{
			"ID": "20230404011830-5ra9wc9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-5ra9wc9",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "闻其名不如看其图，先来看看「单 Reactor 多线程」方案的示意图如下："
				}
			]
		},
		{
			"ID": "20230404011830-cpqv4uf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-cpqv4uf",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/c3239b1ad22446a890d0c6b630763cc7-20230404011829-9df46my.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n详细说一下这个方案："
				}
			]
		},
		{
			"ID": "20230404011830-57cc2br",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-57cc2br",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-lzurosm",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-lzurosm",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-9mbnszr",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-9mbnszr",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-nfdpsr9",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-nfdpsr9",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-i4crw42",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-i4crw42",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-324vnmr",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-324vnmr",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-8h9oi4z",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-8h9oi4z",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-fa5uo7e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-fa5uo7e",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上面的三个步骤和单 Reactor 单线程方案是一样的，接下来的步骤就开始不一样了："
				}
			]
		},
		{
			"ID": "20230404011830-nu6y8hy",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-nu6y8hy",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-yxw99gp",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-yxw99gp",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-tdhoaxl",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-tdhoaxl",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-1g4lqm2",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-1g4lqm2",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-47sod1q",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-47sod1q",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-bj6g0re",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-bj6g0re",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "单 Reator 多线程的方案优势在于能够充分利用多核 CPU 的能，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。"
				}
			]
		},
		{
			"ID": "20230404011830-prxk5hf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-prxk5hf",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "例如，子线程完成业务处理后，要把结果传递给主线程的 Reactor 进行发送，这里涉及共享数据的竞争。"
				}
			]
		},
		{
			"ID": "20230404011830-bkxgoq7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-bkxgoq7",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "要避免多线程由于竞争共享资源而导致数据错乱的问题，就需要在操作共享资源前加上互斥锁，以保证任意时间里只有一个线程在操作共享资源，待该线程操作完释放互斥锁后，其他线程才有机会操作共享数据。"
				}
			]
		},
		{
			"ID": "20230404011830-1yfui7s",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230404011830-1yfui7s",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多 Reactor 多进程"
				}
			]
		},
		{
			"ID": "20230404011830-azoqdgz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-azoqdgz",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "要解决「单 Reactor」的问题，就是将「单 Reactor」实现成「多 Reactor」，这样就产生了第 多 Reactor 多进程 / 线程的方案。\n老规矩，闻其名不如看其图。多 Reactor 多进程 / 线程方案的示意图如下（以线程为例）："
				}
			]
		},
		{
			"ID": "20230404011830-3ovqh1n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-3ovqh1n",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/af986012c2eb4ba28a3df8602cfabf51-20230404011829-ehnmr4p.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n方案详细说明如下："
				}
			]
		},
		{
			"ID": "20230404011830-6t27fl5",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-6t27fl5",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-i9dss95",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-i9dss95",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-2wu5g1e",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-2wu5g1e",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程；"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-mzwaimm",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-mzwaimm",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-f7be737",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-f7be737",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-4lgd2wt",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-4lgd2wt",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-ghcjiw9",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-ghcjiw9",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-j7tppuv",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-j7tppuv",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-74x68yr",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-74x68yr",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Handler 对象通过 read -\u003e 业务处理 -\u003e send 的流程来完成完整的业务流程。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-wn5ubv2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-wn5ubv2",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多 Reactor 多线程的方案虽然看起来复杂的，但是实际实现时比单 Reactor 多线程的方案要简单的多，原因如下："
				}
			]
		},
		{
			"ID": "20230404011830-vbi5al4",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-vbi5al4",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-h0tm8zf",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-h0tm8zf",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-rexu2qy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-rexu2qy",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-xjitkf2",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-xjitkf2",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-8bki3ty",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-8bki3ty",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-4yhz1yb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-4yhz1yb",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "大名鼎鼎的两个开源软件 Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案。"
				}
			]
		},
		{
			"ID": "20230404011830-i7tmodc",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-i7tmodc",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-9531rq0",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-9531rq0",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-j5opfoz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-j5opfoz",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "nginx：nginx是多进程模型，master进程不处理网络IO，每个Wroker进程是一个独立的单Reacotr单线程模型。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-ryjruz5",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-ryjruz5",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-b4fzinc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-b4fzinc",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "netty：通信绝对的王者，默认是多Reactor，主Reacotr只负责建立连接，然后把建立好的连接给到从Reactor，从Reactor负责IO读写。当然可以专门调整为单Reactor。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-v665k2x",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-v665k2x",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-wlc89d4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-wlc89d4",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "kafka：kafka也是多Reactor，但是因为Kafka主要与磁盘IO交互，因此真正的读写数据不是从Reactor处理的，而是有一个worker线程池，专门处理磁盘IO，从Reactor负责网络IO，然后把任务交给worker线程池处理。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-x3sdxv2",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230404011830-x3sdxv2",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Proactor模型"
				}
			]
		},
		{
			"ID": "20230404011830-8mswhvs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-8mswhvs",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Reactor 是非阻塞同步网络模型，因为真正的 read 和 send 操作都需要用户进程同步操作。这里的“同步”指用户进程在执行 read 和 send 这类 I/O 操作的时候是同步的，如果把 I/O 操作改为异步就能够进一步提升性能，这就是异步网络模型 Proactor。"
				}
			]
		},
		{
			"ID": "20230404011830-ex5dmz8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-ex5dmz8",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Proactor 中文翻译为“前摄器”比较难理解，与其类似的单词是 proactive，含义为“主动的”，因此我们照猫画虎翻译为“主动器”反而更好理解。Reactor 可以理解为“来了事件我通知你，你来处理”，而 Proactor 可以理解为“来了事件我来处理，处理完了我通知你”。这里的“我”就是操作系统内核，“事件”就是有新连接、有数据可读、有数据可写的这些 I/O 事件，“你”就是我们的程序代码。"
				}
			]
		},
		{
			"ID": "20230404011830-530xst2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-530xst2",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Proactor 模型示意图是：\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "在这里插入图片描述"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/f26cbbed871a4562aa3ad22b9d69992f-20230404011829-6ghhtt8.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n详细介绍一下 Proactor 方案："
				}
			]
		},
		{
			"ID": "20230404011830-ebp7goo",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011830-ebp7goo",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"ID": "20230404011830-w57fdm5",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-w57fdm5",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-r3bklfi",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-r3bklfi",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Proactor Initiator 负责创建 Proactor 和 Handler，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-m36zqt9",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-m36zqt9",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-e4l8yrq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-e4l8yrq",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Asynchronous Operation Processor 负责处理注册请求，并完成 I/O 操作。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-3p9q1m5",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-3p9q1m5",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-ibhsy5c",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-ibhsy5c",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Asynchronous Operation Processor 完成 I/O 操作后通知 Proactor。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-rg2um2v",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-rg2um2v",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-nqa0lhq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-nqa0lhq",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011830-e8ltwnc",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011830-e8ltwnc",
						"updated": "20230404011830"
					},
					"Children": [
						{
							"ID": "20230404011830-zzvkgyx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011830-zzvkgyx",
								"updated": "20230404011830"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Handler 完成业务处理，Handler 也可以注册新的 Handler 到内核进程。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011830-4pcx4tr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011830-4pcx4tr",
				"updated": "20230404011830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "理论上 Proactor 比 Reactor 效率要高一些，异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠，但要实现真正的异步 I/O，操作系统需要做大量的工作。目前 Windows 下通过 IOCP 实现了真正的异步 I/O，而在 Linux 系统下的 AIO 并不完善，因此在 Linux 下实现高并发网络编程时都是以 Reactor 模式为主。所以即使 Boost.Asio 号称实现了 Proactor 模型，其实它在 Windows 下采用 IOCP，而在 Linux 下是用 Reactor 模式（采用 epoll）模拟出来的异步模型。"
				}
			]
		}
	]
}