{
	"ID": "20230404011833-on553j2",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230404011833-on553j2",
		"title": "吃透Redis（七）：网络框架篇-redis 6.0 IO多线程原子性保证_java多线程操作redis_吃透Java的博客-CSDN博客",
		"updated": "20230404011833"
	},
	"Children": [
		{
			"ID": "20230404011833-fg26lnj",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230404011833-fg26lnj",
				"updated": "20230404011833"
			}
		},
		{
			"ID": "20230404011833-5qh3434",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011833-5qh3434",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"ID": "20230404011833-pjriem9",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011833-pjriem9",
						"updated": "20230404011833"
					},
					"Children": [
						{
							"ID": "20230404011833-dfr81ss",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011833-dfr81ss",
								"updated": "20230404011833"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://blog.csdn.net/u013277209/article/details/126274656",
									"TextMarkTextContent": "https://blog.csdn.net/u013277209/article/details/126274656"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011833-csfmjyw",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011833-csfmjyw",
						"updated": "20230404011833"
					},
					"Children": [
						{
							"ID": "20230404011833-d7d44ee",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011833-d7d44ee",
								"updated": "20230404011833"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Redis的主线程处理客户端连接操作Redis的IO线程处理客户端的读、写操作Redis IO线程处理时，Redis主线程处理部分连接完毕后需要等待IO线程处理读写完成。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011833-jnfgqwp",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011833-jnfgqwp",
						"updated": "20230404011833"
					},
					"Children": [
						{
							"ID": "20230404011833-bxoch3s",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011833-bxoch3s",
								"updated": "20230404011833"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2023-04-04 01:18:33"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011833-l67y6f3",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230404011833-l67y6f3",
				"updated": "20230404011833"
			}
		},
		{
			"ID": "20230404011833-ohp9ir1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011833-ohp9ir1",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/original-20230404011832-hrhke16.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230404011833-xnix5ko",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011833-xnix5ko",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://blog.csdn.net/u013277209",
					"TextMarkATitle": "吃透Java",
					"TextMarkTextContent": "吃透Java"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/newCurrentTime2-20230404011832-psx8r4i.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "于 2022-08-10 21:31:03 发布"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/articleReadEyes2-20230404011832-il8ot2j.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "444"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/tobarCollect2-20230404011832-p68s3yq.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkTextContent": "                                                                           收藏                                              "
				}
			]
		},
		{
			"ID": "20230404011833-fnall2q",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404011833-fnall2q",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "                         版权声明：本文为博主原创文章，遵循[ CC 4.0 BY-SA ](http://creativecommons.org/licenses/by-sa/4.0/)版权协议，转载请附上原文出处链接和本声明。                       \n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404011833-21nd9jr",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404011833-21nd9jr",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "bGluaw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\n                            本文链接：https://blog.csdn.net/u013277209/article/details/126274656\n                      \n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404011833-ytlpjba",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011833-ytlpjba",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkTextContent": "版权"
				}
			]
		},
		{
			"ID": "20230404011833-ada4iql",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011833-ada4iql",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis server 一旦和一个客户端建立连接后，就会在事件驱动框架中注册可读事件，这就对应了客户端的命令请求。而对于整个命令处理的过程来说，我认为主要可以分成四个阶段：命令读取阶段、命令解析阶段、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://so.csdn.net/so/search?q=%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C\u0026spm=1001.2101.3001.7020",
					"TextMarkTextContent": "命令执行"
				},
				{
					"Type": "NodeText",
					"Data": "阶段、结果返回阶段。"
				}
			]
		},
		{
			"ID": "20230404011833-o73vs7s",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011833-o73vs7s",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这四个阶段在 Redis 6.0 版本前都是由主 IO 线程来执行完成的。虽然 Redis 使用了 IO "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://so.csdn.net/so/search?q=%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\u0026spm=1001.2101.3001.7020",
					"TextMarkTextContent": "多路复用"
				},
				{
					"Type": "NodeText",
					"Data": "机制，但是该机制只是一次性获取多个就绪的 socket 描述符，对应了多个发送命令请求的客户端。而 Redis 在主 IO 线程中，还是逐一来处理每个客户端上的命令的，所以命令执行的原子性依然可以得到保证。"
				}
			]
		},
		{
			"ID": "20230404011833-hcrv29w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011833-hcrv29w",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "而当使用了 Redis 6.0 版本后，命令处理过程中的读取、解析和结果写回，就由多个 IO 线程来处理了。不过你也不用担心，多个 IO 线程只是完成解析第一个读到的命令，命令的实际执行还是由主 IO 线程处理。当多个 IO 线程在并发写回结果时，命令就已经执行完了，不存在多 IO 线程冲突的问题。所以，使用了多 IO 线程后，命令执行的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%80%A7\u0026spm=1001.2101.3001.7020",
					"TextMarkTextContent": "原子性"
				},
				{
					"Type": "NodeText",
					"Data": "仍然可以得到保证。"
				}
			]
		},
		{
			"ID": "20230404011833-ryzs4c7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011833-ryzs4c7",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为什么并发IO线程读写还能保证处理的原子性？"
				}
			]
		},
		{
			"ID": "20230404011833-e92rgau",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011833-e92rgau",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "答：主线程负责把read pending队列中的数据放入到这些IO线程的io_threads_list队列，并且处理io_threads_list[0]也就是主线程处理IO操作，处理完成之后，主线程自旋等待IO线程处理完之后，才开始一个个执行命令，所以保证了原子性。看源码："
				}
			]
		},
		{
			"ID": "20230404011833-8ivzk63",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230404011833-8ivzk63",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "void beforeSleep(struct aeEventLoop *eventLoop) { \n    ...\n    // 处理read pending队列的客户端队列\n    handleClientsWithPendingReadsUsingThreads();\n    ...\n}\n\nint handleClientsWithPendingReadsUsingThreads(void) { \n    // 获取clients_pending_read队列列表迭代器\n    listIter li;\n    listNode *ln;\n    listRewind(server.clients_pending_read,\u0026li);\n    int item_id = 0;\n  \n    // 一，放入不同的IO线程中\n    // 遍历所有待读取的客户端，并将其散列到不同IO线程处理列表中\n    while((ln = listNext(\u0026li))) { \n        client *c = listNodeValue(ln);\n        // 通过取余方式散列获取IO线程下标\n        int target_id = item_id % server.io_threads_num;\n        // 将该客户端放入该下标列表中\n        listAddNodeTail(io_threads_list[target_id],c);\n        item_id++;\n    }\n    // 所有连接放入到IO线程处理列表后将IO线程操作标识为IO_THREADS_OP_READ读操作\n    io_threads_op = IO_THREADS_OP_READ;\n    for (int j = 1; j \u003c server.io_threads_num; j++) { \n        // 设置io_threads_pending为非零数，也即当前需要处理的客户端数量，这时线程将会响应该操作，开始处理客户端连接\n        int count = listLength(io_threads_list[j]);\n        io_threads_pending[j] = count;\n    }\n  \n    // 二、处理主线程的IO读写时间\n    //io_threads_list数组0下标处为main线程处理，也即main线程处理一部分读IO\n    listRewind(io_threads_list[0],\u0026li);\n    while((ln = listNext(\u0026li))) { \n        client *c = listNodeValue(ln);\n        readQueryFromClient(c-\u003econn);\n    }\n    // 清空主线程负责的下标为0的客户端列表，其他的下标由IO线程自己处理\n    listEmpty(io_threads_list[0]);\n  \n    // 三、自旋等待所有IO线程全部处理完\n    // 自旋等嗲其他线程处理IO完毕\n    while(1) { \n        unsigned long pending = 0;\n        for (int j = 1; j \u003c server.io_threads_num; j++)\n            pending += io_threads_pending[j];\n        if (pending == 0) break;\n    }\n  \n    // 四、执行命令\n    // 当所有IO线程将clients_pending_read的客户端读IO处理完毕后，在主线程中处理客户端命令\n    while(listLength(server.clients_pending_read)) { \n        ln = listFirst(server.clients_pending_read);\n        client *c = listNodeValue(ln);\n        // 去掉CLIENT_PENDING_READ标志位，并将其从clients_pending_read队列中移除\n        c-\u003eflags \u0026= ~CLIENT_PENDING_READ;\n        listDelNode(server.clients_pending_read,ln);\n        // 如果设置暂停客户端请求那么继续循环\n        if (clientsArePaused()) continue;\n        // 处理客户端命令\n        if (processPendingCommandsAndResetClient(c) == C_ERR) { \n            continue;\n        }\n        processInputBuffer(c);\n        // 如果处理完毕且有数据需要写回，那么将客户端放入clients_pending_write队列等待IO线程完成写操作\n        if (!(c-\u003eflags \u0026 CLIENT_PENDING_WRITE) \u0026\u0026 clientHasPendingReplies(c))\n            clientInstallWriteHandler(c);\n    }\n    server.stat_io_reads_processed += processed;\n    return processed;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230404011833-coty5b0",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011833-coty5b0",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"ID": "20230404011833-7qvallk",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011833-7qvallk",
						"updated": "20230404011833"
					},
					"Children": [
						{
							"ID": "20230404011833-5vtg6ox",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011833-5vtg6ox",
								"updated": "20230404011833"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "客户端A 先发起请求1，后客户端B发起请求2，服务端【无法保证】先接收到 请求1后接收到请求2，因为网络传输时间不同。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011833-yew9qnd",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011833-yew9qnd",
						"updated": "20230404011833"
					},
					"Children": [
						{
							"ID": "20230404011833-a4edx16",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011833-a4edx16",
								"updated": "20230404011833"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "客户端A 先发起请求1，后客户端A再次发起请求2，服务端 【可以保证】 先接收到请求1后接收到请求2，这个由TCP来保证。"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011833-wpxpche",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011833-wpxpche",
						"updated": "20230404011833"
					},
					"Children": [
						{
							"ID": "20230404011833-vqwl248",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011833-vqwl248",
								"updated": "20230404011833"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "服务端先接收到请求1，后接收到请求2，在多io环境下，redis【可以保证】先执行请求1后执行请求2。请求会先放到列表里，多IO线程从列表依次获取请求，进行命令读取及解析，待所有IO线程都处理完成之后，主线程才开始按序执行命令。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011833-xuyg12l",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230404011833-xuyg12l",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总结"
				}
			]
		},
		{
			"ID": "20230404011833-x0e0ulz",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230404011833-x0e0ulz",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"ID": "20230404011833-prp6zf8",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011833-prp6zf8",
						"updated": "20230404011833"
					},
					"Children": [
						{
							"ID": "20230404011833-q3bcw4e",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011833-q3bcw4e",
								"updated": "20230404011833"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Redis的主线程处理客户端连接操作"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011833-qeku0pu",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011833-qeku0pu",
						"updated": "20230404011833"
					},
					"Children": [
						{
							"ID": "20230404011833-hox9083",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011833-hox9083",
								"updated": "20230404011833"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Redis的IO线程处理客户端的读、写操作"
								}
							]
						}
					]
				},
				{
					"ID": "20230404011833-170x22k",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230404011833-170x22k",
						"updated": "20230404011833"
					},
					"Children": [
						{
							"ID": "20230404011833-lf1lf5l",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230404011833-lf1lf5l",
								"updated": "20230404011833"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Redis IO线程处理时，Redis主线程处理部分连接完毕后需要等待IO线程处理读写完成"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230404011833-wk2zfwh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230404011833-wk2zfwh",
				"updated": "20230404011833"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "我们可以简单地用一段话来描述Redis的请求处理流程：Redis主线程一次性获取最大为1000个客户端连接，将其放入到read pending队列中，在下一次aeMain主循环中调用beforeSleep函数，该函数将read pending队列和write pending队列中的客户端散列到IO线程中执行读写操作，并且自身负责下标为0处的客户端，然后等待IO线程执行 read、write 完毕后再执行。"
				}
			]
		}
	]
}