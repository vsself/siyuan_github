{
	"ID": "20230327120834-7moqxj5",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230327120834-7moqxj5",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20230327120837-5hrf18t\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230327120837-ihxuigr\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230327120837-ihxuigr\u0026quot;,\u0026quot;focusStart\u0026quot;:227,\u0026quot;focusEnd\u0026quot;:227}",
		"title": "多线程的优点",
		"updated": "20230327120846"
	},
	"Children": [
		{
			"ID": "20230327120837-5hrf18t",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327120837-5hrf18t",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "尽管面临很多挑战，多线程有一些优点使得它一直被使用。这些优点是："
				}
			]
		},
		{
			"ID": "20230327120837-5qh9rty",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230327120837-5qh9rty",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"ID": "20230327120837-bl7kbts",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230327120837-bl7kbts",
						"updated": "20230327120837"
					},
					"Children": [
						{
							"ID": "20230327120837-q45594s",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327120837-q45594s",
								"updated": "20230327120837"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "资源利用率更好"
								}
							]
						}
					]
				},
				{
					"ID": "20230327120837-3qck74y",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230327120837-3qck74y",
						"updated": "20230327120837"
					},
					"Children": [
						{
							"ID": "20230327120837-pdabfvx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327120837-pdabfvx",
								"updated": "20230327120837"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "程序设计在某些情况下更简单"
								}
							]
						}
					]
				},
				{
					"ID": "20230327120837-szm5pe2",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230327120837-szm5pe2",
						"updated": "20230327120837"
					},
					"Children": [
						{
							"ID": "20230327120837-x3cs2u9",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327120837-x3cs2u9",
								"updated": "20230327120837"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "程序响应更快"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230327120837-yspaue9",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230327120837-yspaue9",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "资源利用率更好"
				}
			]
		},
		{
			"ID": "20230327120837-uqvlzqh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327120837-uqvlzqh",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要："
				}
			]
		},
		{
			"ID": "20230327120837-6n4t1cu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327120837-6n4t1cu",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[code lang=”java”]\n5秒读取文件A\n2秒处理文件A\n5秒读取文件B\n2秒处理文件B\n———————\n总共需要14秒\n[/code]"
				}
			]
		},
		{
			"ID": "20230327120837-2vqkspp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327120837-2vqkspp",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "从磁盘中读取文件的时候，大部分的CPU时间用于等待磁盘去读取数据。在这段时间里，CPU非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序："
				}
			]
		},
		{
			"ID": "20230327120837-3jutd8g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327120837-3jutd8g",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[code lang=”java”]\n5秒读取文件A\n5秒读取文件B + 2秒处理文件A\n2秒处理文件B\n———————\n总共需要12秒\n[/code]"
				}
			]
		},
		{
			"ID": "20230327120837-kkheph1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327120837-kkheph1",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "CPU等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU大部分时间是空闲的。"
				}
			]
		},
		{
			"ID": "20230327120837-1vs9hlf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327120837-1vs9hlf",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。"
				}
			]
		},
		{
			"ID": "20230327120837-eggdr0n",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230327120837-eggdr0n",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "程序设计更简单"
				}
			]
		},
		{
			"ID": "20230327120837-dre7zou",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327120837-dre7zou",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在单线程应用程序中，如果你想编写程序手动处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。相反，你可以启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。"
				}
			]
		},
		{
			"ID": "20230327120837-z29e4ai",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230327120837-z29e4ai",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "程序响应更快"
				}
			]
		},
		{
			"ID": "20230327120837-o2e58sy",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230327120837-o2e58sy",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "将一个单线程应用程序变成多线程应用程序的另一个常见的目的是实现一个响应更快的应用程序。设想一个服务器应用，它在某一个端口监听进来的请求。当一个请求到来时，它去处理这个请求，然后再返回去监听。"
				}
			]
		},
		{
			"ID": "20230327120837-xxqrh3z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327120837-xxqrh3z",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "服务器的流程如下所述："
				}
			]
		},
		{
			"ID": "20230327120837-zzxoe6o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327120837-zzxoe6o",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[code lang=”java”]\nwhile(server is active){\nlisten for request\nprocess request\n}\n[/code]"
				}
			]
		},
		{
			"ID": "20230327120837-0el8l3n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327120837-0el8l3n",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果一个请求需要占用大量的时间来处理，在这段时间内新的客户端就无法发送请求给服务端。只有服务器在监听的时候，请求才能被接收。另一种设计是，监听线程把请求传递给工作者线程(worker thread)，然后立刻返回去监听。而工作者线程则能够处理这个请求并发送一个回复给客户端。这种设计如下所述："
				}
			]
		},
		{
			"ID": "20230327120837-kqqkf06",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327120837-kqqkf06",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[code lang=”java”]\nwhile(server is active){\nlisten for request\nhand request to worker thread\n}\n[/code]"
				}
			]
		},
		{
			"ID": "20230327120837-75zxrfd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327120837-75zxrfd",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这种方式，服务端线程迅速地返回去监听。因此，更多的客户端能够发送请求给服务端。这个服务也变得响应更快。"
				}
			]
		},
		{
			"ID": "20230327120837-ihxuigr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327120837-ihxuigr",
				"updated": "20230327120837"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "桌面应用也是同样如此。如果你点击一个按钮开始运行一个耗时的任务，这个线程既要执行任务又要更新窗口和按钮，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。相反，任务可以传递给工作者线程（word thread)。当工作者线程在繁忙地处理任务的时候，窗口线程可以自由地响应其他用户的请求。当工作者线程完成任务的时候，它发送信号给窗口线程。窗口线程便可以更新应用程序窗口，并显示任务的结果。对用户而言，这种具有工作者线程设计的程序显得响应速度更快。"
				}
			]
		}
	]
}